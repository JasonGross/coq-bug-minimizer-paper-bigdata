[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526184","html_url":"https://github.com/coq/coq/issues/3742#issuecomment-337526184","issue_url":"https://api.github.com/repos/coq/coq/issues/3742","id":337526184,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjE4NA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-15T06:06:41Z","updated_at":"2017-10-18T09:37:19Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nHere is some code that works in 8.4, but fails in trunk due to reordered existentials:\n\n(* File reduced by coq-bug-finder from original input, then from 287 lines to 208 lines *)\n(* coqc version trunk (October 2014) compiled on Oct 11 2014 1:13:41 with OCaml 4.01.0\n   coqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d65496f09c4b68fa318783e53f9cd6d5c18e1eb7) *)\nRequire Coq.Sorting.Permutation.\nExport Coq.Sorting.Permutation.\n\nDefinition BagInsertEnumerate\n           {TContainer TItem: Type}\n           (RepInv : TContainer -> Prop)\n           (benumerate : TContainer -> list TItem)\n           (binsert    : TContainer -> TItem -> TContainer) :=\n  forall inserted container\n         (containerCorrect : RepInv container),\n    Permutation\n      (benumerate (binsert container inserted))\n      (inserted :: benumerate container).\n\nDefinition BagEnumerateEmpty\n           {TContainer TItem: Type}\n           (benumerate : TContainer -> list TItem)\n           (bempty     : TContainer) :=\n  forall item, ~ List.In item (benumerate bempty).\n\nDefinition BagFindCorrect\n           {TContainer TItem TSearchTerm: Type}\n           (RepInv : TContainer -> Prop)\n           (bfind         : TContainer -> TSearchTerm -> list TItem)\n           (bfind_matcher : TSearchTerm -> TItem -> bool)\n           (benumerate : TContainer -> list TItem) :=\n  forall container search_term\n         (containerCorrect : RepInv container),\n    Permutation\n      (List.filter (bfind_matcher search_term) (benumerate container))\n      (bfind container search_term).\n\nDefinition BagFindStar\n           {TContainer TItem TSearchTerm: Type}\n           (RepInv : TContainer -> Prop)\n           (bfind : TContainer -> TSearchTerm -> list TItem)\n           (benumerate : TContainer -> list TItem)\n           (bstar : TSearchTerm) :=\n  forall container\n         (containerCorrect : RepInv container),\n    bfind container bstar = benumerate container.\n\nDefinition BagCountCorrect\n           {TContainer TItem TSearchTerm: Type}\n           (RepInv : TContainer -> Prop)\n           (bcount        : TContainer -> TSearchTerm -> nat)\n           (bfind         : TContainer -> TSearchTerm -> list TItem) :=\n  forall container search_term\n         (containerCorrect : RepInv container),\n    List.length (bfind container search_term) = (bcount container search_term).\n\nDefinition BagDeleteCorrect\n           {TContainer TItem TSearchTerm: Type}\n           (RepInv : TContainer -> Prop)\n           (bfind         : TContainer -> TSearchTerm -> list TItem)\n           (bfind_matcher : TSearchTerm -> TItem -> bool)\n           (benumerate : TContainer -> list TItem)\n           (bdelete    : TContainer -> TSearchTerm -> (list TItem) * TContainer) :=\n  forall container search_term\n         (containerCorrect : RepInv container),\n    Permutation (benumerate (snd (bdelete container search_term)))\n                (snd (List.partition (bfind_matcher search_term)\n                                     (benumerate container)))\n    /\\ Permutation (fst (bdelete container search_term))\n                   (fst (List.partition (bfind_matcher search_term)\n                                        (benumerate container))).\n\nDefinition BagUpdateCorrect\n           {TContainer TItem TSearchTerm TUpdateTerm : Type}\n           (RepInv : TContainer -> Prop)\n           (ValidUpdate : TUpdateTerm -> Prop)\n           (bfind         : TContainer -> TSearchTerm -> list TItem)\n           (bfind_matcher : TSearchTerm -> TItem -> bool)\n           (benumerate : TContainer -> list TItem)\n           (bupdate_transform : TUpdateTerm -> TItem -> TItem)\n           (bupdate    : TContainer -> TSearchTerm -> TUpdateTerm -> TContainer) :=\n  forall container search_term update_term\n         (containerCorrect : RepInv container)\n         (valid_update : ValidUpdate update_term),\n    Permutation (benumerate (bupdate container search_term update_term))\n                ((snd (List.partition (bfind_matcher search_term)\n                                      (benumerate container)))\n                   ++ List.map (bupdate_transform update_term)\n                   (fst (List.partition (bfind_matcher search_term)\n                                        (benumerate container)))).\n\nDefinition binsert_Preserves_RepInv\n           {TContainer TItem: Type}\n           (RepInv : TContainer -> Prop)\n           (binsert    : TContainer -> TItem -> TContainer)\n  := forall container item\n            (containerCorrect : RepInv container),\n       RepInv (binsert container item).\n\nDefinition bdelete_Preserves_RepInv\n           {TContainer TItem TSearchTerm: Type}\n           (RepInv : TContainer -> Prop)\n           (bdelete    : TContainer -> TSearchTerm -> (list TItem) * TContainer)\n  := forall container search_term\n            (containerCorrect : RepInv container),\n       RepInv (snd (bdelete container search_term)).\n\nDefinition bupdate_Preserves_RepInv\n           {TContainer TSearchTerm TUpdateTerm : Type}\n           (RepInv : TContainer -> Prop)\n           (ValidUpdate       : TUpdateTerm -> Prop)\n           (bupdate    : TContainer -> TSearchTerm -> TUpdateTerm -> TContainer)\n  := forall container search_term update_term\n            (containerCorrect : RepInv container)\n            (valid_update : ValidUpdate update_term),\n       RepInv (bupdate container search_term update_term).\n\nClass Bag (BagType TItem SearchTermType UpdateTermType : Type) :=\n  {\n\n    bempty            : BagType;\n    bstar             : SearchTermType;\n    bfind_matcher     : SearchTermType -> TItem -> bool;\n    bupdate_transform : UpdateTermType -> TItem -> TItem;\n\n    benumerate : BagType -> list TItem;\n    bfind      : BagType -> SearchTermType -> list TItem;\n    binsert    : BagType -> TItem -> BagType;\n    bcount     : BagType -> SearchTermType -> nat;\n    bdelete    : BagType -> SearchTermType -> (list TItem) * BagType;\n    bupdate    : BagType -> SearchTermType -> UpdateTermType -> BagType\n  }.\n\nClass CorrectBag\n      {BagType TItem SearchTermType UpdateTermType : Type}\n      (RepInv            : BagType -> Prop)\n      (ValidUpdate       : UpdateTermType -> Prop)\n      (BagImplementation : Bag BagType TItem SearchTermType UpdateTermType) :=\n  {\n\n    bempty_RepInv     : RepInv bempty;\n    binsert_RepInv    : binsert_Preserves_RepInv RepInv binsert;\n    bdelete_RepInv    : bdelete_Preserves_RepInv RepInv bdelete ;\n    bupdate_RepInv    : bupdate_Preserves_RepInv RepInv ValidUpdate bupdate;\n\n    bfind_star        : BagFindStar RepInv bfind benumerate bstar;\n\n    benumerate_empty  : BagEnumerateEmpty benumerate bempty;\n    binsert_enumerate : BagInsertEnumerate RepInv benumerate binsert;\n    bfind_correct     : BagFindCorrect RepInv bfind bfind_matcher benumerate;\n    bcount_correct    : BagCountCorrect RepInv bcount bfind;\n    bdelete_correct   : BagDeleteCorrect RepInv bfind bfind_matcher benumerate bdelete;\n    bupdate_correct   : BagUpdateCorrect RepInv ValidUpdate bfind bfind_matcher benumerate bupdate_transform bupdate\n  }.\n\nRecord BagPlusProof (TItem : Type) :=\n  { BagTypePlus : Type;\n    SearchTermTypePlus : Type;\n    UpdateTermTypePlus : Type;\n\n    RepInvPlus : BagTypePlus -> Prop;\n    ValidUpdatePlus : UpdateTermTypePlus -> Prop;\n\n    BagPlus : Bag BagTypePlus TItem SearchTermTypePlus UpdateTermTypePlus;\n    CorrectBagPlus : CorrectBag RepInvPlus ValidUpdatePlus BagPlus\n  }.\nArguments SearchTermTypePlus [TItem] _.\nArguments RepInvPlus [TItem] _ _.\nArguments ValidUpdatePlus [TItem] _ _.\n\nDefinition WFBagPlusType {TItem} (Index : BagPlusProof TItem)\n  := sigT (RepInvPlus Index).\n\nInstance WFBagPlusTypeAsBag {TItem}\n         (Index : BagPlusProof TItem)\n: Bag (WFBagPlusType Index) TItem (SearchTermTypePlus Index)\n      (sigT (ValidUpdatePlus Index)).\nProof.\n  destruct Index as [? ? ? ? ? BagPlus' CorrectBagPlus'];\n  destruct BagPlus'; destruct CorrectBagPlus'; simpl in *.\n  econstructor 1; simpl; try solve [eassumption].\n\n  econstructor; eauto.\n\n  intro; apply bupdate_transform0; apply X.\n\n  intros; apply benumerate0; apply X.\n\n  intros; destruct X; apply (bfind0 x X0).\n\n  intros; destruct X; econstructor; eapply binsert_RepInv0; apply r.\n\n  intros; destruct X; eapply bcount0; [apply x | apply X0 ].\n\n  intros x search_term; constructor.\n  -\n    eapply (fst (bdelete0 (projT1 x) search_term)).\n  -\n    econstructor; eapply bdelete_RepInv0; apply (projT2 x).\n\n  -\n    intros x search_term update_term; destruct x; destruct update_term;\n    econstructor.\n    eapply bupdate_RepInv0.\n    apply r.\n    apply v.\n    Grab Existential Variables.\n    Fail apply X0.\n    3:apply X0 || fail \"not 8.4\".\n    2:(simpl; apply search_term) || fail \"not 8.4\".\n    1:(simpl; apply search_term) || fail \"not 8.4\".\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526184/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526187","html_url":"https://github.com/coq/coq/issues/3742#issuecomment-337526187","issue_url":"https://api.github.com/repos/coq/coq/issues/3742","id":337526187,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjE4Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-15T08:07:03Z","updated_at":"2017-10-18T09:37:19Z","author_association":"CONTRIBUTOR","body":"Comment author: @aspiwack\n\nI don't know why that is (my guess though is that it is not Grab Existential Variable which changed, but the precise order in which the tactics are run, hence the order in which the existential variables are generated). But I don't think it is anything which can be made very robust unfortunately.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526187/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526188","html_url":"https://github.com/coq/coq/issues/3742#issuecomment-337526188","issue_url":"https://api.github.com/repos/coq/coq/issues/3742","id":337526188,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjE4OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-15T18:23:14Z","updated_at":"2017-10-18T09:37:19Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nHere is a much simpler example of code that works in 8.4, but fails in trunk:\n\nGoal forall (P Q : nat -> Prop) (f : nat -> nat -> nat)\n            (QH : forall x, Q x)\n            (H : forall (y : nat) (x : { x : nat | x = y }),\n                   Q y -> P (f (proj1_sig x) y)),\n       ({ x : nat | P x } * { x : nat | P x } * { x : nat | P x })%type.\n  intros.\n  repeat split.\n  { econstructor. eapply (@ H 0). apply QH. }\n  { econstructor. eapply (@ H 1). apply QH. }\n  { econstructor. eapply (@ H 2). apply QH. }\n  Grab Existential Variables.\n  { (exists 2; reflexivity). }\n  { (exists 1; reflexivity). }\n  { (exists 0; reflexivity). }\nDefined.\n\nIn 8.4, the existential variables seem to be given in reverse order of the goals to which they were generated.  In trunk, they seem to be given in the same order as the goals in which they were generated.  If this is correct, although trunk behavior seems saner, I don't think there's a good reason to break backwards compatibility here (or, at least, no good reason to break it without providing a flag to restore the old behavior).\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526188/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526190","html_url":"https://github.com/coq/coq/issues/3742#issuecomment-337526190","issue_url":"https://api.github.com/repos/coq/coq/issues/3742","id":337526190,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjE5MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-15T18:35:53Z","updated_at":"2017-10-18T09:37:19Z","author_association":"CONTRIBUTOR","body":"Comment author: @aspiwack\n\nApparently, Grab… used to be an [Evd.undefined_list], now it is and [Evar.Map.bindings Evd.undefined_map]. It seems [bindings] and [undefined_list] have a different ordering.\n\nThe fix is a [List.rev] away. I will try not to forget to fix it.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526190/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526193","html_url":"https://github.com/coq/coq/issues/3742#issuecomment-337526193","issue_url":"https://api.github.com/repos/coq/coq/issues/3742","id":337526193,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjE5Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-16T13:17:12Z","updated_at":"2017-10-18T09:37:20Z","author_association":"CONTRIBUTOR","body":"Comment author: @aspiwack\n\nI've just fixed it ( b5c5f67c628e6ba7c987e9a306f7a0efdebf85cf ).\n\nAs an added bonus, though, it is now possible to call back the goals in the middle of the proof using Unshelve (rather than just at the end of the proof with Grab Existential Variables).\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526193/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]