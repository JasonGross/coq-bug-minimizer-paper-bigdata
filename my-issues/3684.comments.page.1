[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525158","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525158","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525158,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE1OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-09-30T16:54:43Z","updated_at":"2017-10-18T09:34:38Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nDefinition foo : Set.\n  refine ($(abstract admit)$).\n(* Toplevel input, characters 15-42:\nAnomaly: Uncaught exception Not_found(_). Please report. *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525158/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525159","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525159","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525159,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE1OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-07T19:21:01Z","updated_at":"2017-10-18T09:34:38Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nRemark: When refine typecheck proof, the (abstracted) constant foo_subproof is not found in the environment.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525159/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525160","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525160","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525160,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE2MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-07T20:15:49Z","updated_at":"2017-10-18T09:34:38Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\nThis seems another instance of the \"the system ought to be functional\" syndrome.\n\nMy guess is that refine \"fixes\" the environment in which it will typecheck the term before the abstract tactic updates imperatively the one in Global and updates the one in the tactic monad. The other possibility is that the updates made during ltac argument interpretation, that here involve calling a tactic, are somehow lost (PMP, the state of tactic monad for $(..)$ is retained?).\n\nUsing abstract is bad (even outside the STM/Paral-ITP business, that here really cannot play a role).  Using abstract inside $(stuff)$ is really a recipe for a disaster.\n\nIndependently of the fix, I think we should add a msg_warning to abstract. Something like \"this tactic is broken, don't use it in new code!\".\nAt least users (not reading my complaints on the bugzilla) would be warned.\n\nBest,\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525160/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525161","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525161","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525161,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE2MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-07T21:08:07Z","updated_at":"2017-10-18T09:34:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nDo we have an evar-map-compactification tactic yet that can serve as a replacement for [abstract] in the realm of memory-management in opaque proofs?\n\nI also don't think [abstract] should be deprecated until there's a good story for an alternative way of marking some part of the term as \"this term is frozen, and has already been typechecked, so you don't need to look inside of it for subterm selection, and you don't need to retypecheck it.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525161/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525162","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525162","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525162,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE2Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-08T11:15:04Z","updated_at":"2017-10-18T09:34:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nEnrico: since \"abstract\" (and apparently even \"abstract using\") do not survive the Qed/Defined as part of the global env, would it make sense to declare it to the goal env only? Then, we could turn (by need) those \"imperative\" functions looking for the abstract name in the global env to functions taking an env as argument and pass them the goal env instead of the global env?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525162/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525163","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525163","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525163,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE2Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-08T22:23:16Z","updated_at":"2017-10-18T09:34:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\n@ Hugo: yes, it would make sense.  But note that \"Defined\" does behave as in 8.4:\nabstracted sub proofs are not inlined but declared globally during \"Defined\".\nThere was request for that.  In any case I cannot postpone Defined proofs, so\nfrom the STM point of view, I lose nothing doing that.  Still, the \"future proof\ncomputation\" produces a proof and a list of side effects that are declared during\nDefined on top of the original env (not the one imperatively modified on the go),\nsee declare.ml, declare_constant and then declare_sideff.\n\n@ Jason:\n- I will push a vernacular to compact th evar map and call the GC of OCaml to\n  give a weapon to people fighting high memory usage.  It can't be a tactic, sorry.\n- ssr has an \"abstract:\" tactic (since 1.5).  Would you mind trying it?  It uses\n  the context (as in the logic) to cache the typing, and variables to provide\n  opacity.  But abstracted subproofs are scoped, there is no global magic.  One\n  declares an \"abstract variable\" and later on assigns to it a type and a proof.\n  It is just a creative use of \"cut\" and evars, and was motivated for very \n  different purposes (proof refactoring, sub-proof extrusion in particular)\n  but if it works for you I'm ready to code it again in Coq.\n\nI hope abstract has no other useful \"side effect\".\nOnce more, that tactic is broken in 8.5, its current semantics fundamentally\nclashes with the new proof engine and the STM.  Both components try to make\nsense of things giving a purely functional interpretation to tactics/proofs.\n\"abstract\" is one of the few imperative  bits still standing in the way.\n\nWe must tell our users that it is (and IMO will always be) buggy.\nAs you correctly point out, we should provide valid alternatives.\nFixing bugs related to abstract is, in my opinion, a waste of time.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525163/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525166","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525166","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525166,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE2Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T00:13:49Z","updated_at":"2017-10-18T09:34:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n> ssr has an \"abstract:\" tactic (since 1.5)\n\nRemind me where I can get ssr 1.5 that works with trunk?  (Actually, one that works with e8726550e01e51ef3ccf8602f2ecbe2b3737cca3, trunk from about a month ago, would be preferred; we're waiting to bump the version of trunk HoTT is tied to until the massive slowdown of bug [BZ#3783](https://github.com/coq/coq/issues?q=is%3Aissue%20%22Original%20bug%20ID%3A%20BZ%233783%22) has some kind of resolution.)  I'll run a diff on the difference between using [abstract], using [abstract:], and not using anything at all, is.\n\nUsing ssr 1.5 with 8.4pl3, I cannot figure out how to use [abstract:]\n\nGoal True.\n  abstract: exact I. (* Error: No such section variable or assumption: exact. *)\n  abstract: (exact I). (* Anomaly: Uncaught exception Option.IsNone. Please report. *)\n  abstract: I. (* Error: No such section variable or assumption: I. *)\n  pose proof I as j.\n  abstract: j. (* Error: not an abstract constant: j *)\n  \nIn any case, here is an example of where I want [abstract] to speed things up.  If replacing [abstract] with [abstract:] does not change the performance, then I'm happy to use it as a replacement in my cases:\n\nFixpoint twos (n : nat) (A : Type) :=\n  match n with\n    | 0 => A\n    | S n' => twos n' (prod A A)\n  end.\n\nDefinition twos_trans : Type.\n  let x := constr:(let n := 11 in twos n Set = twos n Set) in\n  let x' := (eval compute in x) in\n  exact x'.\nDefined.\n\nDefinition twos_qed : Type.\n  let x := constr:(let n := 11 in twos n Set = twos n Set) in\n  let x' := (eval compute in x) in\n  exact x'.\nQed.\n\nDefinition twos_abs : Type.\n  let x := constr:(let n := 11 in twos n Set = twos n Set) in\n  let x' := (eval compute in x) in\n  abstract exact x'.\nDefined.\n\nGoal twos_qed. hnf. Time match goal with |- ?G => set (H := G) end. Abort. (* 0 s *)\nGoal twos_abs. hnf. Time match goal with |- ?G => set (H := G) end. Abort. (* 0 s *)\nGoal twos_trans. hnf. Time match goal with |- ?G => set (H := G) end. Abort. (* 2.041 s *) (* grows with the size of [n] *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525166/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525168","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525168","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525168,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE2OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T10:41:24Z","updated_at":"2017-10-18T09:34:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\n> Using ssr 1.5 with 8.4pl3, I cannot figure out how to use [abstract:]\n\nIt is not unexpected if you don't read the doc...\n\nAs I was saying, abstract constants in ssr are scoped, they born and die inside a single proof (they born with a [: foo ] intro pattern and die with abstract:).  If what you posted is not an oversimplification of your real code,\nthen abstract: has no use for you.  Your abstracted constants are global.\n\nA real example would anyway help, here I see no $( )$ and the statements you obtain in the opaque variants are not provable, so I'm a bit puzzled.  I'm also not surprised that manipulating a goal that grows as n has a cost that depends on n.\n\nBest,\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525168/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525170","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525170","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525170,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE3MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T11:06:48Z","updated_at":"2017-10-18T09:34:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI've stared at the examples on page 34 of https://hal.inria.fr/inria-00258384v15/document, and still can't figure out [abstract:].  The furthest I've gotten is:\n\nDefinition twos_abs : Type.\n  let x := constr:(let n := 11 in twos n Set = twos n Set) in\n  let x' := (eval compute in x) in\n  have [:x0] @ i : Set := x'; first exact x'. abstract: x0. (* Error: abstract constant x0 already used *)\nDefined.\n\nAnd I should go to sleep and stop bashing my head against [abstract:].\n\n> Your abstracted constants are global.\n\nWhat do you mean?\n\n\n> A real example would anyway help\n\nI don't have any real examples involving [$(abstract ...)$]; I'm worried about my use-case of [abstract] (no tactics in terms).\n\nThere are two completely disjoint reasons that I know of to use [abstract].  One is memory usage, as in bedrock, and, as I understand it, the evar-map-compactification vernacular will handle this.\n\nThe other use is to hide proof terms from the type-checker.\n\n> I'm also not surprised that manipulating a goal that grows as n has a cost that depends on n.\n\nIndeed, which is why I want [abstract].  The typical use-case is\n\nDefinition foo : foo_type.\nProof.\n  refine (computational part).\n  abstract (tactic to generate a humongous proof term to solve a moderately large type that's ugly and painful to copy/paste).\nDefined.\n\nDefinition bar : type_involving_foo.\nProof.\n  unfold foo.\n  rewrite baz.\n  ...\nQed.\n\nIf [unfold]ing [foo] results in a gigantic term showing up in my goal, then [rewrite] (and [set] and everything else) will be unreasonably slow.  So whatever this abstract-replacement does, I need it to be the case that when I [unfold foo], subsequent manipulations aren't slowed down by the size of the [abstract]ed term.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525170/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525171","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525171","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525171,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE3MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T11:43:57Z","updated_at":"2017-10-18T09:34:40Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\nYour use case works in trunk, this bug is about $( .. abstract .. )$.\n\nYou constants are global because they survive the end of a proof.\n\nThe very same problems you face can happen inside a proof, you define a dependent pair hiding the proof to the rest of the proof script, and\nabstract: deals with it.\n\n@ Hugo, what is the status of $()$ in turnk?\nIt its semantics settled?  If not we should not recommend using it.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525171/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525173","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525173","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525173,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE3Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T11:51:00Z","updated_at":"2017-10-18T09:34:40Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\nMaybe I was not clear.\n\n\"abstract\" in a 8.4 proof script ending with Defined must work as before, and shall continue to work like that.\n\n\"abstract\" in conjunction with any other 8.5 feature should be avoided.\n\nThe new vernacular I'll commit will make abstract not to be used for dealing with memory management.\n\n\"abstract\" is broken, and there are \"hacks\" to make it work on Defined proofs.\nI don't want to pollute the system with other hacks to make it work in other contexts, especially in new (w.r.t. 8.4)  ones.\n\nI hope I made myself clear this time.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525173/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525174","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525174","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525174,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE3NA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T15:29:38Z","updated_at":"2017-10-18T09:34:40Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\n> what is the status of $()$ in turnk?\n\nIt is somehow up to us. If it is too fragile, we can tag it as experimental. It is basically PMP who has the expertise on this feature, so let's ask him.\n\n(Maybe should we aim at a IMO less \"hackish\" syntax too, I think there were proposals like ?[_:=tac] or something like that).\n\nEnrico, I'm otherwise wondering what you exactly mean by \"abstract is broken\". Do you mean that it is conceptually a bad solution to a real problem, or that the Coq implementation is not functional enough to make abstract robust enough, or that it breaks modularity (and that e.g. we should add something like \"Defined using (foo_subproof1 : typ1) (foo_subproof2 : typ2).\" to support modular reuse of abstracted proofs), or that it is the more general possibility to issue global declarations in the middle of a proof script which you would like to revise, or some other reasons, ...? In particular, assuming we had unlimited time resources, what would you suggest to do?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525174/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525179","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525179","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525179,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE3OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T16:23:34Z","updated_at":"2017-10-18T09:34:40Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\n@ Hugo, sorry for the long message, but I hope summing up will help taking a final decision on abstract.\n\nFor the STM, the execution of the text between Proof..Qed is represented with a pure computation, pure like in haskell, very pure.  Only a pure computation can be run when one wants and in the context (system state) one wants.  (OK, internally the code is not pure, but via freze/unfree one can simulate that, and it is also what is imposed\nby multi-proces parallelism: a side effect in a worker process is simply lost, it will never reach the master).\nThe only output of a pure computation is what it returns, that is a proof term.\n\nAn output \"returned\" via a global side effect does not fit.\n\nThe tactic monad represents  proof steps as pure functions, and here again the imperative behavior of abstract does not fit well.  Just to be clear, the tactic monad carries an env, but env in Coq is too much stuff.  IMO it should only carry the \"local context\" part of the env.\n\nw.r.t. the STM, abstract is \"supported\", in the sense that internally a pure proof computation returns the proof term + the list of global constants, and\nif the proof ends with Qed such constants are inlined, if it ends with Define the execution of Defined declares in one go all these extra lemmas plus the main one (simulating the old imperative behavior).  \n\nw.r.t. the tactic monad I don't know, I thought that having tclSIDEFF also update the env in the monad was enough to make the whole thing as correct as the STM, but it is not sufficient.  This bug shows that the problem is more fine grained for the tactic monad (I did not investigate, but somehow the side effect of the abstract inside $()$ is lost or not seen by refine).  Maybe this is the last bug standing, maybe not.\n\nWhat it is clear is that any tactic that has an effect different from manipulating the evar map is not a tactic in the new sense, that I think is the correct one.  Abstract, as it is today, is not a tactic.\n\nNow, as far as I know abstract is used to:\n1 avoid evarmap explosion by cutting it.  At some extent this can be coded with a vernacular,\n  I had the patch attached to another bugreport, I'll try to resurrect the code next week.\n2 write computable code using tactics but hiding the non-computational parts via abstract.\n  This is bad practice in my humble opinion.  I'd rather have something \n  like Program taking care of computing the statements, open lemmas/goals form them, an \n  finally  define the program using the lemmas.  Still this way of doing thing is widespread,\n  Adam does it for example. The STM supports it, in response to his request.\n3 avoid running reflexive tactics twice.  This is a nice trick by Guillame: if you do\n   abstract ( something_no_check ring )\n  the use immediately has the result (success or failure) but the \"env\" works like a cache\n  and the long computation has not to be redone at Qed time.  I proposed a patch to have\n  the same feature: ask the kernel to add a cast, sign in in a sort of cryptographically\n  sense, and re-accept the term at Qed time is the signature is valid.  No imperative side\n  effect, just a cache.  Unfortunately the code was not that nice, during proof construction\n  one works with Vars while Qed encounters Rels, and the conversion is verbose.  Also the\n  notion of signature I had worked will inside the process boundaries.  In a multi process\n  scenario things have to be done differently (Not with ==, since marshal/demarshal breaks \n  ==). \n\nAs far as I can tell, 1 is easily fixable, 2 works, 3 does not.\n\nThe bug report of jason is a new point, 4, that is abstract + $()$.\n\nHence my position of telling people to avoid abstract for any new \"nice tricks\", because\nit is unclear if it can be made to work without piling up too many hacks.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525179/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525181","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525181","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525181,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE4MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T16:32:12Z","updated_at":"2017-10-18T09:34:41Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\nThis would make abstract useless:\n  \"Defined using (foo_subproof1 : typ1) (foo_subproof2 : typ2)\"\n\nThe point of using abstract is to avoid having to type typ1 and typ2,\notherwise one could just start by proving the two lemmas, and then\nuse them directly without abstract.\n\nAbstract lets people do the exact opposite: pretend they proved the two\nlemmas in advance without stating them (too large statements I guess...).\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525181/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525183","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525183","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525183,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE4Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T20:13:31Z","updated_at":"2017-10-18T09:34:41Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nI think you are pointing the right question. If the tactic monad were updating not only the evar map but also an environment, then abstract would become pure, since a Proof..Qed or Proof..Defined segment would (functionally) return a proof-term + an extension of the environment.\n\n> This would make abstract useless:\n>   \"Defined using (foo_subproof1 : typ1) (foo_subproof2 : typ2)\"\n> \n> The point of using abstract is to avoid having to type typ1 and typ2,\n> otherwise one could just start by proving the two lemmas, and then\n> use them directly without abstract.\n\nI agree that this is probably not what we want (except maybe for \"abstract using\" - if ever really useful). I guess that for abstract we simply want to forbid to refer to the subproof name, with what your solution to make the abstracted subproofs local to the main proof complies.\n\nComing back to my question, if I summarize your answer, my understanding is that it is not abstract which is essentially bad but its implementation, i.e. the issue that a Proof..Qed script is not working in a functional way over the environment.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525183/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525185","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525185","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525185,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE4NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T21:16:50Z","updated_at":"2017-10-18T09:34:41Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n> \"abstract\" in conjunction with any other 8.5 feature should be avoided.\n\nAh, ok, thanks for rephrasing.  I was under the impression that you wanted to remove, or deprecate, [abstract] entirely.\n\nIn particular,\n\n> Independently of the fix, I think we should add a msg_warning to abstract. Something like \"this tactic is broken, don't use it in new code!\".\n\nI think this is not the best idea if [abstract] in [Defined] proofs is fully supported and the only solution being provided to a particular problem.  (If there's any way to tell when [abstract] is being used in other contexts, I think it's fine to emit warnings in those contexts.)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525185/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525187","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525187","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525187,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE4Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-09T22:14:54Z","updated_at":"2017-10-18T09:34:41Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\nIt is already like that. The monad holds (together with the evar map) a copy of the env (and also the list of side effects, that I put in the evar map IIRC).\n\nAt Qed time I hide the side effects, I make them local to the proof term.\nIf I don't do that, than I cannot produce in advance a system state without\nexecuting the proof.  Today I assume the env after the Qed has just one extra entry (the one being proved).  By hiding side effects I force the computation to be pure in that sense.  E.g. I cannot know how many extra entries the env and the nametab should have without executing the proof, just imagine \"trivial || abstract auto\", or a user defined tactic.\n\nThis bug is, IMO, due to the fact that refine typechecks the term using an environment that is not the one altered by the interpretation of its argument.\nIt is probably fixable...\n\nI guess you are right, if we manage to have abstract do not produce global\nconstants, but say just local cuts, then things are way more clean.\nThe hard part is that such a cut is not local, one cannot create it by instantiation.  In ssreflect the \"abstract\" tactic is split into two\ntactics: one does the cut, but without fixing the formula; the other one\nfixes the formula and starts (focuses its proof).  Imagine this pseudo Coq:\n\n  cut ?[f] as f\n  .....\n  here one has     f : ? |- G\n  ....\n  abstract tac as ?f.  (* runs tac in the right context, e.g. no f *)\n  ...\n  here one has     f : T |- G     and f is \"opaque\" and hides what-tac-does\n  ...\n  the final proofterm is   ...  (fun f : T => ....) (what-tac-does)  ....\n\n\nIn this way the scope of f is user provided, and the actual beta redex is\ngenerated when it is not too late.  When you call abstract in standard Coq\nit is too late, one should pick the proof term, go up some nodes, make the\nbeta redex... Not what a tactic in the current (and right) sense can do.\n\nSo you really need to split abstract in two steps, unless I'm missing\nsomething.  We don't have fancy control operators in CIC, but here I'm\ntouching a ground I do not master.\n\nI think we can't fix \"abstract\" as it is today, but a more civilized\nversion of abstract can exist, if one makes its scope explicit.\n\nBest,\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525187/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525188","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525188","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525188,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE4OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-10T08:43:38Z","updated_at":"2017-10-18T09:34:41Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nEnrico, I understand that you like the abstract from ssreflect. Please feel free to implement an \"abstract\" of this form.\n\nWith respect to the existing abstract, it seems to me that you are making an implicit assumption that if abstract generates global constants, you \"cannot produce in advance a system state without executing the proof\". I don't see any reason why it would be such.\n\nWhen you see a \"Proof..Qed\" block, you are able to produce a system state which is usable for the rest of the compilation even though you are missing the actual body of the theorem. This is working because you're relying here on the weakening property that if \"Gamma, c:T, Gamma' |-\" is well formed and \"Gamma |- t:T\" holds, then \"Gamma, c:=t:T, Gamma' |-\" is well-formed too.\n\nThen, what's wrong in using this very same state \"Gamma, c:T, Gamma' |-\" for compiling what comes after the Proof..Qed block and to allow adding also global constants produced by the Proof..Qed block, i.e. to rely on the weakening property that if \"Gamma, c:T, Gamma' |-\" and \"Gamma, Delta |- t:T\" then \"Gamma, Delta, c:=t:T, Gamma' |-\" for an arbitrary context Delta of admit's or abstract's produced by the proof?\n\nOf course, I'm not taking here about \"abstract using foo\" where the user intends to later on refer to \"foo\". In this case, some form of \"Defined using foo : T.\" would be mandatory.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525188/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525189","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525189","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525189,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE4OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-10T08:48:48Z","updated_at":"2017-10-18T09:34:42Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nHugo, you're suggesting that abstracted constants be defined as if with `Local Definition`, and not exported to be usable in other files?  And perhaps declare that that `abstract ... using ...` require a corresponding `Qed using ...`?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525189/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525191","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525191","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525191,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE5MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-10T09:05:52Z","updated_at":"2017-10-18T09:34:42Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\n> you're suggesting that abstracted constants be defined as if with `Local \n> Definition`, and not exported to be usable in other files?  And perhaps \n> declare that that `abstract ... using ...` require a corresponding `Qed\n> using ...`?\n\nYes, a possible approach to the unpredictability of which constants may be declared by a proof could have been to introduce a kind of constants tagged as unreferrable (at least from coqc). But I'm fine with Enrico's approach to instead make these global constants local since it fulfills the same needs (and avoid to add such a new kind of private constant).\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525191/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525193","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525193","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525193,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE5Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-10T09:28:07Z","updated_at":"2017-10-18T09:34:42Z","author_association":"CONTRIBUTOR","body":"Comment author: @aspiwack\n\n\n> The tactic monad represents  proof steps as pure functions, and here again\n> the imperative behavior of abstract does not fit well.  Just to be clear,\n> the tactic monad carries an env, but env in Coq is too much stuff.  IMO it\n> should only carry the \"local context\" part of the env.\n\nI don't understand what you mean by \"local context\" but whatever definition which does not include the whole environment surely cannot work. I mean tactics need to access the global env, don't they? All of it. Either they do it directly (icky sticky ugly side effect), or I pass the global env as an argument.\n\n> w.r.t. the tactic monad I don't know, I thought that having tclSIDEFF also\n> update the env in the monad was enough to make the whole thing as correct as\n> the STM, but it is not sufficient.  This bug shows that the problem is more\n> fine grained for the tactic monad (I did not investigate, but somehow the\n> side effect of the abstract inside $()$ is lost or not seen by refine). \n> Maybe this is the last bug standing, maybe not.\n\nThe capacity to modify the environment during a tactic is sufficient internally to a tactic, but not to a proof. We would need to modify the proof to carry the updated environment which is not done at the time. But it presumably wouldn't be hard (and even better as [Global.env] would only be called at proof creation: fewer icky sticky ugly side effects).\n\n> What it is clear is that any tactic that has an effect different from\n> manipulating the evar map is not a tactic in the new sense, that I think is\n> the correct one.  Abstract, as it is today, is not a tactic.\n\nI beg to differ: any function which as an effect which is not clearly delineated by the type of the monad's \"run\" is not a tactic. But it can do (and does) plenty of other stuff than updating an [evar_map].\n\nI would be fine with updating the environment. And I like, for instance, Hugo's suggestion of using \"private constant\".\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525193/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525195","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525195","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525195,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE5NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-10T15:44:38Z","updated_at":"2017-10-18T09:34:42Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\n@ Arnaud: The local context is for me the context (rel_context + var_context).\nThe env is much more, it is also the set of global constants.\n\nWe all agree that tactics have to access the environment, but they\nalso have to access much more of the system state.  They access the\nvarious data bases of hints, of coercions, of type classes, of canonical \nstructures, nametab, ... there are even tactics that do not work with an\nempty libstack.\n\nI don't know why you added the env to the monad, but \"because tactics\nneed it\" is not a good reason.  They need much more.  If you added it\nto make \"abstract work\" then I'm afraid you were too optimistic: there is\ncode reading/writing global.env.  I think that, after the patch that\nmakes tclSIDEFF also update the env in the monad, tactics are ok (the\nglobal.env  and the monad env should be in sync, or at least all the\ntactic code that writes global.env, according to my knowledge, now also\nupdates the monad).\n\nIn my view, during a proof, the global system state should stay constant.\n\nUnfortunately there are exceptions, like sticking an Hint in the middle of\na proof script.  I take this as an example, I hope it makes my point more clear:\nIf you duplicate in the monad the piece of system state that holds the db of\nhints, things will stop to work: tactics will not see the new hint.  Unless\nthe Hint command does also update the monad.  This is what happens today with\nabstract, that calls tclSIDEFF.\n\nIMO, the simplest thing is to put in the monad only the system state tactics\ncan write (essentially the evar map) and access the rest globally.\nIf one sticks a Hint in the middle of tactics, the effect will just be visible\nto the tactics running afterwards.\nOf course I would prefer not to have a global state at all, and pass to .run\na read only component (the system state).  The STM already has a notion of\nsystem state, but the only way it has to \"pass it\" to vernac (hence tactic)\ninterp is to install it globally.\n\n@ Hugo: I agree that it is logically consistent, but:\n1) it works only if you make these extra constants private (not visible via\n   the nametab for example, otherwise the nametab for the rest of the file\n   would be incomplete).  \n2) it requires to change the data structure and add special cases\n   to the type checker: where does it looks for these constants? Not in\n   the env.  Are they named using a regular kernel name?\nFollowing this path may fix problem 3. in my long message, but requires some\nextra coding effort.  We thought (with Bruno) about adding a notion of\nsub-constants to represent the side effects of abstract, but inlineing seemed\na simpler solution.\nAlso it is odd: one can Print a proof term, that displays\nfoo_subproof, but can't Print foo_subproof because it is not a valid name.\nOr a specific naming like foo#subproof1 that Print can follow, but not the\nnametab.  It is not that clean IMO.\n\n\nBest,\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525195/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525198","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525198","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525198,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE5OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-10T20:05:29Z","updated_at":"2017-10-18T09:34:42Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nAs far as abstract is concerned, as I said, I'm fine with pushing the subproofs as local definitions at toplevel of the proof, as far as users are satisfied with it.\n\nRegarding the dilemma between the need for private names and the expected reparsability of terms (whether these are names of constants or simply of goal variables), it is a general issue to which I don't know a \"good\" solution.\nUsing a private name space or a private subset of Id.t? Allowing to parse private names only with an explicit warning, allowing to parse them only in an interactive session, allowing to parse them only by giving some kind of \"SesameAfficheToi\" prefix to the command, ...?\n\nOtherwise, as far as I'm concerned, I'm satisfied by the clarification of your point of view about abstract and by my understanding of the conclusions that seem to come out of the discussion: \n\n- abstract is not \"bad\"\n- it might be the case, considering the work you already made with tclSIDEFF, \nthat the here-discussed bug is only a local fixable bug of $()$ (PMP?)\n- that having the proof state made functional over the (logical) environment would simplify the implementation of abstract by not let it enter the global environment until Qed/Defined is reached, with the question whether we need (even for Defined) to have the abstracted subproofs turned into global rather than local definitions still possibly under discussion\n- that the status of global logical and not logical declarations in the middle of a proof script remains unclear, whether we want to allow them, whether they have to be interpreted both locally for the proof and globally for the rest of the session, etc.\n- that the need for and status of \"abstract using\" is yet to be clarified.\n\nI also looked a bit at ssreflect's \"locally scoped abstract\" but I'm unsure I seized the interest of it compared to Coq's \"unscoped abstract\" (you somehow said it was for proof refactoring and subproof extrusion - do you think it can be of general interest for Coq users?).\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525198/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525199","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525199","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525199,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTE5OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-12T09:12:46Z","updated_at":"2017-10-18T09:34:43Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\n> I also looked a bit at ssreflect's \"locally scoped abstract\" but I'm unsure I \n> seized the interest of it compared to Coq's \"unscoped abstract\" (you somehow \n> said it was for proof refactoring and subproof extrusion - do you think it can \n> be of general interest for Coq users?).\n\nIt has two uses:\n1) put in the context a dependent pair hiding the proof part:\n \n   pn : P n\n   n : subtype-something := (n, pn)\n   ======\n   Goal\n\n2) reuse a \"deeply nested subproof\" pulling it out at the toplevel\n\nI guess the most readable explanation is here:\n\n  https://sympa.inria.fr/sympa/arc/ssreflect/2014-04/msg00009.html\n\nThe effects (display + efficiency) are only there during proof construction.\n\nIf one ends such a proof with Defined, these these beta redexes don't truly hide\nthe proof (they will end up in head position).  So it is only OK for \"proofs\".\n\nYou are right in arguing that Coq's abstract is \"more powerful\".  It is just that it\nis not a \"tactic\" in the sense I explained (evar instantiation procedure), this is the\nroot of all problems.\n\nThat is all for your question about abstract: in ssr.\n\nBack to \"abstract\".\n\nI think the preferred style for \"building programs via tactics\" should be\na different vernacular (that the STM would not optimize, or would optimize differently)\nthat enables a special \"tactic\" (preferably just a vernacular, but I don't know \nif that would suffice) to declare a sub-proof to be hidden.\nExactly like Definition/Defined today, but with the clear intent of generating a\nbunch of global constants in an unpredictable number, of an unknown type.\nThis to make \"abstract\" not available in \"normal\" proofs, and have a pure notion\nof tactics.  (It would not change much from the implementation side I guess, but\nwould make it clear that one is doing something special).\n\nI don't know if Program can already be used for that, or if it can easily extended to\nlet one manually declare the subterms/subgoals that have to be turned into obligations.\nIf so, then I would strongly recommend driving users in this direction, and warning out\na message if one uses abstract elsewhere.\n\nReusing an abstracted proof later on without naming it explicitly should be forbidden\n(today it works only if you end Defined, Qed just hides things).  And as you suggested it\nshould be named in a Vernacular, like Defined exporting bla, bar. to make it easy to\nknow it statically.\nIn any case I had the impression that what people really miss is a language to produce the\ngoals one abstract beforehand.  You can do it in ML, like Program kind of does.  But not in\nLtac, since you can't start a Lemma in Ltac.  But this is way a more complicated feature,\nit seems way simpler to make Program more general (if possible).\n\nBest,\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525199/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525202","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525202","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525202,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTIwMg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-12T12:13:46Z","updated_at":"2017-10-18T09:34:43Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nEnrico, let me first continue with the controversy. If one takes as definition of a tactic, code which modifies a state of evars, you can see \"abstract\" (the local but unscoped version of it) as a tactic: just set an initial evar of type a polymorphic list at the start of proof, refine it with the pair of a subproof and of a new evar standing for a residual list everytime you call abstract, and fills the residual evar with unit at Qed time. So, the feature that a local unscoped abstract provides could be implemented as a tactic in your sense.\n\nThis being said, I agree that \"abstract\" is in some sense unsatisfactory and that we might want for instance a more declarative interface to abstracting subproofs, which is your concern if I understand your message correctly.\n\nI cannot resist seizing this opportunity to wonder why there is so little interest and investment in C-zar, as if everyone de facto validated the procedural style - for its efficiency? out of habit? by homogeneity of style with what other people do? because easier to learn? for its programmability? for its flexibility? -, even though the scripts are hardly readable back. I wish further good features of a declarative style could eventually be supported (re-readability, ability to choose the order in which proving the goals, support for natural language, ...). Maybe some features that should actually be provided by a GUI?\n\nIncidentally, I observed that \"abstract using foo\" does not necessarily generate a lemma named foo but only a lemma with prefix foo (i.e. foo0 if foo is already taken, and so on). Is there some interest into this? Why not to fail if foo is already taken? Any use case of it is welcome.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525202/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525203","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525203","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525203,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTIwMw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-12T14:12:57Z","updated_at":"2017-10-18T09:34:43Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\n> just set an initial evar of type a polymorphic list at the start of proof...\n\nI'm going a bit off topic but since it is interesting...\n\nYes and no.  You implementation is OK if you restrict the visibility of abstract constants to the current proof.  In that sense your abstract is still local\n(you pushed things to the root of the proof term, but not \"globally\" as abstract\ndoes).\n\nIn some sense you are making just one big cut as your first proof step,\nstanding for a n-ary conjunction.  That choice makes some things simpler to code,\nbut all your proofs/statements are going to be fully generalized, since\nthey must be \"lifted\" up to the empty local context (as abstract constants\nare today, but not necessarily as ssr abstracted constants are, since you\ncan make the cut(s) down in the proof term where you actually need them).\n\nI've no strong opinion on czar itself, actually I quite don't know it.\nI've some opinions on proof languages, mostly coming from my work on the Odd Order Theoerm.\n\nIn general, if you take the proofs of math comp about complex group theory (the\nonly ones I really know) the style is very declarative.  They are made of\nsuccessive forward steps, like \"assert\".  Then the way we convince Coq of\nthese big steps is mostly backward chain + rewrite.  So I think the two styles\nmust live together, especially if there is no automation filling these steps\n(and I can hardly imagine automation always filling these gaps...).\n\nIn short, my experience suggest that you don't was to use only a\ndeclarative language (just look at a TLA+ proofs, without code folding you\nnever see the end).  Actually as long as the proofs are short the\nrewrite + backchain style is much better.  When complexity rises, you need\nincreasingly more sophisticated forms of forward reasoning to declare where\nyou are going, since the final goal is too far away.\n\nI want to be honest.  I think I have a personal aversion to \"natural languages\"\nin the context of computer science, and this may bias my opinion above very much.\n(Among other things because, not being a native speaker, I never know which one I\nshould pick among \"of\", \"to\", \"for\" and the like, so \"looking like English\" does\nnot necessarily help).\n\nBest,\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525203/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525205","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525205","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525205,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTIwNQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-12T21:31:03Z","updated_at":"2017-10-18T09:34:43Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nOK, thanks for the discussion. This is probably a good time to make a break (and for the [BZ#3684](https://github.com/coq/coq/issues?q=is%3Aissue%20%22Original%20bug%20ID%3A%20BZ%233684%22) to find back its original purpose... it is still open!).\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525205/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525207","html_url":"https://github.com/coq/coq/issues/3684#issuecomment-337525207","issue_url":"https://api.github.com/repos/coq/coq/issues/3684","id":337525207,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTIwNw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-20T20:42:23Z","updated_at":"2017-10-18T09:34:43Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nShould be morally fixed in trunk. See the comments of commit 9295b3db to understand that the reality is not that bright, but at least, typical use-case should go through just fine.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525207/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]