[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516781","html_url":"https://github.com/coq/coq/issues/3179#issuecomment-337516781","issue_url":"https://api.github.com/repos/coq/coq/issues/3179","id":337516781,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjc4MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-08T03:52:56Z","updated_at":"2017-10-18T09:10:36Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n[match] constructs should reduce when the discriminee is another [match] construct, and should also reduce in some cases when applied to arguments.\n\nHere is a rule for reducing a [match (match ... with ... end) with ... end] construct on arbitrary inductive types (actually, here's the two constructor one parameter one index case, which should be straightforwardly generalizable to all cases) (code compiles in Coq 8.4):\n\nSet Implicit Arguments.\n\nModule match_commutes.\n  Axiom A : Type.\n  Axiom A' : Type.\n  Axiom B t1T t2T : A -> Type.\n  Axiom B' t1T' t2T' : A' -> Type.\n  Axiom f1 : forall x, t1T x -> B x.\n  Axiom f2 : forall x, t2T x -> B x.\n  Axiom f1' : forall x, t1T' x -> B' x.\n  Axiom f2' : forall x, t2T' x -> B' x.\n\n  (** Suppose we have types [A] and [A'] and fibrations [B : A → Type] and [B' : A' → Type].  Suppose we have two inductive families with one parameter and one index (the multi-parameter multi-index case should be a straightforward generalization) defined as: *)\n\n  Inductive T (x : A) : B x -> Type :=\n  | t1 : forall y : t1T x, T x (f1 x y)\n  | t2 : forall y : t2T x, T x (f2 x y).\n\n  Inductive T' (x : A') : B' x -> Type :=\n  | t1' : forall y : t1T' x, T' x (f1' x y)\n  | t2' : forall y : t2T' x, T' x (f2' x y).\n\n  (** for some [t1T], [t2T], [t1T'], [t2T'], [f1], [f2], [f1'], and [f2'].  Then we have the following theorem: *)\n\n  Theorem matches_commute a' b' (t' : T' a' b')\n          (rta : forall b'', T' a' b'' -> A)\n          (rtb : forall b'' t'', B (rta b'' t''))\n          (rt1 : forall y, T _ (rtb (f1' a' y) (@ t1' a' y)))\n          (rt2 : forall y, T _ (rtb (f2' a' y) (@ t2' a' y)))\n          (R : forall (b : B (rta b' t')), T _ b -> Type)\n          (r1 : forall y, R (f1 _ y) (@ t1 _ y))\n          (r2 : forall y, R (f2 _ y) (@ t2 _ y))\n  : match\n      match t' as t0' in (T' _ b0') return T (rta b0' t0') (rtb b0' t0') with\n        | t1' y => rt1 y\n        | t2' y => rt2 y\n      end\n      as t0 in (T _ b0)\n      return R b0 t0\n    with\n      | t1 y => r1 y\n      | t2 y => r2 y\n    end\n    =\n    match t'\n          as t0' in (T' _ b0')\n          return (forall (R : forall (b : B (rta b0' t0')), T _ b -> Type)\n                         (r1 : forall y, R (f1 _ y) (@ t1 _ y))\n                         (r2 : forall y, R (f2 _ y) (@ t2 _ y)),\n                    R _ (match t0' as t0'0 in (T' _ b0'0) return T (rta b0'0 t0'0) (rtb b0'0 t0'0) with\n                           | t1' y => rt1 y\n                           | t2' y => rt2 y\n                         end))\n    with\n      | t1' y => fun _ r1 r2 =>\n                      match rt1 y with\n                        | t1 y' => r1 y'\n                        | t2 y' => r2 y'\n                      end\n      | t2' y => fun _ r1 r2 =>\n                      match rt2 y with\n                        | t1 y' => r1 y'\n                        | t2 y' => r2 y'\n                      end\n    end R r1 r2.\n  Proof.\n    destruct t'; reflexivity.\n  Defined.\nEnd matches_commute.\n\n\nI'm still working on a rule for reducing a [match] applied to arguments which doesn't require solving higher order unification.  (The rule I use mentally only works when the arguments are sufficiently polymorphic, so it's not a good candidate for implementation.)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516781/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516782","html_url":"https://github.com/coq/coq/issues/3179#issuecomment-337516782","issue_url":"https://api.github.com/repos/coq/coq/issues/3179","id":337516782,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjc4Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-08T03:56:30Z","updated_at":"2017-10-18T09:10:37Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n(The rule I use in my head is essentially the commutation rule I mention in https://coq.inria.fr/bugs/show_bug.cgi?id=3119, for [f := (fun m x => m x)].)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516782/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516786","html_url":"https://github.com/coq/coq/issues/3179#issuecomment-337516786","issue_url":"https://api.github.com/repos/coq/coq/issues/3179","id":337516786,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjc4Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-09-08T19:49:06Z","updated_at":"2017-10-18T09:10:37Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nThis feature wish being overly deep (it needs some formal proofs of the feasibility & soundness of the resulting system), I think it is better to close it for now. If you wish to write down such proofs, you're welcome!\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516786/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]