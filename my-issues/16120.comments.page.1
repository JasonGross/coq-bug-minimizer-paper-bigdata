[{"url":"https://api.github.com/repos/coq/coq/issues/comments/1142677942","html_url":"https://github.com/coq/coq/issues/16120#issuecomment-1142677942","issue_url":"https://api.github.com/repos/coq/coq/issues/16120","id":1142677942,"node_id":"IC_kwDOABUDh85EG-G2","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2022-05-31T21:59:01Z","updated_at":"2022-05-31T21:59:01Z","author_association":"MEMBER","body":"Even simpler:\r\n```coq\r\nInductive t1 := q1 (v : option t1) (pf : v = v).\r\nInductive t2 := q2 (v : option t2) (pf : v = None).\r\n(* Error: Non strictly positive occurrence of \"t2\" in\r\n \"forall v : option t2, v = None -> t2\". *)\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/1142677942/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158900994","html_url":"https://github.com/coq/coq/issues/16120#issuecomment-1158900994","issue_url":"https://api.github.com/repos/coq/coq/issues/16120","id":1158900994,"node_id":"IC_kwDOABUDh85FE20C","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2022-06-17T14:00:05Z","updated_at":"2022-06-17T14:00:05Z","author_association":"CONTRIBUTOR","body":"In what sense is it incorrect? `t2` appears in `@None t2` which appears in index position for `eq`","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158900994/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158914962","html_url":"https://github.com/coq/coq/issues/16120#issuecomment-1158914962","issue_url":"https://api.github.com/repos/coq/coq/issues/16120","id":1158914962,"node_id":"IC_kwDOABUDh85FE6OS","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2022-06-17T14:14:27Z","updated_at":"2022-06-17T14:14:27Z","author_association":"CONTRIBUTOR","body":"In the reverse order\r\n~~~\r\nInductive t3 := q3 (v : option t3) (pf : None = v).\r\n~~~\r\nthe issue is https://coq.github.io/doc/master/refman/language/core/inductive.html#strict-positivity\r\n>and the (instantiated) types of constructor Ci{pj/aj}j=1…m of I satisfy the nested positivity condition for X1…Xk\r\n\r\nthe instantiated type of eq_refl here is `@eq t2 (@None t2) (@None t2)`, the second `@None t2` breaks nested positivity because it is in index position.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158914962/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158936837","html_url":"https://github.com/coq/coq/issues/16120#issuecomment-1158936837","issue_url":"https://api.github.com/repos/coq/coq/issues/16120","id":1158936837,"node_id":"IC_kwDOABUDh85FE_kF","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2022-06-17T14:37:39Z","updated_at":"2022-06-17T14:37:39Z","author_association":"MEMBER","body":"Does anything go wrong (metatheoretically) if we first (recursively) erase uniform parameters from constructors (and, I guess, erase parameters from primitive projections) and then check the (strict) positivity condition on the resulting erased term?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158936837/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158947086","html_url":"https://github.com/coq/coq/issues/16120#issuecomment-1158947086","issue_url":"https://api.github.com/repos/coq/coq/issues/16120","id":1158947086,"node_id":"IC_kwDOABUDh85FFCEO","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2022-06-17T14:48:57Z","updated_at":"2022-06-17T14:48:57Z","author_association":"MEMBER","body":"Maybe we should add an an example of a derivation of absurdity from an inductive that breaks strict positivity only by violating the rule about lack of occurrences in the indices?  Before the change to the guard checker that fixed the inconsistency with univalence / propositional extensionality, I think the following would do:\r\n```coq\r\nInductive Questionable := questionable (T : Type) (pf : T = Questionable) (t : T).\r\n```\r\nBut now that the guard checker no longer preserves the subterm relation across transport (at least this is my understanding), I think the resulting infinite loop fixpoint would be unguarded (because we must choose whether `t` is recognized as a subterm of `@questionable _ _ t` or whether it is recognized as being of type `Questionable`, and we cannot get both simultaneously).  I actually cannot think of an example here, and I'm wondering if occurrences in indices have lost their bite since the change to the guard checker.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158947086/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158956316","html_url":"https://github.com/coq/coq/issues/16120#issuecomment-1158956316","issue_url":"https://api.github.com/repos/coq/coq/issues/16120","id":1158956316,"node_id":"IC_kwDOABUDh85FFEUc","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2022-06-17T14:58:41Z","updated_at":"2022-06-17T14:58:41Z","author_association":"CONTRIBUTOR","body":"\r\n\r\n`Inductive t1 := q1 (v : option t1) (pf : v = v).` breaks the translation from nested to mutual AFAICT, so what you want seems like a subset of inductive-inductive types.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158956316/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158976940","html_url":"https://github.com/coq/coq/issues/16120#issuecomment-1158976940","issue_url":"https://api.github.com/repos/coq/coq/issues/16120","id":1158976940,"node_id":"IC_kwDOABUDh85FFJWs","user":{"login":"ppedrot","id":1202327,"node_id":"MDQ6VXNlcjEyMDIzMjc=","avatar_url":"https://avatars.githubusercontent.com/u/1202327?v=4","gravatar_id":"","url":"https://api.github.com/users/ppedrot","html_url":"https://github.com/ppedrot","followers_url":"https://api.github.com/users/ppedrot/followers","following_url":"https://api.github.com/users/ppedrot/following{/other_user}","gists_url":"https://api.github.com/users/ppedrot/gists{/gist_id}","starred_url":"https://api.github.com/users/ppedrot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ppedrot/subscriptions","organizations_url":"https://api.github.com/users/ppedrot/orgs","repos_url":"https://api.github.com/users/ppedrot/repos","events_url":"https://api.github.com/users/ppedrot/events{/privacy}","received_events_url":"https://api.github.com/users/ppedrot/received_events","type":"User","site_admin":false},"created_at":"2022-06-17T15:20:06Z","updated_at":"2022-06-17T15:20:06Z","author_association":"MEMBER","body":"By the way does anybody know if we can get full blown induction-induction with some kind of generalization of nested inductive types? I've always had the impression that there was something going on with this since I discovered that not all nested were translatable to mutual (and hence transitively to non-mutual indexed) types.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/1158976940/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]