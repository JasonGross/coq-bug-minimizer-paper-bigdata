[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521812","html_url":"https://github.com/coq/coq/issues/3476#issuecomment-337521812","issue_url":"https://api.github.com/repos/coq/coq/issues/3476","id":337521812,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTgxMg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-01T15:22:57Z","updated_at":"2017-10-18T09:25:00Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI would like both of the following to work:\n\nTactic Notation \"elet\" ident(x) \":=\" constr(c) \"in\" tactic(cont) := let x := c in cont.\nTactic Notation \"elet\" ident(x) \":=\" tactic3(c) \"in\" tactic(cont) := c; cont.\nGoal False.\nProof.\n  Fail let x := lazymatch goal with\n             | [ |- True ] => constr:(1)\n             | [ |- False ] => fail \"Found False\"\n           end in\n  elet x' := x in pose x'; pose x'. (* Error: Tactic failure: Found False., as expected *)\nAbort.    \nGoal True.\n  let x := lazymatch goal with\n             | [ |- True ] => constr:(1)\n             | [ |- False ] => fail \"Found False\"\n           end in\n  elet x' := x in pose x'; pose x'. (* Error: Value is a term. Expected a tactic. *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521812/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521813","html_url":"https://github.com/coq/coq/issues/3476#issuecomment-337521813","issue_url":"https://api.github.com/repos/coq/coq/issues/3476","id":337521813,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTgxMw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-05T22:00:55Z","updated_at":"2017-10-18T09:25:00Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nYou can't overload notations in the current implementation, and I doubt it will be possible anytime soon. In both cases, the \"elet\" expression is parsed as a constr, because \"x\" is accepted by the constr grammar.\n\nMaybe what you want is a way to discriminate tactics from constrs dynamically. The problem I foresee is that in Ltac, eagerness of evaluation is REALLY badly specified, and this would be difficult to test that something is a tactic without actually evaluating it...\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521813/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521816","html_url":"https://github.com/coq/coq/issues/3476#issuecomment-337521816","issue_url":"https://api.github.com/repos/coq/coq/issues/3476","id":337521816,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTgxNg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-05T22:10:42Z","updated_at":"2017-10-18T09:25:01Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI would also be happy with a built-in \"eager let\" so that [elet x := y in z] ran [y] eagerly, resulting in immediate failure (with the appropriate message) if [y] was bound to something like [fail \"foo\"], but was the same as [let x := y in z] if [y] was bound to a constr.\n\nI'd also be happy with a functional if-then-else of ltac, where it evaluated to the then clause if the test passed, and evaluated to the else clause when the test failed.  So I could do something like [if (is_evar x) then constr:(y) else constr:(z)] and I could also do [if constr:(x) then (exact x) else x].\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521816/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521818","html_url":"https://github.com/coq/coq/issues/3476#issuecomment-337521818","issue_url":"https://api.github.com/repos/coq/coq/issues/3476","id":337521818,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTgxOA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-06T09:54:32Z","updated_at":"2017-10-18T09:25:01Z","author_association":"CONTRIBUTOR","body":"Comment author: @aspiwack\n\nThere is an internal tactic called [Proofview.tclIFCATCH] such that [Proofview.tclIFCATCH t k h] is t;k if [t] succeeds at least once, and [h] otherwise (in particular it would work with [is_evar], or the new [guard]).\n\nIt's not in ltac yet because I haven't decided on a syntax.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521818/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/1012043910","html_url":"https://github.com/coq/coq/issues/3476#issuecomment-1012043910","issue_url":"https://api.github.com/repos/coq/coq/issues/3476","id":1012043910,"node_id":"IC_kwDOABUDh848UpCG","user":{"login":"ppedrot","id":1202327,"node_id":"MDQ6VXNlcjEyMDIzMjc=","avatar_url":"https://avatars.githubusercontent.com/u/1202327?v=4","gravatar_id":"","url":"https://api.github.com/users/ppedrot","html_url":"https://github.com/ppedrot","followers_url":"https://api.github.com/users/ppedrot/followers","following_url":"https://api.github.com/users/ppedrot/following{/other_user}","gists_url":"https://api.github.com/users/ppedrot/gists{/gist_id}","starred_url":"https://api.github.com/users/ppedrot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ppedrot/subscriptions","organizations_url":"https://api.github.com/users/ppedrot/orgs","repos_url":"https://api.github.com/users/ppedrot/repos","events_url":"https://api.github.com/users/ppedrot/events{/privacy}","received_events_url":"https://api.github.com/users/ppedrot/received_events","type":"User","site_admin":false},"created_at":"2022-01-13T11:21:11Z","updated_at":"2022-01-13T11:21:11Z","author_association":"MEMBER","body":"That's a WONTFIX.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/1012043910/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]