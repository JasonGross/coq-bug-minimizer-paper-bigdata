[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337539480","html_url":"https://github.com/coq/coq/issues/4533#issuecomment-337539480","issue_url":"https://api.github.com/repos/coq/coq/issues/4533","id":337539480,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzOTQ4MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-01-26T09:16:06Z","updated_at":"2017-10-18T10:16:24Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nThis code passes in 8.5rc1, but fails in 8.5.\n\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-nois\" \"-indices-matter\" \"-R\" \".\" \n\"Top\" \"-top\" \"bug_lex_wrong_rewrite_02\") -*- *)\n(* File reduced by coq-bug-finder from original input, then from 1125 lines to \n346 lines, then from 360 lines to 346 lines, then from 822 lines to 271 lines, \nthen from 285 lines to 271 lines *)\n(* coqc version 8.5 (January 2016) compiled on Jan 23 2016 16:15:22 with OCaml \n4.01.0\n   coqtop version 8.5 (January 2016) *)\nInductive False := .\nAxiom proof_admitted : False.\nTactic Notation \"admit\" := case proof_admitted.\nRequire Coq.Init.Datatypes.\nImport Coq.Init.Notations.\nGlobal Set Universe Polymorphism.\nNotation \"A -> B\" := (forall (_ : A), B) : type_scope.\nModule Export Datatypes.\n  Set Implicit Arguments.\n  Notation nat := Coq.Init.Datatypes.nat.\n  Notation S := Coq.Init.Datatypes.S.\n  Record prod (A B : Type) := pair { fst : A ; snd : B }.\n  Notation \"x * y\" := (prod x y) : type_scope.\n  Delimit Scope nat_scope with nat.\n  Open Scope nat_scope.\nEnd Datatypes.\nModule Export Specif.\n  Set Implicit Arguments.\n  Record sig {A} (P : A -> Type) := exist { proj1_sig : A ; proj2_sig : P \nproj1_sig }.\n  Notation sigT := sig (only parsing).\n  Notation \"{ x : A  & P }\" := (sigT (fun x:A => P)) : type_scope.\n  Notation projT1 := proj1_sig (only parsing).\n  Notation projT2 := proj2_sig (only parsing).\nEnd Specif.\nGlobal Set Keyed Unification.\nGlobal Unset Strict Universe Declaration.\nDefinition Type1@ {i} := Eval hnf in let gt := (Set : Type@ {i}) in Type@ {i}.\nDefinition Type2@ {i j} := Eval hnf in let gt := (Type1@ {j} : Type@ {i}) in \nType@ {i}.\nDefinition Type2le@ {i j} := Eval hnf in let gt := (Set : Type@ {i}) in\n                                        let ge := ((fun x => x) : Type1@ {j} -> \nType@ {i}) in Type@ {i}.\nNotation idmap := (fun x => x).\nDelimit Scope function_scope with function.\nDelimit Scope path_scope with path.\nDelimit Scope fibration_scope with fibration.\nOpen Scope fibration_scope.\nOpen Scope function_scope.\nNotation pr1 := projT1.\nNotation pr2 := projT2.\nNotation \"x .1\" := (pr1 x) (at level 3, format \"x '.1'\") : fibration_scope.\nNotation \"x .2\" := (pr2 x) (at level 3, format \"x '.2'\") : fibration_scope.\nNotation compose := (fun g f x => g (f x)).\nNotation \"g 'o' f\" := (compose g%function f%function) (at level 40, left \nassociativity) : function_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation \"x = y :> A\" := (@ paths A x y) : type_scope.\nNotation \"x = y\" := (x = y :>_) : type_scope.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x\n  := match p with idpath => idpath end.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z :=\n  match p, q with idpath, idpath => idpath end.\nNotation \"1\" := idpath : path_scope.\nNotation \"p @  q\" := (concat p%path q%path) (at level 20) : path_scope.\nNotation \"p ^\" := (inverse p%path) (at level 3, format \"p '^'\") : path_scope.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y\n  := match p with idpath => idpath end.\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x)\n  := forall x:A, f x = g x.\nNotation \"f == g\" := (pointwise_paths f g) (at level 70, no associativity) : \ntype_scope.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) :=\n  forall x : A, r (s x) = x.\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv {\n                                               equiv_inv : B -> A ;\n                                               eisretr : Sect equiv_inv f;\n                                               eissect : Sect f equiv_inv;\n                                               eisadj : forall x : A, eisretr \n(f x) = ap f (eissect x)\n                                             }.\nArguments eissect {A B}%type_scope f%function_scope {_} _.\nInductive Unit : Type1 := tt : Unit.\nLocal Open Scope path_scope.\nDefinition concat_p_pp {A : Type} {x y z t : A} (p : x = y) (q : y = z) (r : z \n= t) :\n  p @  (q @  r) = (p @  q) @  r :=\n  match r with idpath =>\n               match q with idpath =>\n                            match p with idpath => 1\n                            end end end.\nSection Adjointify.\n  Context {A B : Type} (f : A -> B) (g : B -> A).\n  Context (isretr : Sect g f) (issect : Sect f g).\n  Let issect' := fun x =>\n                   ap g (ap f (issect x)^)  @   ap g (isretr (f x))  @   issect x.\n\n  Let is_adjoint' (a : A) : isretr (f a) = ap f (issect' a).\n    admit.\n  Defined.\n\n  Definition isequiv_adjointify : IsEquiv f\n    := BuildIsEquiv A B f g isretr issect' is_adjoint'.\nEnd Adjointify.\nDefinition ExtensionAlong {A B : Type} (f : A -> B)\n           (P : B -> Type) (d : forall x:A, P (f x))\n  := { s : forall y:B, P y & forall x:A, s (f x) = d x }.\nFixpoint ExtendableAlong@ {i j k l}\n         (n : nat) {A : Type@ {i}} {B : Type@ {j}}\n         (f : A -> B) (C : B -> Type@ {k}) : Type@ {l}\n  := match n with\n     | 0 => Unit@ {l}\n     | S n => (forall (g : forall a, C (f a)),\n                  ExtensionAlong@ {i j k l l} f C g) *\n              forall (h k : forall b, C b),\n                ExtendableAlong n f (fun b => h b = k b)\n     end.\n\nDefinition ooExtendableAlong@ {i j k l}\n           {A : Type@ {i}} {B : Type@ {j}}\n           (f : A -> B) (C : B -> Type@ {k}) : Type@ {l}\n  := forall n, ExtendableAlong@ {i j k l} n f C.\n\nModule Type ReflectiveSubuniverses.\n\n  Parameter ReflectiveSubuniverse@ {u a} : Type2@ {u a}.\n\n  Parameter O_reflector@ {u a i} : forall (O : ReflectiveSubuniverse@ {u a}),\n      Type2le@ {i a} -> Type2le@ {i a}.\n\n  Parameter In@ {u a i} : forall (O : ReflectiveSubuniverse@ {u a}),\n      Type2le@ {i a} -> Type2le@ {i a}.\n\n  Parameter O_inO@ {u a i} : forall (O : ReflectiveSubuniverse@ {u a}) (T : \nType@ {i}),\n      In@ {u a i} O (O_reflector@ {u a i} O T).\n\n  Parameter to@ {u a i} : forall (O : ReflectiveSubuniverse@ {u a}) (T : \nType@ {i}),\n      T -> O_reflector@ {u a i} O T.\n\n  Parameter extendable_to_O@ {u a i j k}\n    : forall (O : ReflectiveSubuniverse@ {u a}) {P : Type2le@ {i a}} {Q : \nType2le@ {j a}} {Q_inO : In@ {u a j} O Q},\n      ooExtendableAlong@ {i i j k} (to O P) (fun _ => Q).\n\nEnd ReflectiveSubuniverses.\n\nModule ReflectiveSubuniverses_Theory (Os : ReflectiveSubuniverses).\n  Export Os.\n  Existing Class In.\n  Module Export Coercions.\n    Coercion O_reflector : ReflectiveSubuniverse >-> Funclass.\n  End Coercions.\n  Global Existing Instance O_inO.\n\n  Section ORecursion.\n    Context {O : ReflectiveSubuniverse}.\n\n    Definition O_rec {P Q : Type} {Q_inO : In O Q}\n               (f : P -> Q)\n      : O P -> Q\n      := (fst (extendable_to_O O 1%nat) f).1.\n\n    Definition O_rec_beta {P Q : Type} {Q_inO : In O Q}\n               (f : P -> Q) (x : P)\n      : O_rec f (to O P x) = f x\n      := (fst (extendable_to_O O 1%nat) f).2 x.\n\n    Definition O_indpaths {P Q : Type} {Q_inO : In O Q}\n               (g h : O P -> Q) (p : g o to O P == h o to O P)\n      : g == h\n      := (fst (snd (extendable_to_O O 2) g h) p).1.\n\n  End ORecursion.\n\n\n  Section Reflective_Subuniverse.\n    Context (O : ReflectiveSubuniverse@ {Ou Oa}).\n\n    Definition isequiv_to_O_inO@ {u a i} (T : Type@ {i}) `{In@ {u a i} O T} : \nIsEquiv@ {i i} (to O T).\n    Proof.\n\n      pose (g := O_rec@ {u a i i i i i} idmap).\n      refine (isequiv_adjointify (to O T) g _ _).\n      -\n        refine (O_indpaths@ {u a i i i i i} (to O T o g) idmap _).\n        intros x.\n        apply ap.\n        apply O_rec_beta.\n      -\n        intros x.\n        apply O_rec_beta.\n    Defined.\n    Global Existing Instance isequiv_to_O_inO.\n\n  End Reflective_Subuniverse.\n\nEnd ReflectiveSubuniverses_Theory.\n\nModule Type Preserves_Fibers (Os : ReflectiveSubuniverses).\n  Module Export Os_Theory := ReflectiveSubuniverses_Theory Os.\nEnd Preserves_Fibers.\n\nModule Lex_Reflective_Subuniverses\n       (Os : ReflectiveSubuniverses) (Opf : Preserves_Fibers Os).\n  Import Opf.\n  Goal forall (O : ReflectiveSubuniverse) (A : Type) (B : A -> Type) (A_inO : \nIn O A),\n\n      forall g,\n      forall (x : O {x : A & B x}) v v' v'' (p2 : v'' = v') (p0 : v' = v) (p1 : \nv = _) r,\n        (p2\n           @  (p0\n                @  p1))\n          @  eissect (to O A) (g x) = r.\n    intros.\n    cbv zeta.\n    rewrite concat_p_pp.\n    match goal with\n    | [ |- p2 @  p0 @  p1 @  eissect (to O A) (g x) = r ] => idtac \"good\"\n    | [ |- ?G ] => fail 1 \"bad\" G\n    end.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337539480/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337539481","html_url":"https://github.com/coq/coq/issues/4533#issuecomment-337539481","issue_url":"https://api.github.com/repos/coq/coq/issues/4533","id":337539481,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzOTQ4MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-01-29T20:52:33Z","updated_at":"2017-10-18T10:16:24Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nEven worse, if you turn on primitive projections, [rewrite] unfolds constants which were declared Opaque!\n\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-nois\" \"-indices-matter\" \"-R\" \".\"\n\"Top\" \"-top\" \"bug_lex_wrong_rewrite_02\") -*- *)\n(* File reduced by coq-bug-finder from original input, then from 1125 lines to  346 lines, then from 360 lines to 346 lines, then from 822 lines to 271 lines,  then from 285 lines to 271 lines *)\n(* coqc version 8.5 (January 2016) compiled on Jan 23 2016 16:15:22 with OCaml  4.01.0\n   coqtop version 8.5 (January 2016) *)\nInductive False := .\nAxiom proof_admitted : False.\nTactic Notation \"admit\" := case proof_admitted.\nRequire Coq.Init.Datatypes.\nImport Coq.Init.Notations.\nGlobal Set Universe Polymorphism.\nGlobal Set Primitive Projections.\nNotation \"A -> B\" := (forall (_ : A), B) : type_scope.\nModule Export Datatypes.\n  Set Implicit Arguments.\n  Notation nat := Coq.Init.Datatypes.nat.\n  Notation S := Coq.Init.Datatypes.S.\n  Record prod (A B : Type) := pair { fst : A ; snd : B }.\n  Notation \"x * y\" := (prod x y) : type_scope.\n  Delimit Scope nat_scope with nat.\n  Open Scope nat_scope.\nEnd Datatypes.\nModule Export Specif.\n  Set Implicit Arguments.\n  Record sig {A} (P : A -> Type) := exist { proj1_sig : A ; proj2_sig : P  proj1_sig }.\n  Notation sigT := sig (only parsing).\n  Notation \"{ x : A  & P }\" := (sigT (fun x:A => P)) : type_scope.\n  Notation projT1 := proj1_sig (only parsing).\n  Notation projT2 := proj2_sig (only parsing).\nEnd Specif.\nGlobal Set Keyed Unification.\nGlobal Unset Strict Universe Declaration.\nDefinition Type1@ {i} := Eval hnf in let gt := (Set : Type@ {i}) in Type@ {i}. Definition Type2@ {i j} := Eval hnf in let gt := (Type1@ {j} : Type@ {i}) in\nType@ {i}.\nDefinition Type2le@ {i j} := Eval hnf in let gt := (Set : Type@ {i}) in\n                                        let ge := ((fun x => x) : Type1@ {j} ->  Type@ {i}) in Type@ {i}.\nNotation idmap := (fun x => x).\nDelimit Scope function_scope with function.\nDelimit Scope path_scope with path.\nDelimit Scope fibration_scope with fibration.\nOpen Scope fibration_scope.\nOpen Scope function_scope.\nNotation pr1 := projT1.\nNotation pr2 := projT2.\nNotation \"x .1\" := (pr1 x) (at level 3, format \"x '.1'\") : fibration_scope. Notation \"x .2\" := (pr2 x) (at level 3, format \"x '.2'\") : fibration_scope. Notation compose := (fun g f x => g (f x)).\nNotation \"g 'o' f\" := (compose g%function f%function) (at level 40, left  associativity) : function_scope.\nInductive paths@ {i} {A : Type@ {i}} (a : A) : A -> Type@ {i} := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation \"x = y :> A\" := (@ paths A x y) : type_scope.\nNotation \"x = y\" := (x = y :>_) : type_scope.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x\n  := match p with idpath => idpath end.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z :=\n  match p, q with idpath, idpath => idpath end.\nNotation \"1\" := idpath : path_scope.\nNotation \"p @  q\" := (concat p%path q%path) (at level 20) : path_scope.\nNotation \"p ^\" := (inverse p%path) (at level 3, format \"p '^'\") : path_scope. Definition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y\n  := match p with idpath => idpath end.\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x)\n  := forall x:A, f x = g x.\nNotation \"f == g\" := (pointwise_paths f g) (at level 70, no associativity) :  type_scope.\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) :=\n  forall x : A, r (s x) = x.\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv {\n                                               equiv_inv : B -> A ;\n                                               eisretr : Sect equiv_inv f;\n                                               eissect : Sect f equiv_inv;\n                                               eisadj : forall x : A, eisretr\n(f x) = ap f (eissect x)\n                                             }.\nArguments eissect {A B}%type_scope f%function_scope {_} _.\nInductive Unit : Type1 := tt : Unit.\nLocal Open Scope path_scope.\nDefinition concat_p_pp {A : Type} {x y z t : A} (p : x = y) (q : y = z) (r : z  = t) :\n  p @  (q @  r) = (p @  q) @  r :=\n  match r with idpath =>\n               match q with idpath =>\n                            match p with idpath => 1\n                            end end end.\nSection Adjointify.\n  Context {A B : Type} (f : A -> B) (g : B -> A).\n  Context (isretr : Sect g f) (issect : Sect f g).\n  Let issect' := fun x =>\n                   ap g (ap f (issect x)^)  @   ap g (isretr (f x))  @   issect x.\n\n  Let is_adjoint' (a : A) : isretr (f a) = ap f (issect' a).\n    admit.\n  Defined.\n\n  Definition isequiv_adjointify : IsEquiv f\n    := BuildIsEquiv A B f g isretr issect' is_adjoint'.\nEnd Adjointify.\n\nSection foo.\nLocal Unset Strict Universe Declaration.\nDefinition ExtensionAlong {A : Type@ {i}} {B : Type@ {j}} (f : A -> B)\n           (P : B -> Type@ {k}) (d : forall x:A, P (f x))\n  := sigT@ {l m} (fun s : forall y:B, P y => forall x:A, paths@ {k} (s (f x)) (d x)).\nEnd foo.\nFixpoint ExtendableAlong@ {i j k l}\n         (n : nat) {A : Type@ {i}} {B : Type@ {j}}\n         (f : A -> B) (C : B -> Type@ {k}) : Type@ {l}\n  := match n with\n     | 0 => Unit@ {l}\n     | S n => (forall (g : forall a, C (f a)),\n                  ExtensionAlong@ {i j k l l} f C g) *\n              forall (h k : forall b, C b),\n                ExtendableAlong n f (fun b => h b = k b)\n     end.\n\nDefinition ooExtendableAlong@ {i j k l}\n           {A : Type@ {i}} {B : Type@ {j}}\n           (f : A -> B) (C : B -> Type@ {k}) : Type@ {l}\n  := forall n, ExtendableAlong@ {i j k l} n f C.\n\nModule Type ReflectiveSubuniverses.\n\n  Parameter ReflectiveSubuniverse@ {u a} : Type2@ {u a}.\n\n  Parameter O_reflector@ {u a i} : forall (O : ReflectiveSubuniverse@ {u a}),\n      Type2le@ {i a} -> Type2le@ {i a}.\n\n  Parameter In@ {u a i} : forall (O : ReflectiveSubuniverse@ {u a}),\n      Type2le@ {i a} -> Type2le@ {i a}.\n\n  Parameter O_inO@ {u a i} : forall (O : ReflectiveSubuniverse@ {u a}) (T :\nType@ {i}),\n      In@ {u a i} O (O_reflector@ {u a i} O T).\n\n  Parameter to@ {u a i} : forall (O : ReflectiveSubuniverse@ {u a}) (T :\nType@ {i}),\n      T -> O_reflector@ {u a i} O T.\n\n  Parameter extendable_to_O@ {u a i j k}\n    : forall (O : ReflectiveSubuniverse@ {u a}) {P : Type2le@ {i a}} {Q :  Type2le@ {j a}} {Q_inO : In@ {u a j} O Q},\n      ooExtendableAlong@ {i i j k} (to O P) (fun _ => Q).\n\nEnd ReflectiveSubuniverses.\n\nModule ReflectiveSubuniverses_Theory (Os : ReflectiveSubuniverses).\n  Export Os.\n  Existing Class In.\n  Module Export Coercions.\n    Coercion O_reflector : ReflectiveSubuniverse >-> Funclass.\n  End Coercions.\n  Global Existing Instance O_inO.\n\n  Section ORecursion.\n    Context {O : ReflectiveSubuniverse}.\n\n    Definition O_rec {P Q : Type} {Q_inO : In O Q}\n               (f : P -> Q)\n      : O P -> Q\n      := (fst (extendable_to_O O 1%nat) f).1.\n\n    Definition O_rec_beta {P Q : Type} {Q_inO : In O Q}\n               (f : P -> Q) (x : P)\n      : O_rec f (to O P x) = f x\n      := (fst (extendable_to_O O 1%nat) f).2 x.\n\n    Definition O_indpaths {P Q : Type} {Q_inO : In O Q}\n               (g h : O P -> Q) (p : g o to O P == h o to O P)\n      : g == h\n      := (fst (snd (extendable_to_O O 2) g h) p).1.\n\n  End ORecursion.\n\n\n  Section Reflective_Subuniverse.\n    Context (O : ReflectiveSubuniverse@ {Ou Oa}).\n\n    Definition isequiv_to_O_inO@ {u a i} (T : Type@ {i}) `{In@ {u a i} O T} :  IsEquiv@ {i i} (to O T).\n    Proof.\n\n      pose (g := O_rec@ {u a i i i i i} idmap).\n      refine (isequiv_adjointify (to O T) g _ _).\n      -\n        refine (O_indpaths@ {u a i i i i i} (to O T o g) idmap _).\n        intros x.\n        apply ap.\n        apply O_rec_beta.\n      -\n        intros x.\n        apply O_rec_beta.\n    Defined.\n    Global Existing Instance isequiv_to_O_inO.\n\n  End Reflective_Subuniverse.\n\nEnd ReflectiveSubuniverses_Theory.\n\nModule Type Preserves_Fibers (Os : ReflectiveSubuniverses).\n  Module Export Os_Theory := ReflectiveSubuniverses_Theory Os.\nEnd Preserves_Fibers.\n\nOpaque eissect.\nModule Lex_Reflective_Subuniverses\n       (Os : ReflectiveSubuniverses) (Opf : Preserves_Fibers Os).\n  Import Opf.\n  Goal forall (O : ReflectiveSubuniverse) (A : Type) (B : A -> Type) (A_inO :  In O A),\n\n      forall g,\n      forall (x : O {x : A & B x}) v v' v'' (p2 : v'' = v') (p0 : v' = v) (p1 :  v = _) r,\n        (p2\n           @  (p0\n                @  p1))\n          @  eissect (to O A) (g x) = r.\n    intros.\n    cbv zeta.\n    Unset Printing Primitive Projection Parameters.\n    rewrite concat_p_pp.\n    match goal with\n    | [ |- p2 @  p0 @  p1 @  eissect (to O A) (g x) = r ] => idtac \"good\"\n    | [ |- ?G ] => fail 1 \"bad\" G\n    end.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337539481/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337539482","html_url":"https://github.com/coq/coq/issues/4533#issuecomment-337539482","issue_url":"https://api.github.com/repos/coq/coq/issues/4533","id":337539482,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzOTQ4Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-03-09T15:34:04Z","updated_at":"2017-10-18T10:16:24Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nBoth bugs are now fixed with the new strategy of keyed unification.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337539482/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]