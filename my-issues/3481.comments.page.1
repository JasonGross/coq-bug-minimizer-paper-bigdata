[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521933","html_url":"https://github.com/coq/coq/issues/3481#issuecomment-337521933","issue_url":"https://api.github.com/repos/coq/coq/issues/3481","id":337521933,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTkzMw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-01T21:20:50Z","updated_at":"2017-10-18T09:25:21Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nThe eliminators for records with eta should just be defined as function application or the identity function, not using pattern matching.  (The current eliminators are convertible with the ones I want, but Coq doesn't seem to know that unless I jump through contortions.)\n\nSet Implicit Arguments.\n\nRequire Import Logic.\n\nGlobal Set Universe Polymorphism.\nGlobal Set Asymmetric Patterns.\nLocal Set Record Elimination Schemes.\nLocal Set Primitive Projections.\n\nRecord prod (A B : Type) : Type :=\n  pair { fst : A; snd : B }.\n\nPrint prod_rect.\n(** prod_rect =\nfun (A B : Type) (P : prod A B -> Type)\n  (f : forall (fst : A) (snd : B), P {| fst := fst; snd := snd |})\n  (p : prod A B) =>\nmatch p as p0 return (P p0) with\n| {| fst := x; snd := x0 |} => f x x0\nend\n     : forall (A B : Type) (P : prod A B -> Type),\n       (forall (fst : A) (snd : B), P {| fst := fst; snd := snd |}) ->\n       forall p : prod A B, P p\n\nArguments A, B are implicit\nArgument scopes are [type_scope type_scope _ _ _]\n *)\n\n(* What I really want: *)\nDefinition prod_rect' A B (P : prod A B -> Type) (u : forall (fst : A) (snd : B), P (pair fst snd))\n           (p : prod A B) : P p\n  := u (fst p) (snd p).\n\nDefinition conv : @ prod_rect = @ prod_rect'.\nProof.\n  unfold prod_rect, prod_rect'.\n  simpl.\n  set (f0 := (fun A B P f (p : prod A B) => match p as p0 return P p0 with\n                              | {| fst := x ; snd := x0 |} => f x x0\n                            end)).\n  replace f0 with (fun A B P f p => f0 A B P f (@ pair A B (fst p) (snd p))) by (clearbody f0; abstract reflexivity).\n  Undo.\n  replace f0 with (fun A B P f p => f0 A B P f (@ pair A B (fst p) (snd p))) by (clearbody f0; reflexivity).\n  subst f0.\n  simpl.\n  reflexivity.\nDefined.\n\nEval compute in conv. (* = eq_refl\n     : prod_rect = prod_rect' *)\n\nCheck eq_refl : @ prod_rect = @ prod_rect'. (* Toplevel input, characters 6-13:\nError:\nThe term \"eq_refl\" has type \"prod_rect = prod_rect\"\nwhile it is expected to have type \"prod_rect = prod_rect'\"\n(cannot unify \"prod_rect\" and \"prod_rect'\"). *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521933/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521935","html_url":"https://github.com/coq/coq/issues/3481#issuecomment-337521935","issue_url":"https://api.github.com/repos/coq/coq/issues/3481","id":337521935,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTkzNQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-11T14:25:39Z","updated_at":"2017-10-18T09:25:21Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nDoes anything go wrong if you tell the conversion/normalization machinery that whenever you have a [match] whose only branch is the constructor of a primitive record, you should eta-expand the discriminee (and beta/iota reduce the match)?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521935/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521936","html_url":"https://github.com/coq/coq/issues/3481#issuecomment-337521936","issue_url":"https://api.github.com/repos/coq/coq/issues/3481","id":337521936,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTkzNg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-12T09:25:00Z","updated_at":"2017-10-18T09:25:21Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nIn practice it should be doable but a simpler solution not introducing yet another reduction rule would be to disallow matches on primitive records and define the eliminators as applications of projections.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521936/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521938","html_url":"https://github.com/coq/coq/issues/3481#issuecomment-337521938","issue_url":"https://api.github.com/repos/coq/coq/issues/3481","id":337521938,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTkzOA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-12T10:33:44Z","updated_at":"2017-10-18T09:25:21Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI like the conceptual simplicity of having [match] (or [fix], I guess, in the recursive case) be the one primitive way of doing all destructuring.  It also seems cleaner from a metatheoretical standpoint, where eta and primitive projections don't have to be tied.  But, *shrugs*, you're the one implementing this.\n\nAre you thinking of desugaring explicit [match]es and the destructuring let into usage of projections (for compatibility if nothing else)?  (I have a very strong preference for destructuring let sticking around, because the issig tactics depend on having a way to destructure records without knowing the name of the constructor ahead of time, and without knowing whether or not the record is primitive.)  I guess you'd also make destruct, case, elim, etc. make use of projections?\n\nBy the way, what's the reason that you tied eta to primitive projections?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521938/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521939","html_url":"https://github.com/coq/coq/issues/3481#issuecomment-337521939","issue_url":"https://api.github.com/repos/coq/coq/issues/3481","id":337521939,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTkzOQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-12T17:44:00Z","updated_at":"2017-10-18T09:25:22Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\neta-conversion was tied to primitive projections as it is a case where we have easily recognizable canonical forms. Basically eta is implemented using the conversion rules:\n[c = mkFoo params x -> mkFoo params c.(p) = mkFoo params x -> c.(p) = x]. You're right that we could have eta with non-primitive projections as well using\n[c = mkFoo params x -> mkFoo params (p params c) = mkFoo params x -> p params c = x], although the conversions would be a bit more involved due to the [match x with Foo y => y end] encoding of non-primitive projections.\n\nOne reason to separate match and projections is that they are different ways of observing, as shown by Abel et al.'s work on copatterns. If coinductive types become projection-based in the future, they shouldn't come with the [case] construct that makes Coq lose subject reduction right now.\n\nI can easily make the let (x, ... ) notation desugar to projections, and indeed, destruct/case/elim should use projections too.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521939/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521940","html_url":"https://github.com/coq/coq/issues/3481#issuecomment-337521940","issue_url":"https://api.github.com/repos/coq/coq/issues/3481","id":337521940,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTk0MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-12T21:11:32Z","updated_at":"2017-10-18T09:25:22Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nIf it makes the code simpler and is easier to write and maintain, then, by all means, please implement it, and don't let my grumbling stop you here.\n\nI think half (or more) of my reason for wanting match to be _the_ primitive thing is that learning Coq with [match] as primitive taught me some things that I don't think I'd've learned otherwise, so it seems like a nice thing to keep.  But, then again, I'm sure I'd've learned some things that I don't know now if I had learned Coq when inductives were impredicativity encoded, and I'm certainly not against native inductives.\n\nSeparately, the match-based conversion rule is just \"if we have [match x with mkFoo args => k args end] and [k args] doesn't unify with any of the [args], then replace it with [k (proj args x)]\", right?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521940/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521943","html_url":"https://github.com/coq/coq/issues/3481#issuecomment-337521943","issue_url":"https://api.github.com/repos/coq/coq/issues/3481","id":337521943,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTk0Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-28T22:08:03Z","updated_at":"2017-10-18T09:25:22Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nYou get the right induction principle now, and case/destruct/... use projections as well. \"let (x, y) := r in t\" works as well, adding let-ins for the separate projections.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521943/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]