[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515480","html_url":"https://github.com/coq/coq/issues/3102#issuecomment-337515480","issue_url":"https://api.github.com/repos/coq/coq/issues/3102","id":337515480,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTQ4MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-08-03T19:26:38Z","updated_at":"2017-10-18T09:06:47Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nIt would be nice to be able to access not only the context of a term, but also which term is found.  For example, I would like\n\nGoal (1 = 2) = (1 = 2).\n  match goal with\n    | [ |- appcontext C T [@ eq nat _ _] ] => pose T\n  end.\n\nand have (1 = 2) be posed.  I'm not sure what this should do in the case that the holes are under binders, but I think it would be nice if, e.g.,\n\nGoal forall n m : nat, (n = m) = (n = m).\n  match goal with\n    | [ |- appcontext C T [@ eq nat _ _] ] => pose T\n  end.\n\nposed (fun n m : nat => n = m), i.e., bound the binders and made a function.  This is especially useful because I can pass holes in an open_constr to a tactic notation, but I can't pass things like ?a (and even if I could, I can't really use them).\n\nAs a use-case, I can currently implement a limited form of [rewrite] in Ltac (limited in that you need to know ahead of time how many arguments the function takes, and fill them in by hand) as follows:\n\n  Local Tactic Notation \"rewrite_by_transport0_rev\" open_constr(H) :=\n    (* H should be a term with holes of the form [a = b], and we look for [b] in the goal. *)\n      lazymatch type of H with\n        | ?a = ?b\n          => let G0 := match goal with |- ?G => constr:(G) end in\n             lazymatch goal with\n               | [ |- appcontext G[b] ] (* The goal is [G(b)], and we want to rewrite it to [G(a)] *)\n                 => let A := fresh in\n                    let a' := fresh in\n                    let b' := fresh in\n                    let Hrew := fresh \"rew_lem\" in\n                    evar (A : Type); evar (a' : A); evar (b' : A);\n                    unfold A in a', b'; (* use [a'] and [b'] as the evars used to concretely infer [a] and [b], respectively *)\n                    let Gb' := context G[b'] in\n                    let unify_b' := constr:(idpath : Gb' = G0) in (* figure out what [b]/[b'] is *)\n                    instantiate; (* not sure if we need that; but it ensures that we know about all the existentials we've unified *)\n                    let Gb'' := fresh in\n                    pose G0 as Gb'';\n                      let b'' := (eval unfold b' in b') in\n                      change b'' with b' in Gb'';\n                        pattern b' in Gb'';\n                        lazymatch goal with\n                          | [ Gb''' := ?P _ |- _ ]\n                            => constr_eq Gb'' Gb'''; (* find the function type *)\n                              pose (@ transport A P a' b' H) as Hrew (* pose the lemma, letting unification figure out the holes in [H] *)\n                        end;\n                        subst Gb'' a' b' A;\n                        cbv beta in Hrew;\n                        apply Hrew\n             end\n      end.\n\n  Local Tactic Notation \"rewrite_by_transport0\" open_constr(H)\n    := rewrite_by_transport0_rev (inverse H).\n(*                                                                                                                                          \n  Local Tactic Notation \"rewrite_by_transport1\" open_constr(H) tactic(rewrite_by_transport_tac) :=                                          \n    first [ rewrite_by_transport0 H                                                                                                         \n          | rewrite_by_transport_tac (H _) rewrite_by_transport_tac ].                                                                      \n                                                                                                                                            \n  Local Tactic Notation \"rewrite_by_transport1_rev\" open_constr(H) tactic(rewrite_by_transport_tac) :=                                      \n    first [ rewrite_by_transport0_rev H                                                                                                     \n          | rewrite_by_transport_tac (H) rewrite_by_transport_tac ].                                                                        \n                                                                                                                                            \n  Local Tactic Notation \"rewrite_by_transport\" open_constr(H) :=                                                                            \n    rewrite_by_transport1 H (fun H' tac => rewrite_by_transport1 H' tac).                                                                   \n  Local Tactic Notation \"rewrite_by_transport_rev\" open_constr(H) :=                                                                        \n    rewrite_by_transport1_rev H (fun H' tac => rewrite_by_transport1_rev H' tac).                                                           \n*)\n  Time rewrite_by_transport0 (FCompositionOf T _ _ _ _ _).\n\nwhere [inverse : forall {A} {x y : A}, x = y -> y = x] and [transport : forall {A} (P : A -> Type) {x y}, x = y -> P x -> P y].\n\n\nI think with this new feature I could do something much simpler, such as\n  Local Tactic Notation \"rewrite_by_transport0\" open_constr(H) :=\n    (* H should be a term with holes of the form [a = b], and we look for [b] in the goal. *)\n      lazymatch type of H with\n        | ?a = ?b\n          => let G0 := match goal with |- ?G => constr:(G) end in\n             lazymatch goal with\n               | [ |- appcontext G b' [b] ]\n                 => pattern b';\n                   match goal with\n                     | [ |- ?P _ ]\n                       => let T := type of b' in\n                          apply (@ transport T P _ b' H)\n                   end\n             end\n      end. \nat least if there are no binders in the goal.  \n\nIt would also be nice if there were a variant of context which took the context ([G] in the above) and turned it into a gallina function, i.e., if I could do, with both of these features\n\nmatch goal with\n  | [ |- appcontext G T [foo] ] => let Gfun := context_fun[G] in\n                                   pose (Gfun T)\nend\n\nand have it be the same as\n\nmatch goal with\n  | [ |- ?G ] => pose G\nend\n\n\n\nI think the behavior of context_fun should be something like that\nmatch goal with\n  | [ |- appcontext G [foo] ] => let Gfun := context_fun[G] in\n                                 pose (Gfun)\nend\n\nshould be roughly equivalent to\n\npattern foo;\nmatch goal with\n  | [ |- ?Gfun ?T ] => pose Gfun\nend.\n\nif [pattern] allowed holes.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515480/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515481","html_url":"https://github.com/coq/coq/issues/3102#issuecomment-337515481","issue_url":"https://api.github.com/repos/coq/coq/issues/3102","id":337515481,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTQ4MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-08-04T01:34:17Z","updated_at":"2017-10-18T09:06:47Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nI wholeheartedly agree with your propositions.\n\nThe main problem is not the implementation, as it should be quite easy to do, but rather the very syntax of this feature...\n\nMore generally, this raises the problem of manipulating open terms in Ltac, which is currently impossible; one should be able to:\n\n1. abstract a term w.r.t. a free variable;\n2. substitute a free variable by something in an open term.\n\nIndeed, a context is nothing more than a special type of open term...\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515481/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]