[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515284","html_url":"https://github.com/coq/coq/issues/3090#issuecomment-337515284","issue_url":"https://api.github.com/repos/coq/coq/issues/3090","id":337515284,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTI4NA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-07-16T19:07:36Z","updated_at":"2017-10-18T09:06:12Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nIt's very nice that Notations can be overloaded based on scope, and that scopes can be bound to types, so that notations can be transparently overloaded from the top down.  It would be even nicer if notations could also be overloaded from the bottom up.\n\nThis is tricker, and so I suspect that it will require priority and backtracking.  It is currently possible to fake this using typeclasses.  The only problem is that there remains a transparent dummy constant until you do [simpl].  Here is an example of how to overload an infix 'o' to deal with four different variants of compose:\n\nSet Implicit Arguments.\nGeneralizable All Variables.\n\nParameters T1 T2 : Type.\nParameter Compose11 : T1 -> T1 -> T1.\nParameter Compose12 : T1 -> T2 -> T1.\nParameter Compose21 : T2 -> T1 -> T1.\nParameter Compose22 : T2 -> T2 -> T2.\n\n(* Represents the assertion that [a o b = c] *)\nClass ComposeTo A B C (a : A) (b : B) (c : C) := {}.\nDefinition composition `{@ ComposeTo A B C a b c} := c.\nArguments composition / .\nInstance ComposeTo11 x y : ComposeTo x y (Compose11 x y) | 10.\nInstance ComposeTo12 x y : ComposeTo x y (Compose12 x y) | 100.\nInstance ComposeTo21 x y : ComposeTo x y (Compose21 x y) | 100.\nInstance ComposeTo22 x y : ComposeTo x y (Compose22 x y) | 1000.\n\nNotation \"x 'o' y\"\n  := (@ composition _ _ _ x y _ _)\n       (at level 40, left associativity).\n\nUnset Printing Notations.\nCheck (_ o _). (* composition : T1 *)\nEval simpl in (_ o _). (* Compose11 ?72 ?73 : T1 *)\nCheck ((_ : T2) o _). (* composition : T1 *)\nEval simpl in ((_ : T2) o _). (* Compose21 ?86 ?87 : T1 *)\nEval simpl in (_ o (_ : T2)). (* Compose12 ?93 ?94 : T1 *)\nEval simpl in ((_ : T2) o (_ : T2)). (* Compose22 ?100 ?101 : T2 *)\nEval simpl in ((_ : T2) o (_ : T2) o (_ : T1) o (_ : T1) o (_ : T2) o (_ : T2)).\n(* Compose12\n         (Compose12 (Compose11 (Compose21 (Compose22 ?119 ?120) ?123) ?126)\n            ?129) ?132\n     : T1 *)\n\n\nThis serves my purposes, and nests nicely.  However, it would be nice to be able to do this without the typeclass boilerplate, and without needing the [Eval simpl].\n\nI propose that Coq be extended so that the following produces the same behavior as the above, except that [Check] outputs what [Eval simpl in] outputted before:\n\nParameters T1 T2 : Type.\nParameter Compose11 : T1 -> T1 -> T1.\nParameter Compose12 : T1 -> T2 -> T1.\nParameter Compose21 : T2 -> T1 -> T1.\nParameter Compose22 : T2 -> T2 -> T2.\n\nReserved Infix \"o\" (at level 40, left associativity).\n\nInfix \"o\" := ComposeTo11 | 10.\nInfix \"o\" := ComposeTo12 | 100.\nInfix \"o\" := ComposeTo21 | 100.\nInfix \"o\" := ComposeTo22 | 1000.\n\n\nAlternatively, perhaps require that [Infix] or [Notation] be prefixed with [Overloaded] or something.  Or perhaps require that if you specify a notation in a certain scope with a priority ([| num] syntax, or whatever), then all examples of that notation must be specified in that scope with that priority.  Or pick a default priority, with the semantics that the most recent notation is checked before older ones.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515284/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515285","html_url":"https://github.com/coq/coq/issues/3090#issuecomment-337515285","issue_url":"https://api.github.com/repos/coq/coq/issues/3090","id":337515285,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTI4NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-07-16T19:19:12Z","updated_at":"2017-10-18T09:06:12Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nNote that one downside to this is that notations don't fail as quickly.  E.g., notations won't fail in [Check], only [Let] or [Definition].\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515285/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515286","html_url":"https://github.com/coq/coq/issues/3090#issuecomment-337515286","issue_url":"https://api.github.com/repos/coq/coq/issues/3090","id":337515286,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTI4Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-05-20T13:55:08Z","updated_at":"2017-10-18T09:06:13Z","author_association":"CONTRIBUTOR","body":"Comment author: @ejgallego\n\nIMO this is a WONTFIX in practice, as IIANM it would imply calling the pretyper from the notation code which is a purely syntactical pass.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515286/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]