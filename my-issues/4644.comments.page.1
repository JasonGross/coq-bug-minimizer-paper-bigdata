[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337541258","html_url":"https://github.com/coq/coq/issues/4644#issuecomment-337541258","issue_url":"https://api.github.com/repos/coq/coq/issues/4644","id":337541258,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0MTI1OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-03-23T21:36:46Z","updated_at":"2022-01-10T21:10:44Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nThis code works in Coq 8.4 and breaks in Coq 8.5.  Note that \"etransitivity; [ t | reflexivity ]\" succeeds in both, which suggests that is a genuine bug in 8.5, and not just an innocuous change in the unification algorithm.\r\n```coq\r\n(* File reduced by coq-bug-finder from original input, then from 657 lines to 25 lines, then from 1325 lines to 33 lines, then from 495 lines to 49 lines, then from 353 lines to 67 lines, then from 235 lines to 77 lines, then from 1900 lines to 80 lines, then from 94 lines to 80 lines *)\r\n(* coqc version 8.5 (March 2016) compiled on Mar 21 2016 18:39:8 with OCaml 4.02.3\r\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.5,v8.5 (09c2011fbdbb2ac1ce33e5abe52d93b907b21a3c) *)\r\nAxiom proof_admitted : False.\r\nTactic Notation \"admit\" := case proof_admitted.\r\nRequire Export Coq.Classes.Morphisms.\r\nRequire Import Coq.Lists.List.\r\n\r\nGlobal Set Implicit Arguments.\r\n\r\nDefinition list_caset A (P : list A -> Type) (N : P nil) (C : forall x xs, P (x::xs))\r\n           ls\r\n  : P ls\r\n  := match ls with\r\n     | nil => N\r\n     | x::xs => C x xs\r\n     end.\r\n\r\nAxiom list_caset_Proper'\r\n  : forall {A P},\r\n    Proper (eq\r\n              ==> pointwise_relation _ (pointwise_relation _ eq)\r\n              ==> eq\r\n              ==> eq)\r\n           (@ list_caset A (fun _ => P)).\r\nGoal forall (T T' : Set) (a3 : list T), exists y2, forall (a4 : T' -> bool),\r\n        match a3 with\r\n        | nil => 0\r\n        | (_ :: _)%list => 1\r\n        end = y2 a4.\r\n  clear; eexists; intros.\r\n  reflexivity. Undo.\r\n  Local Ltac t :=\r\n    lazymatch goal with\r\n    | [ |- match ?v with nil => ?N | cons x xs => @ ?C x xs end = _ :> ?P ]\r\n      => let T := type of v in\r\n         let A := match (eval hnf in T) with list ?A => A end in\r\n         refine (@ list_caset_Proper' A P _ _ _ _ _ _ _ _ _\r\n                 : @ list_caset A (fun _ => P) N C v = match _ with nil => _ | cons x xs => _ end)\r\n    end.\r\n  (etransitivity; [ t | reflexivity ]) || fail 0 \"too early\".\r\n  Show Proof.\r\n  Undo.\r\n  t. (* In nested Ltac calls to \"t\", \"t\" and\r\n\"refine (list_caset_Proper' _ _ _\r\n         :\r\n         list_caset (fun _ => P) N C v =\r\n         match _ with\r\n         | nil => _\r\n         | x :: xs => _\r\n         end)\", last call failed.\r\nError:\r\nIn environment\r\nT, T' : Set\r\na3 : list T\r\na4 : T' -> bool\r\nThe term\r\n \"list_caset_Proper' ?e ?p ?e0\r\n  :\r\n  list_caset (fun _ : list T => nat) 0 (fun (_ : T) (_ : list T) => 1) a3 =\r\n  match ?y with\r\n  | nil => ?n\r\n  | x :: xs => ?n0 x xs\r\n  end\" has type\r\n \"list_caset (fun _ : list T => nat) 0 (fun (_ : T) (_ : list T) => 1) a3 =\r\n  match ?y with\r\n  | nil => ?n\r\n  | x :: xs => ?n0 x xs\r\n  end\" while it is expected to have type\r\n \"match a3 with\r\n  | nil => 0\r\n  | _ :: _ => 1\r\n  end = ?y2 a4\".\r\n *)\r\n\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337541258/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337541260","html_url":"https://github.com/coq/coq/issues/4644#issuecomment-337541260","issue_url":"https://api.github.com/repos/coq/coq/issues/4644","id":337541260,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0MTI2MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-06-08T09:06:38Z","updated_at":"2022-01-10T21:11:18Z","author_association":"CONTRIBUTOR","body":"Comment author: @silene\r\n\r\nHere is a reduced testcase:\r\n```coq\r\nLemma foo (a : unit) :\r\n  exists b, match a with tt => tt end = b tt.\r\nProof.\r\neexists.\r\nFail refine (_ : _ = match _ with tt => _ end).\r\nrefine (_ : _ = (fun _ => match _ with tt => _ end) _).\r\nreflexivity.\r\nQed.\r\n```\r\nThe refine fails because you are trying to unify a case analysis with an application. I have absolutely no idea whether this is actually a bug.\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337541260/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337541262","html_url":"https://github.com/coq/coq/issues/4644#issuecomment-337541262","issue_url":"https://api.github.com/repos/coq/coq/issues/4644","id":337541262,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0MTI2Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-06-09T13:47:36Z","updated_at":"2021-03-13T15:54:37Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\r\n\r\nInitial example fixed (5ea2539d4a7).\r\n\r\nIn Guillaume's example, \"refine\" now works, but the next \"reflexivity\" does not work because unification.ml is not powerful enough (like in 8.4). Also, this enters in the scope of 8.5's \"refine\" leaving unresolved constraints.\r\n\r\nNote that the \"refine\" is buggy also in 8.4, as it does not instantiate the variable.\r\n```coq\r\nLemma foo (a : unit) :\r\n  exists b, match a with tt => tt end = b tt.\r\nProof.\r\neexists.\r\nrefine (_ : _ = match _ with tt => _ end).\r\n(*\r\n  a : unit\r\n  ============================\r\n   match a with\r\n   | tt => tt\r\n   end = ?9 tt\r\n*)\r\n```\r\nBecause of the latter, I let the report open.\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337541262/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]