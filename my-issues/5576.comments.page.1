[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337554709","html_url":"https://github.com/coq/coq/issues/5576#issuecomment-337554709","issue_url":"https://api.github.com/repos/coq/coq/issues/5576","id":337554709,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU1NDcwOQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-06-03T04:02:39Z","updated_at":"2017-10-18T11:05:07Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-R\" \"src\" \"CrossCrypto\" \"-R\" \n\"fcf/src/FCF\" \"FCF\" \"-R\" \"fcf/src/HMAC\" \"HMAC\" \"-top\" \"Minimalistic\") -*- *)\n(* File reduced by coq-bug-finder from original input, then from 1610 lines to \n38 lines, then from 473 lines to 38 lines, then from 106 lines to 38 lines, \nthen from 102 lines to 58 lines, then from 71 lines to 35 lines, then from 49 \nlines to 43 lines *)\n(* coqc version trunk (May 2017) compiled on May 30 2017 13:28:59 with OCaml \n4.02.3\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-trunk,trunk \n(fd36c0451c26e44b1b7e93299d3367ad2d35fee3) *)\nRequire Import Coq.FSets.FMapPositive.\nRequire Import Coq.FSets.FMapFacts.\nGoal forall type (P : Set -> Set) (b : forall A : Set, P A -> A -> A -> bool) \n(T : Set -> Type)\n            (P0 : forall A : Set, T A -> T A -> Prop)\n            (c : forall A B : Set, T B -> (B -> T A) -> T A),\n    (forall A : Set, @ Equivalence (T A) (P0 A)) ->\n    (forall A B : Set, @ Proper (T B -> (B -> T A) -> T A) (P0 B ==> \n@ pointwise_relation B (T A) (P0 A) ==> P0 A) (c A B)) ->\n    (forall A : Type, @ Equivalence A (@ eq A)) ->\n    forall (c0 : forall A : Set, (forall a1 a2 : A, {a1 = a2} + {a1 <> a2}) -> \nA -> T A) (t : type) (P1 : nat -> Set)\n           (k : forall x0 : nat, T (PositiveMap.t (P1 x0)))\n           (P2 P3 : nat -> Set) (adv' : forall x0 : nat, P2 x0 -> P3 x0) (P4 : \nnat -> Set)\n           (strue0 sfalse0 : forall eta : nat, P4 eta)\n           (P5 : Set -> Set) (s : forall A : Set, P5 A -> forall a b0 : A, {a = \nb0} + {a <> b0}) (e : forall eta : nat, P5 (P4 eta))\n           (P6 : Set) (f : forall x0 : nat, T (P4 x0) -> P6),\n      (forall (eta : nat) (R1 : relation (T (P4 eta))), @ Proper (T (P4 eta) -> \nP6) (R1 ==> @ eq P6) (f eta)) ->\n      forall (negligible : (nat -> P6) -> Prop) (P7 : P6 -> P6 -> Prop),\n        @ Proper ((nat -> P6) -> Prop) (@ pointwise_relation nat P6 P7 ==> iff) \nnegligible ->\n        forall (P8 : type -> nat -> Set) (i : forall eta : nat, (P2 eta -> P3 \neta) -> PositiveMap.t (P1 eta) -> P8 t eta)\n               (e0 : forall (t0 : type) (eta : nat), P (P8 t0 eta)),\n          (forall (eta : nat) (rands : PositiveMap.t (P1 eta)),\n              b (P8 t eta) (e0 t eta) (i eta (adv' eta) rands) (i eta (adv' \neta) rands) = true) ->\n          negligible\n            (fun eta : nat =>\n               f eta\n                 (c (P4 eta) (PositiveMap.t (P1 eta)) (k eta)\n                    (fun rands : PositiveMap.t (P1 eta) =>\n                       c0 (P4 eta) (s (P4 eta) (e eta))\n                          (if b (P8 t eta) (e0 t eta) (i eta (adv' eta) rands) \n(i eta (adv' eta) rands)\n                           then strue0 eta else sfalse0 eta)))).\n  intros ????????? * H' ?? Proper_negligible * lem.\n\n  eapply Proper_negligible; [ | shelve.. ]; intro eta;\n    timeout 1 setoid_rewrite (lem _ _) || fail 1 \"too early\". (* success  *)\n  Undo.\n  Timeout 1 setoid_rewrite (lem _ _). (* times out *)\n\n\nSetting typeclasses debug reveals that the first [setoid_rewrite] does this:\nDebug: 1: looking for (Proper (eq ==> ?r) (c0 (P4 eta) (s (P4 eta) (e eta)))) \nwith backtracking\n...\nDebug:\n2: looking for (Proper (pointwise_relation (PositiveMap.t (P1 eta)) eq ==> ?r) \n(c (P4 eta) (PositiveMap.t (P1 eta)) (k eta))) with\nbacktracking\n\nwhile the second one does this:\nDebug: 1: looking for (Proper (eq ==> ?r) (c0 (P4 eta) (s (P4 eta) (e eta)))) \nwith backtracking\n...\nDebug:\n2: looking for (Proper (forall_relation (fun _ : PositiveMap.t (P1 eta) => eq) \n==> ?r) (c (P4 eta) (PositiveMap.t (P1 eta)) (k eta))) with backtracking\n\nWhy does the first one look for pointwise_relation, but the second one looks \nfor forall_relation?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337554709/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]