[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337534411","html_url":"https://github.com/coq/coq/issues/4215#issuecomment-337534411","issue_url":"https://api.github.com/repos/coq/coq/issues/4215","id":337534411,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzNDQxMQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-29T19:17:26Z","updated_at":"2020-03-26T20:51:37Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\n```coq\r\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-R\" \".\" \"Top\") -*- *)\r\n(* File reduced by coq-bug-finder from original input, then from 196 lines to 185 lines, then from 195 lines to 151 lines *)\r\n(* coqc version 8.5beta1 (April 2015) compiled on Apr 9 2015 15:39:28 with OCaml 4.01.0\r\n   coqtop version cagnode13:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (33650e275a4b3f00541ea87ee4b39892be5fdb2f) *)\r\nAxiom proof_admitted : False.\r\nTactic Notation \"admit\" := case proof_admitted.\r\nModule Export Overture.\r\n\r\n  Definition relation (A : Type) := A -> A -> Type.\r\n\r\n  Class Symmetric {A} (R : relation A) :=\r\n    symmetry : forall x y, R x y -> R y x.\r\n  Delimit Scope function_scope with function.\r\n\r\n  Notation compose := (fun g f x => g (f x)).\r\n\r\n  Notation \"g 'o' f\" := (compose g%function f%function) (at level 40, left associativity) : function_scope.\r\n\r\n  Inductive paths {A : Type} (a : A) : A -> Type :=\r\n    idpath : paths a a.\r\n\r\n  Arguments idpath {A a} , [A] a.\r\n\r\n  Notation \"x = y :> A\" := (@ paths A x y) : type_scope.\r\n  Notation \"x = y\" := (x = y :>_) : type_scope.\r\n\r\n  Definition inverse {A : Type} {x y : A} (p : x = y) : y = x\r\n    := match p with idpath => idpath end.\r\n\r\n  Global Instance symmetric_paths {A} : Symmetric (@ paths A) | 0 := @ inverse A.\r\n\r\nEnd Overture.\r\nSet Implicit Arguments.\r\n\r\nDelimit Scope morphism_scope with morphism.\r\nDelimit Scope category_scope with category.\r\nDelimit Scope object_scope with object.\r\n\r\nRecord PreCategory :=\r\n  Build_PreCategory' {\r\n      object :> Type;\r\n      morphism : object -> object -> Type;\r\n\r\n      identity : forall x, morphism x x;\r\n      compose : forall s d d',\r\n                  morphism d d'\r\n                  -> morphism s d\r\n                  -> morphism s d'\r\n      where \"f 'o' g\" := (compose f g);\r\n\r\n      associativity : forall x1 x2 x3 x4\r\n                             (m1 : morphism x1 x2)\r\n                             (m2 : morphism x2 x3)\r\n                             (m3 : morphism x3 x4),\r\n                        (m3 o m2) o m1 = m3 o (m2 o m1);\r\n\r\n      associativity_sym : forall x1 x2 x3 x4\r\n                                 (m1 : morphism x1 x2)\r\n                                 (m2 : morphism x2 x3)\r\n                                 (m3 : morphism x3 x4),\r\n                            m3 o (m2 o m1) = (m3 o m2) o m1;\r\n\r\n      left_identity : forall a b (f : morphism a b), identity b o f = f;\r\n      right_identity : forall a b (f : morphism a b), f o identity a = f;\r\n\r\n      identity_identity : forall x, identity x o identity x = identity x\r\n    }.\r\n\r\nBind Scope category_scope with PreCategory.\r\nArguments identity {!C%category} / x%object : rename.\r\nArguments compose {!C%category} / {s d d'}%object (m1 m2)%morphism : rename.\r\n\r\nDefinition Build_PreCategory\r\n           object morphism compose identity\r\n           associativity left_identity right_identity\r\n  := @ Build_PreCategory'\r\n       object\r\n       morphism\r\n       compose\r\n       identity\r\n       associativity\r\n       (fun _ _ _ _ _ _ _ => symmetry _ _ (associativity _ _ _ _ _ _ _))\r\n       left_identity\r\n       right_identity\r\n       (fun _ => left_identity _ _ _).\r\nInfix \"o\" := compose : morphism_scope.\r\nNotation \"1\" := (identity _) : morphism_scope.\r\nLocal Open Scope morphism_scope.\r\n\r\nSection prod.\r\n  Variables C D : PreCategory.\r\n\r\n  Definition prodC : PreCategory.\r\n    refine (@ Build_PreCategory\r\n              (C * D)%type\r\n              (fun s d => (morphism C (fst s) (fst d)\r\n                           * morphism D (snd s) (snd d))%type)\r\n              (fun x => (identity (fst x), identity (snd x)))\r\n              (fun s d d' m2 m1 => (fst m2 o fst m1, snd m2 o snd m1))\r\n              _\r\n              _\r\n              _); admit.\r\n  Defined.\r\nEnd prod.\r\nInfix \"*\" := prodC : category_scope.\r\n\r\nDelimit Scope functor_scope with functor.\r\n\r\nSection Functor.\r\n  Variables C D : PreCategory.\r\n\r\n  Record Functor :=\r\n    {\r\n      object_of :> C -> D;\r\n      morphism_of : forall s d, morphism C s d\r\n                                -> morphism D (object_of s) (object_of d);\r\n      composition_of : forall s d d'\r\n                              (m1 : morphism C s d) (m2: morphism C d d'),\r\n                         morphism_of _ _ (m2 o m1)\r\n                         = (morphism_of _ _ m2) o (morphism_of _ _ m1);\r\n      identity_of : forall x, morphism_of _ _ (identity x)\r\n                              = identity (object_of x)\r\n    }.\r\nEnd Functor.\r\nArguments morphism_of [C%category] [D%category] F%functor [s%object d%object] m%morphism : rename, simpl nomatch.\r\n\r\nSection law4.\r\n  Variables C1 C2 D : PreCategory.\r\n  Variable F : Functor (C1 * C2) D.\r\n\r\n  Definition inverse_object_of_object_of\r\n  : C1 -> (C2 -> D)%category.\r\n  Proof.\r\n    intro c1.\r\n    refine (Build_Functor\r\n              C2 D\r\n              (fun c2 => F (c1, c2))\r\n              (fun s2 d2 m2 => morphism_of\r\n                                 F\r\n                                 (s := (_, _))\r\n                                 (d := (_, _))\r\n                                 (identity c1, m2))\r\n              _\r\n              _) || fail 1 \"too early\".\r\n    Undo.\r\n    refine (Build_Functor\r\n              C2 D\r\n              (fun c2 => F (c1, c2))\r\n              (fun s2 d2 m2 => morphism_of\r\n                                 F\r\n                                 (identity c1, m2))\r\n              _\r\n              _). (* Toplevel input, characters 189-206:\r\nError:\r\nIn environment\r\nC1, C2, D : PreCategory\r\nF : Functor (C1 * C2) D\r\nc1 : C1\r\ns2 : C2\r\nd2 : C2\r\nm2 : morphism C2 s2 d2\r\nThe term \"(1, m2)\" has type \"(morphism C1 c1 c1 * morphism C2 s2 d2)%type\"\r\nwhile it is expected to have type \"morphism (C1 * C2) ?s ?d\".\r\n *)\r\n```\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337534411/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337534413","html_url":"https://github.com/coq/coq/issues/4215#issuecomment-337534413","issue_url":"https://api.github.com/repos/coq/coq/issues/4215","id":337534413,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzNDQxMw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-29T19:20:42Z","updated_at":"2020-03-26T20:51:58Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nNote: A workaround is to insert at the top of the file:\r\n```coq\r\nSet Implicit Arguments.\r\nRecord prod A B := pair { fst : A ; snd : B }.\r\nNotation \"x * y\" := (prod x y) : type_scope.\r\nNotation \"( x , y , .. , z )\" := (pair .. (pair x y) .. z) : core_scope.\r\nCanonical Structure default_Pair {A B : Type} a b : (A * B)%type := (a, b).\r\n\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337534413/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]