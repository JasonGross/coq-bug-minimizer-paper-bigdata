[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521985","html_url":"https://github.com/coq/coq/issues/3485#issuecomment-337521985","issue_url":"https://api.github.com/repos/coq/coq/issues/3485","id":337521985,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTk4NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-04T11:56:35Z","updated_at":"2017-10-18T09:25:31Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n(* File reduced by coq-bug-finder from original input, then from 7794 lines to 258 lines, then from 224 lines to 188 lines, then from 181 lines to 158 lines *)\n\nSet Universe Polymorphism.\nSet Primitive Projections.\nReserved Infix \"o\" (at level 40, left associativity).\nDefinition relation (A : Type) := A -> A -> Type.\nClass Transitive {A} (R : relation A) := transitivity : forall x y z, R x y -> R y z -> R x z.\nTactic Notation \"etransitivity\" open_constr(y) :=\n  let R := match goal with |- ?R ?x ?z => constr:(R) end in\n  let x := match goal with |- ?R ?x ?z => constr:(x) end in\n  let z := match goal with |- ?R ?x ?z => constr:(z) end in\n  refine (@ transitivity _ R _ x y z _ _).\nTactic Notation \"etransitivity\" := etransitivity _.\nNotation \"( x ; y )\" := (existT _ x y) : fibration_scope.\nOpen Scope fibration_scope.\nNotation \"x .1\" := (projT1 x) (at level 3) : fibration_scope.\nNotation \"x .2\" := (projT2 x) (at level 3) : fibration_scope.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where \"x = y\" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z := match p, q with idpath, idpath => idpath end.\nInstance transitive_paths {A} : Transitive (@ paths A) | 0 := @ concat A.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y\n  := match p with idpath => idpath end.\nClass Contr_internal (A : Type) := { center : A ; contr : (forall y : A, center = y) }.\nGeneralizable Variables X A B C f g n.\nDefinition projT1_path `{P : A -> Type} {u v : sigT P} (p : u = v) : u.1 = v.1 := ap (@ projT1 _ _) p.\nNotation \"p ..1\" := (projT1_path p) (at level 3) : fibration_scope.\nLtac simpl_do_clear tac term :=\n  let H := fresh in\n  assert (H := term);\n    simpl in H |- *;\n    tac H;\n    clear H.\nSet Implicit Arguments.\nDelimit Scope morphism_scope with morphism.\nDelimit Scope category_scope with category.\nDelimit Scope object_scope with object.\nRecord PreCategory :=\n  { object :> Type;\n    morphism : object -> object -> Type;\n\n    identity : forall x, morphism x x;\n    compose : forall s d d',\n                morphism d d'\n                -> morphism s d\n                -> morphism s d'\n                            where \"f 'o' g\" := (compose f g);\n\n    left_identity : forall a b (f : morphism a b), identity b o f = f;\n    right_identity : forall a b (f : morphism a b), f o identity a = f }.\nArguments identity {C%category} / x%object : rename.\nArguments compose {C%category} / {s d d'}%object (m1 m2)%morphism : rename.\nInfix \"o\" := compose : morphism_scope.\nNotation \"1\" := (identity _) : morphism_scope.\nDelimit Scope functor_scope with functor.\nLocal Open Scope morphism_scope.\nRecord Functor (C D : PreCategory) :=\n  { object_of :> C -> D;\n    morphism_of : forall s d, morphism C s d\n                              -> morphism D (object_of s) (object_of d);\n    identity_of : forall x, morphism_of _ _ (identity x)\n                            = identity (object_of x) }.\nBind Scope functor_scope with Functor.\nArguments morphism_of [C%category] [D%category] F%functor / [s%object d%object] m%morphism : rename.\nNotation \"F '_1' m\" := (morphism_of F m) (at level 10, no associativity) : morphism_scope.\nSection composition.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n  Variable E : PreCategory.\n  Variable G : Functor D E.\n  Variable F : Functor C D.\n\n  Local Notation c_object_of c := (G (F c)) (only parsing).\n  Local Notation c_morphism_of m := (morphism_of G (morphism_of F m)) (only parsing).\n\n  Definition compose_identity_of x\n  : c_morphism_of (identity x) = identity (c_object_of x)\n    := transport (@ paths _ _)\n                 (identity_of G _)\n                 (ap (@ morphism_of _ _ G _ _) (identity_of F x)).\n\n  Definition composeF : Functor C E\n    := Build_Functor\n         C E\n         (fun c => G (F c))\n         (fun _ _ m => morphism_of G (morphism_of F m))\n         compose_identity_of.\nEnd composition.\nInfix \"o\" := composeF : functor_scope.\n\nDefinition identityF C : Functor C C\n  := Build_Functor C C\n                   (fun x => x)\n                   (fun _ _ x => x)\n                   (fun _ => idpath).\nNotation \"1\" := (identityF _) : functor_scope.\n\nRecord NaturalTransformation C D (F G : Functor C D) := { components_of :> forall c, morphism D (F c) (G c) }.\n\nSection unit.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n  Variable F : Functor C D.\n  Variable G : Functor D C.\n\n  Definition AdjunctionUnit :=\n    { T : NaturalTransformation 1 (G o F)\n                                & forall (c : C) (d : D) (f : morphism C c (G d)),\n                                    Contr_internal { g : morphism D (F c) d & G _1 g o T c = f }\n    }.\nEnd unit.\nVariable C : PreCategory.\nVariable D : PreCategory.\nVariable F : Functor C D.\nVariable G : Functor D C.\n\nDefinition zig__of__adjunction_unit\n           (A : AdjunctionUnit F G)\n           (Y : C)\n           (eta := A.1)\n           (eps := fun X => (@ center _ (A.2 (G X) X 1)).1)\n: G _1 (eps (F Y) o F _1 (eta Y)) o eta Y = eta Y\n  -> eps (F Y) o F _1 (eta Y) = 1.\nProof.\n  intros.\n  etransitivity; [ symmetry | ];\n  simpl_do_clear\n    ltac:(fun H => apply H)\n           (fun y H => (@ contr _ (A.2 _ _ (A.1 Y)) (y; H))..1);\n  try assumption.\n  simpl.\n  rewrite ?@ identity_of, ?@ left_identity, ?@ right_identity;\n    reflexivity.\nQed. (* Toplevel input, characters 15-19:\nError: Unsatisfied constraints:\nTop.373 <= Top.372\nTop.373 <= Coq.Init.Specif.8\nTop.373 <= Coq.Init.Specif.23\nTop.374 <= Top.372\nTop.374 <= Coq.Init.Specif.7\nTop.374 <= Coq.Init.Specif.22\n (maybe a bugged tactic).\n *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521985/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]