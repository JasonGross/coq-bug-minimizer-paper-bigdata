[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337528764","html_url":"https://github.com/coq/coq/issues/3888#issuecomment-337528764","issue_url":"https://api.github.com/repos/coq/coq/issues/3888","id":337528764,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyODc2NA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-12-27T05:53:17Z","updated_at":"2017-11-19T11:33:01Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n```coq\r\n\r\n(* File reduced by coq-bug-finder from original input, then from 1426 lines to 322 lines, then from 284 lines to 223 lines, then from 238 lines to 201 lines *)\r\n(* coqc version trunk (December 2014) compiled on Dec 23 2014 22:6:43 with OCaml 4.01.0\r\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (90ed6636dea41486ddf2cc0daead83f9f0788163) *)\r\nRequire Coq.Program.Program.\r\nImport Coq.Program.Program.\r\nImport Coq.Lists.List.\r\nSet Asymmetric Patterns.\r\nAxiom string : Set.\r\n\r\nSet Implicit Arguments.\r\n\r\nRecord string_like (CharType : Type) :=\r\n  {\r\n    String :> Type;\r\n    Singleton : CharType -> String where \"[ x ]\" := (Singleton x);\r\n    Empty : String;\r\n    Concat : String -> String -> String where \"x ++ y\" := (Concat x y);\r\n    bool_eq : String -> String -> bool;\r\n    bool_eq_correct : forall x y : String, bool_eq x y = true <-> x = y;\r\n    Length : String -> nat;\r\n    Associativity : forall x y z, (x ++ y) ++ z = x ++ (y ++ z);\r\n    LeftId : forall x, Empty ++ x = x;\r\n    RightId : forall x, x ++ Empty = x;\r\n    Length_correct : forall s1 s2, Length s1 + Length s2 = Length (s1 ++ s2);\r\n    Length_Empty : Length Empty = 0;\r\n    Empty_Length : forall s1, Length s1 = 0 -> s1 = Empty\r\n  }.\r\n\r\nDelimit Scope string_like_scope with string_like.\r\nBind Scope string_like_scope with String.\r\nNotation \"[[ x ]]\" := (@ Singleton _ _ x) : string_like_scope.\r\nInfix \"++\" := (@ Concat _ _) : string_like_scope.\r\nSection cfg.\r\n  Variable CharType : Type.\r\n\r\n  Section definitions.\r\n\r\n    Inductive item :=\r\n  | Terminal (_ : CharType)\r\n  | NonTerminal (name : string).\r\n\r\n    Definition production := list item.\r\n    Definition productions := list production.\r\n\r\n    Record grammar :=\r\n      {\r\n        Start_symbol :> string;\r\n        Lookup :> string -> productions;\r\n        Start_production :> productions := Lookup Start_symbol;\r\n        Valid_nonterminal_symbols : list string;\r\n        Valid_nonterminals : list productions := map Lookup Valid_nonterminal_symbols\r\n      }.\r\n  End definitions.\r\n\r\n  Section parse.\r\n    Variable String : string_like CharType.\r\n    Variable G : grammar.\r\n\r\n    Inductive parse_of : String -> productions -> Type :=\r\n    | ParseHead : forall str pat pats, parse_of_production str pat\r\n                                       -> parse_of str (pat::pats)\r\n    | ParseTail : forall str pat pats, parse_of str pats\r\n                                       -> parse_of str (pat::pats)\r\n    with parse_of_production : String -> production -> Type :=\r\n    | ParseProductionNil : parse_of_production (Empty _) nil\r\n    | ParseProductionCons : forall str pat strs pats,\r\n                              parse_of_item str pat\r\n                              -> parse_of_production strs pats\r\n                              -> parse_of_production (str ++ strs) (pat::pats)\r\n    with parse_of_item : String -> item -> Type :=\r\n    | ParseTerminal : forall x, parse_of_item [[ x ]]%string_like (Terminal x)\r\n    | ParseNonTerminal : forall name str, parse_of str (Lookup G name)\r\n                                          -> parse_of_item str (NonTerminal name).\r\n  End parse.\r\nEnd cfg.\r\n\r\nLocal Notation \"f \\o g\" := (fun x => f (g x)) (at level 40).\r\n\r\nSection cfg'.\r\n  Context CharType (String : string_like CharType) (G : grammar CharType).\r\n  Context (productions_listT : Type)\r\n          (initial_productions_data : productions_listT)\r\n          (is_valid_productions : productions_listT -> productions CharType -> bool)\r\n          (remove_productions : productions_listT -> productions CharType -> productions_listT)\r\n          (productions_listT_R : productions_listT -> productions_listT -> Prop)\r\n          (remove_productions_dec : forall ls prods, is_valid_productions ls prods = true\r\n                                                     -> productions_listT_R (remove_productions ls prods) ls)\r\n          (remove_productions_1\r\n           : forall ls ps,\r\n               is_valid_productions ls ps = false\r\n               -> forall ps', is_valid_productions (remove_productions ls ps) ps' = is_valid_productions ls ps')\r\n          (ntl_wf : well_founded productions_listT_R).\r\n\r\n  Inductive minimal_parse_of\r\n  : productions_listT -> String -> productions CharType -> Type :=\r\n  | MinParseHead : forall valid str pat pats,\r\n                     minimal_parse_of_production valid str pat\r\n                     -> minimal_parse_of valid str (pat::pats)\r\n  | MinParseTail : forall valid str pat pats,\r\n                     minimal_parse_of valid str pats\r\n                     -> minimal_parse_of valid str (pat::pats)\r\n  with minimal_parse_of_production\r\n       : productions_listT -> String -> production CharType -> Type :=\r\n  | MinParseProductionNil : forall valid,\r\n                              minimal_parse_of_production valid (Empty _) nil\r\n  | MinParseProductionConsDec : forall valid str pat strs pats,\r\n                                  str <> Empty _\r\n                                  -> strs <> Empty _\r\n                                  -> minimal_parse_of_item initial_productions_data str pat\r\n                                  -> minimal_parse_of_production initial_productions_data strs pats\r\n                                  -> minimal_parse_of_production valid (str ++ strs) (pat::pats)\r\n  | MinParseProductionConsEmpty0 : forall valid str pat strs pats,\r\n                                     str = Empty _\r\n                                     -> strs <> Empty _\r\n                                     -> minimal_parse_of_item initial_productions_data str pat\r\n                                     -> minimal_parse_of_production valid strs pats\r\n                                     -> minimal_parse_of_production valid (str ++ strs) (pat::pats)\r\n  | MinParseProductionConsEmpty1 : forall valid str pat strs pats,\r\n                                     str <> Empty _\r\n                                     -> strs = Empty _\r\n                                     -> minimal_parse_of_item valid str pat\r\n                                     -> minimal_parse_of_production initial_productions_data strs pats\r\n                                     -> minimal_parse_of_production valid (str ++ strs) (pat::pats)\r\n  | MinParseProductionConsEmpty01 : forall valid str pat strs pats,\r\n                                      str = Empty _\r\n                                      -> strs = Empty _\r\n                                      -> minimal_parse_of_item valid str pat\r\n                                      -> minimal_parse_of_production valid strs pats\r\n                                      -> minimal_parse_of_production valid (str ++ strs) (pat::pats)\r\n  with minimal_parse_of_item\r\n       : productions_listT -> String -> item CharType -> Type :=\r\n  | MinParseTerminal : forall valid x,\r\n                         minimal_parse_of_item valid [[ x ]]%string_like (Terminal x)\r\n  | MinParseNonTerminal\r\n    : forall valid name str,\r\n        is_valid_productions valid (Lookup G name) = true\r\n        -> minimal_parse_of (remove_productions valid (Lookup G name)) str (Lookup G name)\r\n        -> minimal_parse_of_item valid str (NonTerminal CharType name).\r\n  Let P : productions CharType -> Prop.\r\n    exact (fun p => is_valid_productions initial_productions_data p = true).\r\n  Defined.\r\n\r\n  Let valid_mapT := forall p : productions CharType,\r\n                      { v : option productions_listT\r\n                      | v = None \\/ exists v', v = Some v' /\\ is_valid_productions v' p = true }.\r\n\r\n  Local Notation alt_option valid str valid_map\r\n    := { p : _ & (is_valid_productions valid p = false /\\ P p)\r\n                 * match valid_map p with\r\n                     | Some v => minimal_parse_of v str p\r\n                     | None => False\r\n                   end }%type.\r\n\r\n  Section item.\r\n    Context {str : String} (valid : productions_listT) {it : item CharType}.\r\n    Context (valid_map : valid_mapT).\r\n\r\n    Context (minimal_parse_of__of__parse_of\r\n             : forall {str : String} (valid : productions_listT) {pats : productions CharType}\r\n                      (valid_map : valid_mapT)\r\n                      (p : parse_of String G str pats),\r\n                 (minimal_parse_of valid str pats + alt_option valid str (@ proj1_sig _ _ \\o valid_map))).\r\n\r\n    Definition minimal_parse_of_item__of__parse_of_item'\r\n               (p : parse_of_item String G str it)\r\n    : (minimal_parse_of_item valid str it + alt_option valid str (@ proj1_sig _ _ \\o valid_map)).\r\n    Proof.\r\n      revert minimal_parse_of__of__parse_of.\r\n\r\n      admit.\r\n    Defined.\r\n  End item.\r\n\r\n  Axiom admit : forall {T}, T.\r\n\r\n  Fixpoint minimal_parse_of__of__parse_of\r\n          {str : String} (valid : productions_listT) {pats : productions CharType}\r\n          (valid_map : valid_mapT)\r\n          (p : parse_of String G str pats)\r\n          {struct p}\r\n  : (minimal_parse_of valid str pats + alt_option valid str (@ proj1_sig _ _ \\o valid_map))\r\n    := admit\r\n  with minimal_parse_of_production__of__parse_of_production\r\n         {str : String} (valid : productions_listT) {pat : production CharType}\r\n         (valid_map : valid_mapT)\r\n         (p : parse_of_production String G str pat)\r\n         {struct p}\r\n       :  (minimal_parse_of_production valid str pat + alt_option valid str (@ proj1_sig _ _ \\o valid_map))\r\n       := match\r\n           p as p in (parse_of_production _ _ str pat)\r\n           return\r\n           (minimal_parse_of_production valid str pat + alt_option valid str (@ proj1_sig _ _ \\o valid_map))\r\n         with\r\n           | ParseProductionNil\r\n             => admit\r\n           | ParseProductionCons str0 pat' str1 pats' p0' p1'\r\n             => let mp0 := minimal_parse_of_item__of__parse_of_item' valid valid_map (@ minimal_parse_of__of__parse_of) p0' in\r\n                admit\r\n         end.\r\n\r\n  Program Fixpoint minimal_parse_of__of__parse_of'\r\n          {str : String} (valid : productions_listT) {pats : productions CharType}\r\n          (valid_map : valid_mapT)\r\n          (p : parse_of String G str pats)\r\n          {struct p}\r\n  : (minimal_parse_of valid str pats + alt_option valid str (@ proj1_sig _ _ \\o valid_map))\r\n    := admit\r\n  with minimal_parse_of_production__of__parse_of_production'\r\n         {str : String} (valid : productions_listT) {pat : production CharType}\r\n         (valid_map : valid_mapT)\r\n         (p : parse_of_production String G str pat)\r\n         {struct p}\r\n       :  (minimal_parse_of_production valid str pat + alt_option valid str (@ proj1_sig _ _ \\o valid_map))\r\n       := match\r\n           p as p in (parse_of_production _ _ str pat)\r\n           return\r\n           (minimal_parse_of_production valid str pat + alt_option valid str (@ proj1_sig _ _ \\o valid_map))\r\n         with\r\n           | ParseProductionNil\r\n             => admit\r\n           | ParseProductionCons str0 pat' str1 pats' p0' p1'\r\n             => let mp0 := minimal_parse_of_item__of__parse_of_item' valid valid_map (@ minimal_parse_of__of__parse_of') p0' in\r\n                admit\r\n         end.\r\n  (* Toplevel input, characters 1122-1154:\r\nError:\r\nIn environment\r\nCharType : Type\r\nString : string_like CharType\r\nG : grammar CharType\r\nproductions_listT : Type\r\ninitial_productions_data : productions_listT\r\nis_valid_productions : productions_listT -> productions CharType -> bool\r\nremove_productions : productions_listT ->\r\n                     productions CharType -> productions_listT\r\nproductions_listT_R : productions_listT -> productions_listT -> Prop\r\nremove_productions_dec : forall (ls : productions_listT)\r\n                           (prods : productions CharType),\r\n                         is_valid_productions ls prods = true ->\r\n                         productions_listT_R (remove_productions ls prods) ls\r\nremove_productions_1 : forall (ls : productions_listT)\r\n                         (ps : productions CharType),\r\n                       is_valid_productions ls ps = false ->\r\n                       forall ps' : productions CharType,\r\n                       is_valid_productions (remove_productions ls ps) ps' =\r\n                       is_valid_productions ls ps'\r\nntl_wf : well_founded productions_listT_R\r\nP := fun p0 : productions CharType =>\r\n     is_valid_productions initial_productions_data p0 = true\r\n  : productions CharType -> Prop\r\nvalid_mapT := forall p0 : productions CharType,\r\n              {v : option productions_listT |\r\n              v = None \\/\r\n              (exists v' : productions_listT,\r\n                 v = Some v' /\\ is_valid_productions v' p0 = true)} : Type\r\nminimal_parse_of__of__parse_of' : fix_proto\r\n                                    (forall (str : String)\r\n                                       (valid : productions_listT)\r\n                                       (pats : productions CharType)\r\n                                       (valid_map : valid_mapT),\r\n                                     parse_of String G str pats ->\r\n                                     minimal_parse_of valid str pats +\r\n                                     {p0 : productions CharType &\r\n                                     ((is_valid_productions valid p0 = false /\\\r\n                                       P p0) *\r\n                                      (let filtered_var :=\r\n                                         ` (valid_map p0) in\r\n                                       let program_branch_0 :=\r\n                                         fun (v : productions_listT)\r\n                                           (_ : Some v = filtered_var) =>\r\n                                         minimal_parse_of v str p0 in\r\n                                       let program_branch_1 :=\r\n                                         fun _ : None = filtered_var => False\r\n                                         in\r\n                                       match\r\n                                         filtered_var as anonymous'\r\n                                         return\r\n                                           (anonymous' = filtered_var -> Type)\r\n                                       with\r\n                                       | Some v => program_branch_0 v\r\n                                       | None => program_branch_1\r\n                                       end eq_refl))%type})\r\nminimal_parse_of_production__of__parse_of_production'\r\n : fix_proto\r\n     (forall (str : String) (valid : productions_listT)\r\n        (pat : production CharType) (valid_map : valid_mapT),\r\n      parse_of_production String G str pat ->\r\n      minimal_parse_of_production valid str pat +\r\n      {p0 : productions CharType &\r\n      ((is_valid_productions valid p0 = false /\\ P p0) *\r\n       (let filtered_var := ` (valid_map p0) in\r\n        let program_branch_0 :=\r\n          fun (v : productions_listT) (_ : Some v = filtered_var) =>\r\n          minimal_parse_of v str p0 in\r\n        let program_branch_1 := fun _ : None = filtered_var => False in\r\n        match\r\n          filtered_var as anonymous'\r\n          return (anonymous' = filtered_var -> Type)\r\n        with\r\n        | Some v => program_branch_0 v\r\n        | None => program_branch_1\r\n        end eq_refl))%type})\r\nstr : String\r\nvalid : productions_listT\r\npat : production CharType\r\nvalid_map : valid_mapT\r\np : parse_of_production String G str pat\r\nstr0 : String\r\npat' : item CharType\r\nstr1 : String\r\npats' : production CharType\r\np0' : parse_of_item String G str0 pat'\r\np1' : parse_of_production String G str1 pats'\r\nThe term \"minimal_parse_of__of__parse_of'\" has type\r\n \"fix_proto\r\n    (forall (str : String) (valid : productions_listT)\r\n       (pats : productions CharType) (valid_map : valid_mapT),\r\n     parse_of String G str pats ->\r\n     minimal_parse_of valid str pats +\r\n     {p0 : productions CharType &\r\n     ((is_valid_productions valid p0 = false /\\ P p0) *\r\n      (let filtered_var := ` (valid_map p0) in\r\n       let program_branch_0 :=\r\n         fun (v : productions_listT) (_ : Some v = filtered_var) =>\r\n         minimal_parse_of v str p0 in\r\n       let program_branch_1 := fun _ : None = filtered_var => False in\r\n       match\r\n         filtered_var as anonymous'\r\n         return (anonymous' = filtered_var -> Type)\r\n       with\r\n       | Some v => program_branch_0 v\r\n       | None => program_branch_1\r\n       end eq_refl))%type})\" while it is expected to have type\r\n \"forall (str : String) (valid : productions_listT)\r\n    (pats : productions CharType) (valid_map : valid_mapT),\r\n  parse_of String G str pats ->\r\n  minimal_parse_of valid str pats +\r\n  {p0 : productions CharType &\r\n  ((is_valid_productions valid p0 = false /\\ P p0) *\r\n   match ` (valid_map p0) with\r\n   | Some v => minimal_parse_of v str p0\r\n   | None => False\r\n   end)%type}\"\r\n(cannot unify \"(minimal_parse_of valid0 str2 pats +\r\n                {p : productions CharType &\r\n                (is_valid_productions valid0 p = false /\\ P p) *\r\n                (let filtered_var := ` (valid_map0 p) in\r\n                 let program_branch_0 :=\r\n                   fun (v : productions_listT) (_ : Some v = filtered_var) =>\r\n                   minimal_parse_of v str2 p in\r\n                 let program_branch_1 := fun _ : None = filtered_var => False\r\n                   in\r\n                 match\r\n                   filtered_var as anonymous'\r\n                   return (anonymous' = filtered_var -> Type)\r\n                 with\r\n                 | Some v => program_branch_0 v\r\n                 | None => program_branch_1\r\n                 end eq_refl)})%type\" and\r\n\"(minimal_parse_of valid0 str2 pats +\r\n  alt_option valid0 str2 (fun x : productions CharType => ` (valid_map0 x)))%type\").\r\n *)\r\n\r\n\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337528764/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]