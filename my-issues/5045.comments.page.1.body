Comment author: @JasonGross

Axiom silly : 1 = 1 -> nat -> nat.
Goal forall pf : 1 = 1, silly pf 0 = 0 -> True.
  generalize (@ eq nat).
  constructor.
Qed. (* Error: Illegal application: 
The term "silly" of type "1 = 1 -> nat -> nat"
cannot be applied to the terms
 "pf" : "P 1 1"
 "0" : "nat"
The 1st term has type "P 1 1" which should be coercible to "1 = 1".
 *)


Comment author: @maximedenes

Wow, how can generalize succeed here?


Comment author: @maximedenes

This seems to be a consequence of:

commit 37ab457263e980aa49e681eceb3eb382ef8b36e3
Author: Hugo Herbelin <Hugo.Herbelin@ inria.fr>
Date:   Sat Oct 24 17:53:30 2015 +0200

    Moving apply_type to new proof engine.
    
    Note that code depending on apply_type might now have to ensure that
    typing constraints that were possibly generated by apply_type are now
    taken into account in advance.

I am not sure how to interpret the commit message. Were the tactics relying on apply_type fixed after this commit (apart from generalize)?


Comment author: @herbelin

(In reply to Maxime Dénès from comment [BZ#2](https://github.com/coq/coq/issues?q=is%3Aissue%20%22Original%20bug%20ID%3A%20BZ%232%22))
> This seems to be a consequence of:
> 
> commit 37ab457263e980aa49e681eceb3eb382ef8b36e3
> Author: Hugo Herbelin <Hugo.Herbelin@ inria.fr>
> Date:   Sat Oct 24 17:53:30 2015 +0200
> 
>     Moving apply_type to new proof engine.
>     
>     Note that code depending on apply_type might now have to ensure that
>     typing constraints that were possibly generated by apply_type are now
>     taken into account in advance.
> 
> I am not sure how to interpret the commit message. Were the tactics relying
> on apply_type fixed after this commit (apart from generalize)?

This message was referring to tactics outside the Coq archive.

Within the archive, the apply_type, there were only one occurrences of apply_type in fourier which I bypassed.

About generalize, the point is that I failed to put typing at the right place. It should be done after substitution.

By the way, the code of generalize is excessively convoluted for a tactic simple like this one. I believe it should basically be rewritten from scratch and extended so that it works:
- by giving open subterms (e.g. "generalize (S _)")
- supporting not only a "at" clause, but also a "in" clause, consistently with destruct
- and more generally be connected to a unified mechanism for selecting subterms (whatever strategy, up to some amount of delta or not, is used), e.g. by resorting to an extension with a testing_function of subst_closed_term_occ, or by using the low-level features of rewrite_strat (to see with Matthieu what is the most relevant here).


Comment author: @ppedrot

Fixed by 064de6f.


