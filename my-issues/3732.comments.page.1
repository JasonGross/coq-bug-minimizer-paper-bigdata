[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526053","html_url":"https://github.com/coq/coq/issues/3732#issuecomment-337526053","issue_url":"https://api.github.com/repos/coq/coq/issues/3732","id":337526053,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjA1Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-14T04:24:21Z","updated_at":"2018-06-10T11:26:51Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nThe following code, from Bedrock, works in Coq 8.4, but fails in trunk:\r\n```coq\r\n(* File reduced by coq-bug-finder from original input, then from 2073 lines to 358 lines, then from 359 lines to 218 lines, then from 107 lines to 92 lines *)\r\n(* coqc version trunk (October 2014) compiled on Oct 11 2014 1:13:41 with OCaml 4.01.0\r\n   coqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (d65496f09c4b68fa318783e53f9cd6d5c18e1eb7) *)\r\nRequire Coq.Lists.List.\r\n\r\nImport Coq.Lists.List.\r\n\r\nSet Implicit Arguments.\r\nGlobal Set Asymmetric Patterns.\r\n\r\nSection machine.\r\n  Variables pc state : Type.\r\n\r\n  Inductive propX (i := pc) (j := state) : list Type -> Type :=\r\n  | Inj : forall G, Prop -> propX G\r\n  | ExistsX : forall G A, propX (A :: G) -> propX G.\r\n\r\n  Implicit Arguments Inj [G].\r\n\r\n  Definition PropX := propX nil.\r\n  Fixpoint last (G : list Type) : Type.\r\n    exact (match G with\r\n             | nil => unit\r\n             | T :: nil => T\r\n             | _ :: G' => last G'\r\n           end).\r\n  Defined.\r\n  Fixpoint eatLast (G : list Type) : list Type.\r\n    exact (match G with\r\n             | nil => nil\r\n             | _ :: nil => nil\r\n             | x :: G' => x :: eatLast G'\r\n           end).\r\n  Defined.\r\n\r\n  Fixpoint subst G (p : propX G) : (last G -> PropX) -> propX (eatLast G) :=\r\n    match p with\r\n      | Inj _ P => fun _ => Inj P\r\n      | ExistsX G A p1 => fun p' =>\r\n                            match G return propX (A :: G) -> propX (eatLast (A :: G)) -> propX (eatLast G) with\r\n                              | nil => fun p1 _ => ExistsX p1\r\n                              | _ :: _ => fun _ rc => ExistsX rc\r\n                            end p1 (subst p1 (match G return (last G -> PropX) -> last (A :: G) -> PropX with\r\n                                                | nil => fun _ _ => Inj True\r\n                                                | _ => fun p' => p'\r\n                                              end p'))\r\n    end.\r\n\r\n  Definition spec := state -> PropX.\r\n  Definition codeSpec := pc -> option spec.\r\n\r\n  Inductive valid (specs : codeSpec) (G : list PropX) : PropX -> Prop := Env : forall P, In P G -> valid specs G P.\r\n  Definition interp specs := valid specs nil.\r\nEnd machine.\r\nNotation \"'ExX' : A , P\" := (ExistsX (A := A) P) (x ident, at level 89) : PropX_scope.\r\nBind Scope PropX_scope with PropX propX.\r\nVariables pc state : Type.\r\n\r\nInductive subs : list Type -> Type :=\r\n| SNil : subs nil\r\n| SCons : forall T Ts, (last (T :: Ts) -> PropX pc state) -> subs (eatLast (T :: Ts)) -> subs (T :: Ts).\r\n\r\nFixpoint SPush G T (s : subs G) (f : T -> PropX pc state) : subs (T :: G) :=\r\n  match s in subs G return subs (T :: G) with\r\n    | SNil => SCons _ nil f SNil\r\n    | SCons T' Ts f' s' => SCons T (T' :: Ts) f' (SPush s' f)\r\n  end.\r\n\r\nFixpoint Substs G (s : subs G) : propX pc state G -> PropX pc state :=\r\n  match s in subs G return propX pc state G -> PropX pc state with\r\n    | SNil => fun p => p\r\n    | SCons _ _ f s' => fun p => Substs s' (subst p f)\r\n  end.\r\nVariable specs : codeSpec pc state.\r\n\r\nLemma simplify_fwd_ExistsX : forall G A s (p : propX pc state (A :: G)),\r\n                               interp specs (Substs s (ExX  : A, p))\r\n                               -> exists a, interp specs (Substs (SPush s a) p).\r\nadmit.\r\nDefined.\r\n\r\nGoal    forall (G : list Type) (A : Type) (p : propX pc state (@ cons Type A G))\r\n               (s : subs G)\r\n               (_ : @ interp pc state specs (@ Substs G s (@ ExistsX pc state G A p)))\r\n               (P : forall _ : subs (@ cons Type A G), Prop)\r\n               (_ : forall (s0 : subs (@ cons Type A G))\r\n                           (_ : @ interp pc state specs (@ Substs (@ cons Type A G) s0 p)),\r\n                      P s0),\r\n          @ ex (forall _ : A, PropX pc state)\r\n              (fun a : forall _ : A, PropX pc state => P (@ SPush G A s a)).\r\n  intros ? ? ? ? H ? H'.\r\n  apply simplify_fwd_ExistsX in H; firstorder.\r\nQed.\r\n (* Toplevel input, characters 15-19:\r\nError: Illegal application:\r\nThe term \"cons\" of type \"forall A : Type, A -> list A -> list A\"\r\ncannot be applied to the terms\r\n \"Type\" : \"Type\"\r\n \"T\" : \"Type\"\r\n \"G0\" : \"list Type\"\r\nThe 2nd term has type \"Type@ {Top.53}\" which should be coercible to\r\n \"Type@ {Top.12}\".\r\n *)\r\n```\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526053/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526054","html_url":"https://github.com/coq/coq/issues/3732#issuecomment-337526054","issue_url":"https://api.github.com/repos/coq/coq/issues/3732","id":337526054,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjA1NA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-03-03T22:23:08Z","updated_at":"2017-10-18T09:36:55Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nFirstorder was buggy, fixed in 8.5.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526054/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]