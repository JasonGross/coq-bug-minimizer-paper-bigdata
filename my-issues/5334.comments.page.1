[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337550998","html_url":"https://github.com/coq/coq/issues/5334#issuecomment-337550998","issue_url":"https://api.github.com/repos/coq/coq/issues/5334","id":337550998,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU1MDk5OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-02-01T19:10:56Z","updated_at":"2019-03-04T03:29:49Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nIt's cool that [match _, _ with] with use typing information from the first one \r\nin matching on the second one.  It's neat (albeit perhaps a bit \r\ncounter-intuitive) that this works:\r\n```coq\r\nInductive vector T : nat -> Type :=\r\n| nil : vector T 0\r\n| cons {n} : T -> vector T n -> vector T (S n).\r\nDefinition tl {T n} (v : vector T (S n)) : vector T n\r\n  := match v with\r\n     | cons _ x xs => xs\r\n     end.\r\nDefinition hd {T n} (v : vector T (S n)) : T\r\n  := match v with\r\n     | cons _ x xs => x\r\n     end.\r\nFixpoint pointwise_eq {T n} (x y : vector T n) : Prop :=\r\n  match x, y with\r\n  | nil, _ => True\r\n  | cons _ x xs, _ => x = hd y /\\ @ pointwise_eq _ _ xs (tl y) (* apparently Coq \r\nfigures out typing information on y *)\r\n  end.\r\n```\r\n\r\nHowever, it's really not cool that this fails:\r\n```coq\r\nAxiom proof_admitted : False.\r\nInductive foo : nat -> Type := bar (t : nat) : foo t.\r\nNotation check x y :=\r\n  (let x' := x in\r\n   let y' := y in\r\n   match x', y' with\r\n   | bar _, bar _ => True\r\n   end).\r\nGoal forall (t : nat) (f : foo t -> foo t), check (bar t) (f (bar t)).\r\nProof.\r\n  (*   forall (t : nat) (f : foo t -> foo t),\r\n  let x' := bar t in\r\n  let y' := f (bar t) in match x' with\r\n                         | bar t0 => let y'0 := f (bar t0) in match y'0 with\r\n                                                              | bar _ => True\r\n                                                              end\r\n                         end *)\r\n  abstract case proof_admitted. (* Error: Illegal application:\r\nThe term \"f\" of type \"foo t -> foo t\" cannot be applied to the term\r\n \"bar t0\" : \"foo t0\"\r\nThis term has type \"foo t0\" which should be coercible to \"foo t\". *)\r\n```\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337550998/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]