Comment author: @JasonGross

(* -*- mode: coq; coq-prog-args: ("-emacs" "-R" "src" "Crypto" "-R" "Bedrock" 
"Bedrock" "-R" "coqprime/Coqprime" "Coqprime" "-top" "I\
nterpretations") -*- *)
(* File reduced by coq-bug-finder from original input, then from 440 lines to 
147 lines, then from 452 lines to 178 lines, then from \
204 lines to 76 lines, then from 102 lines to 44 lines, then from 482 lines to 
129 lines, then from 223 lines to 132 lines, then from\
 237 lines to 134 lines, then from 183 lines to 135 lines, then from 149 lines 
to 135 lines, then from 112 lines to 46 lines, then fr\
om 60 lines to 47 lines, then from 54 lines to 24 lines, then from 38 lines to 
25 lines *)
(* coqc version 8.6rc1 (December 2016) compiled on Dec 8 2016 13:43:59 with 
OCaml 4.02.3
   coqtop version 8.6rc1 (December 2016) *)

Inductive flat_type := Unit | Prod (A B : flat_type).
Inductive exprf (op : flat_type -> flat_type -> Type) {var : Type} : flat_type 
-> Type :=
| Op {t1 tR} (opc : op t1 tR) (args : exprf op t1) : exprf op tR.
Inductive op : flat_type -> flat_type -> Type := .
Arguments Op {_ _ _ _} _ _.
Definition bound_op {var}
           {src2 dst2}
           (opc2 : op src2 dst2)
  : forall (args2 : exprf op (var:=var) src2), Op opc2 args2 = Op opc2 args2
  := match opc2 return (forall args2, Op opc2 args2 = Op opc2 args2) with end.
(* Error:
In environment
var : Type
src2 : flat_type
dst2 : flat_type
opc2 : op src2 dst2
f : flat_type
f0 : flat_type
opc0 : op f f0
args2 : exprf op ?t1
Unable to unify "op f f0" with "op ?t1 ?tR". *)


Comment author: @herbelin

Here is a slightly reduced example:

Inductive exprf (op : unit -> Type) : Type :=
| A : exprf op
| Op tR (opc : op tR) (args : exprf op) : exprf op.
Inductive op : unit -> Type := .
Definition bound_op (dst2 : unit) (opc2 : op dst2)
  : forall (args2 : exprf op), Op op dst2 opc2 args2 = A op
  := match opc2 in op h return (forall args2 : exprf ?[U], Op ?[V] ?[I] opc2 args2 = A op) with end.

It was working in 8.4. What happens is the following:

The constraint

op h <= ?V ?I

is generated in typing Op of opc2. Then ?V = ?U and ?U = op are generated by typing args2 in Op and identifying the return type to the external type. The latter also gives that ?I is either dst2 or h.

The problem is then in "solve_unif_constraints_with_heuristics": ?I is tried to be instantiated with dst2, while for some reason "op h <= ?V ?I" has not yet been simplified into "op h <= op ?I". Not using the instance of ?V, it is not seen that ?I cannot be instantiated with dst2. So the instantiation by dst2 is done and it fails too late when trying to again unify "op h <= ?V ?I".

I don't know when it started to fail, but I suspect that it was related to some postponing of the higher-order problem (namely here "op h <= ?V ?I"). The best place where I see a solution is at the time of setting ?V := ?U and ?U := op. It should be noticed that the pending higher-order problems is reducible.

That's all I can say at the current time.


Comment author: @JasonGross

Bisecting with my coq-bisect script gives:

e2fa65fccb9d55ea0b6bd5873155abf436785b1f is the first bad commit
commit e2fa65fccb9d55ea0b6bd5873155abf436785b1f
Author: Hugo Herbelin <Hugo.Herbelin@ inria.fr>
Date:   Mon Nov 3 19:31:43 2014 +0100

    When solving ?id{args} = ?id'{args'}, give preference to ?id:=?id' if
    possible, which is the "natural" way to orient an equation. At least
    it matters for matching subterms against patterns, so that it is the
    pattern variables which are substituted if ever the subterm has itself
    existential variables, as in:

    Goal exists x, S x = x.
    eexists.
    destruct (S _).

:040000 040000 d0a3026aa6942ce3d1aed2b16912a5dacd769c7b 
cf07e179eeaa8d687fb2f477b5905ddf5e60a3ce M      pretyping
:040000 040000 4b37ce869206ce42e110267037bc12b4b8d20c64 
64a608fb8d6f120284bf3f1121f5f24ca7ce8dd8 M      test-suite


Comment author: @herbelin

Thanks for bisecting. However, the success of unification should morally not be dependent in itself on the order in which evar-evar problems are oriented. This report allowed me to find at least a bug in the way pending conversion problems are reconsidered. I pushed a fix in branch v8.5 (a6f687852c).


