[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525403","html_url":"https://github.com/coq/coq/issues/3699#issuecomment-337525403","issue_url":"https://api.github.com/repos/coq/coq/issues/3699","id":337525403,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTQwMw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-07T14:35:57Z","updated_at":"2018-05-30T14:17:58Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nThis might be fixed in newest trunk; either way, here's a test-suite case:\r\n```coq\r\n\r\n(* File reduced by coq-bug-finder from original input, then from 9593 lines to 104 lines, then from 187 lines to 103 lines, then from 113 lines to 90 lines *)\r\n(* coqc version trunk (October 2014) compiled on Oct 1 2014 18:13:54 with OCaml 4.01.0\r\n   coqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (68846802a7be637ec805a5e374655a426b5723a5) *)\r\nAxiom transport : forall {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x), P y.\r\nInductive trunc_index := minus_two | trunc_S (_ : trunc_index).\r\nAxiom IsTrunc : trunc_index -> Type -> Type.\r\nExisting Class IsTrunc.\r\nAxiom Contr : Type -> Type.\r\nInductive Trunc (n : trunc_index) (A :Type) : Type := tr : A -> Trunc n A.\r\nModule NonPrim.\r\n  Unset Primitive Projections.\r\n  Set Implicit Arguments.\r\n  Record sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\r\n  Notation \"{ x : A  & P }\" := (sigT (fun x:A => P)) : type_scope.\r\n  Unset Implicit Arguments.\r\n  Notation \"( x ; y )\" := (existT _ x y) : fibration_scope.\r\n  Open Scope fibration_scope.\r\n  Notation pr1 := projT1.\r\n  Notation pr2 := projT2.\r\n  Notation \"x .1\" := (pr1 x) (at level 3, format \"x '.1'\") : fibration_scope.\r\n  Notation \"x .2\" := (pr2 x) (at level 3, format \"x '.2'\") : fibration_scope.\r\n  Definition hfiber {A B : Type} (f : A -> B) (y : B) := { x : A & f x = y }.\r\n  Class IsConnected (n : trunc_index) (A : Type) := isconnected_contr_trunc :> Contr (Trunc n A).\r\n  Axiom isconnected_elim : forall {n} {A} `{IsConnected n A}\r\n                                  (C : Type) `{IsTrunc n C} (f : A -> C),\r\n                             { c:C & forall a:A, f a = c }.\r\n  Class IsConnMap (n : trunc_index) {A B : Type} (f : A -> B)\r\n    := isconnected_hfiber_conn_map :> forall b:B, IsConnected n (hfiber f b).\r\n  Definition conn_map_elim {n : trunc_index}\r\n             {A B : Type} (f : A -> B) `{IsConnMap n _ _ f}\r\n             (P : B -> Type) {HP : forall b:B, IsTrunc n (P b)}\r\n             (d : forall a:A, P (f a))\r\n  : forall b:B, P b.\r\n  Proof.\r\n    intros b.\r\n    refine (pr1 (isconnected_elim _ _)).\r\n    2:exact b.\r\n    intro x.\r\n    exact (transport P x.2 (d x.1)).\r\n  Defined.\r\n\r\n  Definition conn_map_elim' {n : trunc_index}\r\n             {A B : Type} (f : A -> B) `{IsConnMap n _ _ f}\r\n             (P : B -> Type) {HP : forall b:B, IsTrunc n (P b)}\r\n             (d : forall a:A, P (f a))\r\n  : forall b:B, P b.\r\n  Proof.\r\n    intros b.\r\n    refine (pr1 (isconnected_elim _ _)).\r\n    2:exact b.\r\n    intros [a p].\r\n    exact (transport P p (d a)).\r\n  Defined.\r\n\r\n  Definition conn_map_comp {n : trunc_index}\r\n             {A B : Type} (f : A -> B) `{IsConnMap n _ _ f}\r\n             (P : B -> Type) {HP : forall b:B, IsTrunc n (P b)}\r\n             (d : forall a:A, P (f a))\r\n  : forall a:A, conn_map_elim f P d (f a) = d a /\\ conn_map_elim' f P d (f a) = d a.\r\n  Proof.\r\n    intros a.\r\n    unfold conn_map_elim, conn_map_elim'.\r\n    Set Printing Coercions.\r\n    set (fibermap := fun a0p : hfiber f (f a)\r\n                     => let (a0, p) := a0p in transport P p (d a0)).\r\n    Set Printing Implicit.\r\n    let G := match goal with |- ?G => constr:G end in\r\n    first [ match goal with\r\n              | [ |- (@ isconnected_elim n (@ hfiber A B f (f a))\r\n                                        (@ isconnected_hfiber_conn_map n A B f H (f a))\r\n                                        (P (f a)) (HP (f a))\r\n                                        (fun x : @ hfiber A B f (f a) =>\r\n                                           @ transport B P (f x.1) (f a) x.2 (d x.1))).1 =\r\n                     d a /\\ _ ] => idtac\r\n            end\r\n          | fail 1 \"projection names should be folded, [let] should generate unfolded projections, goal:\" G ];\r\n      first [ match goal with\r\n                | [ |- _ /\\ (@ isconnected_elim n (@ hfiber A B f (f a))\r\n                                               (@ isconnected_hfiber_conn_map n A B f H (f a))\r\n                                               (P (f a)) (HP (f a)) fibermap).1 = d a ] => idtac\r\n              end\r\n            | fail 1 \"destruct should generate unfolded projections, as should [let], goal:\" G ].\r\n    admit.\r\n  Defined.\r\nEnd NonPrim.\r\n\r\nModule Prim.\r\n  Set Primitive Projections.\r\n  Set Implicit Arguments.\r\n  Record sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\r\n  Notation \"{ x : A  & P }\" := (sigT (fun x:A => P)) : type_scope.\r\n  Unset Implicit Arguments.\r\n  Notation \"( x ; y )\" := (existT _ x y) : fibration_scope.\r\n  Open Scope fibration_scope.\r\n  Notation pr1 := projT1.\r\n  Notation pr2 := projT2.\r\n  Notation \"x .1\" := (pr1 x) (at level 3, format \"x '.1'\") : fibration_scope.\r\n  Notation \"x .2\" := (pr2 x) (at level 3, format \"x '.2'\") : fibration_scope.\r\n  Definition hfiber {A B : Type} (f : A -> B) (y : B) := { x : A & f x = y }.\r\n  Class IsConnected (n : trunc_index) (A : Type) := isconnected_contr_trunc :> Contr (Trunc n A).\r\n  Axiom isconnected_elim : forall {n} {A} `{IsConnected n A}\r\n                                  (C : Type) `{IsTrunc n C} (f : A -> C),\r\n                             { c:C & forall a:A, f a = c }.\r\n  Class IsConnMap (n : trunc_index) {A B : Type} (f : A -> B)\r\n    := isconnected_hfiber_conn_map :> forall b:B, IsConnected n (hfiber f b).\r\n  Definition conn_map_elim {n : trunc_index}\r\n             {A B : Type} (f : A -> B) `{IsConnMap n _ _ f}\r\n             (P : B -> Type) {HP : forall b:B, IsTrunc n (P b)}\r\n             (d : forall a:A, P (f a))\r\n  : forall b:B, P b.\r\n  Proof.\r\n    intros b.\r\n    refine (pr1 (isconnected_elim _ _)).\r\n    2:exact b.\r\n    intro x.\r\n    exact (transport P x.2 (d x.1)).\r\n  Defined.\r\n\r\n  Definition conn_map_elim' {n : trunc_index}\r\n             {A B : Type} (f : A -> B) `{IsConnMap n _ _ f}\r\n             (P : B -> Type) {HP : forall b:B, IsTrunc n (P b)}\r\n             (d : forall a:A, P (f a))\r\n  : forall b:B, P b.\r\n  Proof.\r\n    intros b.\r\n    refine (pr1 (isconnected_elim _ _)).\r\n    2:exact b.\r\n    intros [a p].\r\n    exact (transport P p (d a)).\r\n  Defined.\r\n\r\n  Definition conn_map_comp {n : trunc_index}\r\n             {A B : Type} (f : A -> B) `{IsConnMap n _ _ f}\r\n             (P : B -> Type) {HP : forall b:B, IsTrunc n (P b)}\r\n             (d : forall a:A, P (f a))\r\n  : forall a:A, conn_map_elim f P d (f a) = d a /\\ conn_map_elim' f P d (f a) = d a.\r\n  Proof.\r\n    intros a.\r\n    unfold conn_map_elim, conn_map_elim'.\r\n    Set Printing Coercions.\r\n    set (fibermap := fun a0p : hfiber f (f a)\r\n                     => let (a0, p) := a0p in transport P p (d a0)).\r\n    Set Printing Implicit.\r\n    let G := match goal with |- ?G => constr:G end in\r\n    first [ match goal with\r\n              | [ |- (@ isconnected_elim n (@ hfiber A B f (f a))\r\n                                        (@ isconnected_hfiber_conn_map n A B f H (f a))\r\n                                        (P (f a)) (HP (f a))\r\n                                        (fun x : @ hfiber A B f (f a) =>\r\n                                           @ transport B P (f x.1) (f a) x.2 (d x.1))).1 =\r\n                     d a /\\ _ ] => idtac\r\n            end\r\n          | fail 1 \"projection names should be folded, [let] should generate unfolded projections, goal:\" G ];\r\n      first [ match goal with\r\n                | [ |- _ /\\ (@ isconnected_elim n (@ hfiber A B f (f a))\r\n                                               (@ isconnected_hfiber_conn_map n A B f H (f a))\r\n                                               (P (f a)) (HP (f a)) fibermap).1 = d a ] => idtac\r\n              end\r\n            | fail 1 \"destruct should generate unfolded projections, as should [let], goal:\" G ].\r\n    admit.\r\n  Defined.\r\nEnd Prim.\r\n\r\n\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525403/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525404","html_url":"https://github.com/coq/coq/issues/3699#issuecomment-337525404","issue_url":"https://api.github.com/repos/coq/coq/issues/3699","id":337525404,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTQwNA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-07T14:54:37Z","updated_at":"2017-10-18T09:35:19Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nYes it is! Thanks for the test-suite file anyway.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525404/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]