[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526763","html_url":"https://github.com/coq/coq/issues/3772#issuecomment-337526763","issue_url":"https://api.github.com/repos/coq/coq/issues/3772","id":337526763,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjc2Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-27T06:10:19Z","updated_at":"2017-10-18T09:39:14Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nHere is some code that I expect to work:\n(* File reduced by coq-bug-finder from original input, then from 9012 lines to 366 lines, then from 378 lines to 163 lines, then from\\\n 143 lines to 96 lines, then from 70 lines to 33 lines *)\n(* coqc version trunk (October 2014) compiled on Oct 25 2014 19:2:39 with OCaml 4.01.0\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (0397aa549645df23cc50c9018b543e6c0b346d62) *)\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nNotation \"g 'o' f\" := (compose g f) (at level 40, left associativity).\nClass Foo := Build_Foo : Set.\nModule MoreProgress.\n  Definition path_universe {A B : Type} (f : A -> B) {feq : Foo} : (A = B).\n    admit.\n  Defined.\n  Goal forall (H : Foo) (H0 H1 : Type) (H2 : H1 -> H0)\n              (H3 : Type) (H4 : H1 -> H3) (H5 : H1 = H3 -> H3 -> H1)\n              (H7 : (H3 -> H0) -> H3 -> Type) (H9 : H3) (H12 : Type),\n         (forall (k : H1 = H3) (x : H3), H7 (H2 o H5 k) x = H12) ->\n         H7 (fun y : H3 => H2 (H5 (path_universe H4) y)) H9.\n    intros.\n    let H0 := match goal with H : _ |- _ => constr:H end in\n    rename H0 into H'.\n    Set Printing Implicit.\n    evar (T : Type).\n    evar (e : T).\n    subst T.\n    let y := constr:(H' (@ path_universe _ _ H4 _)) in\n    rewrite y || fail \"too early\".\n    Undo.\n    unfold compose in *;\n      let e' := (eval unfold e in e) in\n      let y := constr:(H' (@ path_universe _ _ H4 e')) in\n      rewrite y || fail \"too early\".\n    Undo.\n    let e' := (eval unfold e in e) in\n    let y := constr:(H' (@ path_universe _ _ H4 e')) in\n    rewrite y. (* N.B. The evar is dropped during unfolding, because\n                       [path_universe]'s body doesn't mention it, so\n                       we aren't left with uninstantiated evars in\n                       rewriting *)\n    Undo.\n    exfalso; clear; admit.\n    Grab Existential Variables.\n    admit. admit.\n  Defined.\nEnd MoreProgress.\nModule LessProgress.\n  Definition path_universe {A B : Type} (f : A -> B) {feq : Foo} : (A = B).\n    refine (_ feq).\n    admit.\n  Defined.\n  Goal forall (H : Foo) (H0 H1 : Type) (H2 : H1 -> H0)\n              (H3 : Type) (H4 : H1 -> H3) (H5 : H1 = H3 -> H3 -> H1)\n              (H7 : (H3 -> H0) -> H3 -> Type) (H9 : H3) (H12 : Type),\n         (forall (k : H1 = H3) (x : H3), H7 (H2 o H5 k) x = H12) ->\n         H7 (fun y : H3 => H2 (H5 (path_universe H4) y)) H9.\n    intros.\n    let H0 := match goal with H : _ |- _ => constr:H end in\n    rename H0 into H'.\n    Set Printing Implicit.\n    evar (T : Type).\n    evar (e : T).\n    subst T.\n    let y := constr:(H' (@ path_universe _ _ H4 _)) in\n    rewrite y || fail \"too early\".\n    Undo.\n    unfold compose in *;\n      let e' := (eval unfold e in e) in\n      let y := constr:(H' (@ path_universe _ _ H4 e')) in\n      rewrite y || fail \"too early\".\n    Undo.\n    let e' := (eval unfold e in e) in\n    let y := constr:(H' (@ path_universe _ _ H4 e')) in\n    rewrite y. (* Toplevel input, characters 93-102:\nError:\nFound no subterm matching \"H7\n                             (H2\n                              o H5 (@ path_universe H1 H3 H4 ?Goal1@ {T:=Foo}))\n                             ?M190\" in the current goal. *)\n    Undo.\n    exfalso; clear; admit.\n    Grab Existential Variables.\n    admit. admit.\n  Defined.\nEnd LessProgress.\n\n\n\nIt seems that [rewrite] has the behavior that you get either unfolding or unification of evars, but not both.  That is, it seems to only notice that [H2 o H5 (@ path_universe H1 H3 H4 ?Goal1)] and [fun y : H3 => H2 (H5 (@ path_universe H1 H3 H4 H))] are unifiable when unfolding [path_universe] results in the [?Goal1]/[H] argument being dropped.  This seems like a bug.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526763/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526766","html_url":"https://github.com/coq/coq/issues/3772#issuecomment-337526766","issue_url":"https://api.github.com/repos/coq/coq/issues/3772","id":337526766,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjc2Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-22T16:05:31Z","updated_at":"2017-10-18T09:39:14Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nYour example combines different issues:\n- what constants to unfold and when (here \"compose\")\n- using unification or matching\n\nBoth are open questions and, for instance, non-setoid rewrite and setoid rewrite behaves differently wrt both questions (see recent discussion on coqdev).\n\nSo, this is not properly a bug, but typical examples are welcome of when you want conversion and when you don't, and when you want existing evars to be instantiated and when you don't.\n\nI set it as invalid as a \"bug\", though it raises completely relevant questions.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526766/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526768","html_url":"https://github.com/coq/coq/issues/3772#issuecomment-337526768","issue_url":"https://api.github.com/repos/coq/coq/issues/3772","id":337526768,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjc2OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-24T23:29:47Z","updated_at":"2017-10-18T09:39:14Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nIt seems wrong to permit \"conversion that does not instantiate evars\" and \"evar instantiation up to matching\" but not \"conversion that also instantiates evars\".  I expect \"whether to use conversion or matching\" and \"whether or not to instantiate evars\" to be independent axes, and it is confusing to have [rewrite] fail only when you combine these two seemingly independent axes.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526768/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526770","html_url":"https://github.com/coq/coq/issues/3772#issuecomment-337526770","issue_url":"https://api.github.com/repos/coq/coq/issues/3772","id":337526770,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNjc3MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-11-25T10:23:23Z","updated_at":"2017-10-18T09:39:14Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nHi Jason,\n\nAs discussed on coqdev recently [thread subterm selection], rewrite uses a restricted form of \"closed step-by-step conversion\", meaning that full conversion is used only on closed subterms, progressively taking into account the instances of the holes that are already known following a left-to-right processing of subterms. [However, contrarily to what I believed and to what I wrote in this message and in my previous comment, rewrite do solve preexisting evars by unification as soon as the term to rewrite has holes. It is only when the term to rewrite has no holes that it does not solve evars as in \"Goal forall f, exists x, f 0 = 0 -> f x = 0. eexists. intro H. Fail rewrite H.\" (I've been misled by this). I tried a patch to make this more uniform).]\n\nIn particular, \"closed step-by-step conversion\" directly implies that \"to use conversion or matching\" is not regular on its own.\n\nThe question about whether we wish to instantiate evars on the fly or not is accordingly independent, but if we continue to accept it, it will not be independent of whether we use conversion or not.\n\nExplaining your examples, in the first and fourth case of \"rewrite y\", \"H2 (H5 (path_universes H))\" and \"compose H2 H5 (path_universes H)\" are hole-free and convertible, so it succeeds.\n\nIn the second and fifth case, unifying \"H2 (H5 (path_universes ?Goal0))\" with \"H2 (H5 (path_universes H))\" reduces to unifying ?Goal0 and H without needing any conversion, so it succeeds.\n\nIn the third case, \"H2 (H5 (path_universes ?Goal))\" and \"compose H2 H5 (path_universes H)\" are hole-free and convertible (because of the K-redex in path_universes), so it succeeds.\n\nIn the sixth case, \"H2 (H5 (path_universes ?Goal))\" and \"compose H2 H5 (path_universes H)\" are hole-free but not convertible, so it fails.\n\nIn practice, small changes to the current behavior might easily result into incompatilities, efficiency problems, or even other unexpected results, and before stabilizing an hopefully \"optimal\" behavior of rewrite, I think that we need to collect examples of the different behaviors we'd like to obtain.\n\nWith respect to conversion, what is the ideal amount we would like in \"rewrite\"? With full convertibility, the risk is to be exposed sometimes to combinatoric explosion or unexpected matches. But a bit of convertibility is convenient. \n\nI believe that \"keyed unification\" (terminology taken from Ssreflect \"rewrite\") is an important component of what we want. I believe that full conversion on implicit arguments (the strict ones, which are canonically defined, not the user-level ones) is part of what we want to. But I'm skeptical about whether we really want full convertibility (i.e. full delta-expansion) in general.\n\nFor example, I wonder whether we should not classify constants into \"abbreviations\" (like compose), \"functions\" (like plus), \"projections\" (like fst, snd) and to allow delta-conversion say only on abbreviations and projections?\n\nAbout evar instantiation, I'm perplex about whether we want it in its full generality too. Your example is an example where we might wish it, but for instance, at the current time, I don't know what we might prefer in a situation like:\n\nGoal forall f, exists x y, (forall z, f x z = 0) -> f 0 y + f x 0 = x + y.\nintro f. eexists. eexists. intro H. rewrite H.\n\nDo we want both subterms to match individually (with ?x instantiated by 0 in the first case), or only the second, or both at the same time (with both ?x and ?y instantiated by 0)?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337526770/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]