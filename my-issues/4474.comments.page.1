[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337538566","html_url":"https://github.com/coq/coq/issues/4474#issuecomment-337538566","issue_url":"https://api.github.com/repos/coq/coq/issues/4474","id":337538566,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzODU2Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-01-02T16:38:52Z","updated_at":"2017-10-18T10:13:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nIt's great that we have [Arguments foo : simpl never], [Arguments foo /], [Arguments foo !x /], and the [Strategy] vernacular, but I'd like an even more expressive language for specifying the behavior of [simpl].\n\nFor example, there is no way to make [simpl] not handle [List.nth] nicely.  The following is sometimes bad behavior:\n\n  Require Import Coq.Arith.Arith Coq.Lists.List Coq.Program.Program.\n  Time Eval simpl in List.nth 1 [NPeano.pow 5 6; 0] 2. (* 0 s *)\n  Time Eval simpl in List.map (fun y => List.nth y [NPeano.pow 5 6; 0] 2). (* 1.8 s *)\n\nI would like a way to annotate a term (or annotate an identifier) to say things like \"when running [simpl], never look inside the second argument unless the first argument can be unfolded to be headed by a constructor\".\n\nBy contrast, it is frequently the case that running [simpl] on [List.map] should run [simpl] in the function *first*, before applying it to the arguments in the list.  Here is an example of unfortunate behavior:\n\n  Time Eval simpl in List.map (fun y => let x := y + NPeano.pow 5 6 in x) [0]. (* 1.8 s *)\n  Time Eval simpl in List.map (fun y => let x := y + NPeano.pow 5 6 in x) [0; 0]. (* 3.6 s *)\n  Time Eval simpl in List.map (fun y => let x := y + NPeano.pow 5 6 in x) [0; 0; 0]. (* 5.5 s *)\n\nI would like a way to annotate a term (or to annotate an identifier) to say things like \"even though you shouldn't unfold this term until this argument can have a constructor in the head position, you should run [simpl] in this other argument before trying to unfold this term (and then run [simpl] again on the application if needed)\".\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337538566/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337538567","html_url":"https://github.com/coq/coq/issues/4474#issuecomment-337538567","issue_url":"https://api.github.com/repos/coq/coq/issues/4474","id":337538567,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzODU2Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-01-03T09:54:33Z","updated_at":"2017-10-18T10:13:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @silene\n\nI am not sure, but there seems to be a misunderstanding about the \"simpl\" tactic. It performs the simplification of the whole term (or subterm in case of an argument). As the documentation says, it performs \"a kind of strong normalization\" (and \"strong\" should be emphasized here). In particular, as long as \"pow 5 6\" remains in the term, \"simpl\" will spend two seconds simplifying it. The issue is not about delaying simplification of arguments, the issue is about performing (or not) the simplification of the whole term. In other words, I don't think you can get the behavior you want by adding new modifiers for \"simpl\", you need a brand new tactic (a la \"hnf\") that is not \"strong\".\n\nRegarding your second example, it mostly shows that \"simpl\" does not implement the reduction sharing of \"lazy\". If it did, you would get the same timing for the three lists. Note that \"cbn\" is no better with respect to sharing; so much for the \"cbn\" initialism. This is worth a feature request.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337538567/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337538571","html_url":"https://github.com/coq/coq/issues/4474#issuecomment-337538571","issue_url":"https://api.github.com/repos/coq/coq/issues/4474","id":337538571,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzODU3MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-01-12T19:18:37Z","updated_at":"2017-10-18T10:13:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nWhen formalizing semi-simplicial types, I encountered the need for a more customizable \"simpl\" too, and in particular, to tell things like, do only one step of iota, e.g. simplifying \"Nat.pow 5 6\" to only \"5 * Nat.pow 5 5\".\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337538571/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337538575","html_url":"https://github.com/coq/coq/issues/4474#issuecomment-337538575","issue_url":"https://api.github.com/repos/coq/coq/issues/4474","id":337538575,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzODU3NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-01-12T19:39:42Z","updated_at":"2017-10-18T10:13:39Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nAs an aside, you can kludge fixpoints that only ever unfold one step under [simpl]:\n\nDefinition pow_step (pow : nat -> nat -> nat) (n m : nat)\n  := match m with\n     | 0 => 1\n     | S m' => n * pow n m'\n     end.\nFixpoint pow n m {struct m} : nat\n  := pow_step pow n m.\nArguments pow_step : simpl never.\nGoal pow 5 6 = pow 5 6.\n  simpl; unfold pow_step. (* gives [5 * pow 5 5 = 5 * pow 5 5] *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337538575/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]