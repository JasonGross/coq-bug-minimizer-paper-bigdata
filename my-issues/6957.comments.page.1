[{"url":"https://api.github.com/repos/coq/coq/issues/comments/371970722","html_url":"https://github.com/coq/coq/issues/6957#issuecomment-371970722","issue_url":"https://api.github.com/repos/coq/coq/issues/6957","id":371970722,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MTk3MDcyMg==","user":{"login":"gares","id":1013846,"node_id":"MDQ6VXNlcjEwMTM4NDY=","avatar_url":"https://avatars.githubusercontent.com/u/1013846?v=4","gravatar_id":"","url":"https://api.github.com/users/gares","html_url":"https://github.com/gares","followers_url":"https://api.github.com/users/gares/followers","following_url":"https://api.github.com/users/gares/following{/other_user}","gists_url":"https://api.github.com/users/gares/gists{/gist_id}","starred_url":"https://api.github.com/users/gares/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gares/subscriptions","organizations_url":"https://api.github.com/users/gares/orgs","repos_url":"https://api.github.com/users/gares/repos","events_url":"https://api.github.com/users/gares/events{/privacy}","received_events_url":"https://api.github.com/users/gares/received_events","type":"User","site_admin":false},"created_at":"2018-03-09T23:05:29Z","updated_at":"2018-03-09T23:05:29Z","author_association":"MEMBER","body":"What about `Check EqInterp1 _ true` ?\r\nI'm not so sure the \"order\" is the problem here. The problem is that the relevant data for computing is `T` and you are not passing it. If you pass `BOOL` I think both orders are fine.\r\n\r\nYou could make it work, IMO, with unification hints (not in Coq), or, by reformulating things with records, using canonical structures (to solve `bool = TYPE_INTERP ?T`).","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/371970722/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/371985428","html_url":"https://github.com/coq/coq/issues/6957#issuecomment-371985428","issue_url":"https://api.github.com/repos/coq/coq/issues/6957","id":371985428,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MTk4NTQyOA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-03-10T00:43:47Z","updated_at":"2018-03-10T00:43:47Z","author_association":"MEMBER","body":"I expect `Check EqInterp1 _ true` to fail, with a unification/constraint failure.  The issue here is that I should not have to pass implicit arguments when there is enough information to solve for them with first-order unification.\r\n\r\nThe model \"this is very much an issue with the ordering of unification problems\" works well.  For example, this works: `Check (fun x => EqInterp2 x TRUE) true.`","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/371985428/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/372019727","html_url":"https://github.com/coq/coq/issues/6957#issuecomment-372019727","issue_url":"https://api.github.com/repos/coq/coq/issues/6957","id":372019727,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MjAxOTcyNw==","user":{"login":"gares","id":1013846,"node_id":"MDQ6VXNlcjEwMTM4NDY=","avatar_url":"https://avatars.githubusercontent.com/u/1013846?v=4","gravatar_id":"","url":"https://api.github.com/users/gares","html_url":"https://github.com/gares","followers_url":"https://api.github.com/users/gares/followers","following_url":"https://api.github.com/users/gares/following{/other_user}","gists_url":"https://api.github.com/users/gares/gists{/gist_id}","starred_url":"https://api.github.com/users/gares/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gares/subscriptions","organizations_url":"https://api.github.com/users/gares/orgs","repos_url":"https://api.github.com/users/gares/repos","events_url":"https://api.github.com/users/gares/events{/privacy}","received_events_url":"https://api.github.com/users/gares/received_events","type":"User","site_admin":false},"created_at":"2018-03-10T10:29:35Z","updated_at":"2018-03-10T10:35:53Z","author_association":"MEMBER","body":"Let me express my concerns more clearly. Also this seems to be a feature request touching a delicate part of the system, so I take the occasion to discuss the design of the elaborator.\r\n\r\n I know that turning unification problems into a set of constraints solved only when they are lowered to first order seems a good idea. The downside is that it makes the algorithm less predictable (when it does not do what you want). Also, by suspending, you are saying \"I'm not able to type check this term fully, let's continue anyway\" and there are a few invariants that break, eg well typed terms have a normal form, so you can safely reduce them when they occur in types! Although I'm not very concerned by this one in practice, there are other invariants that are less striking from a theoretical POV but are still broken, eg when you check for convertibility of `(fun x : T => a) === (fun y : S => b)` you skip `T === S` because, if (you checked that) the two original terms had the same type, the source of the function must have the same type too (and the elaborator sometimes passes terms down to the kernel). Another tricky bit is where error should be reported. It is getting too technical I guess, but I hope it is sufficiently clear that \"it is not a panacea\".\r\n\r\nAn algorithm that goes \"left to right\" is simple but predictable: you know in advance which data is available and when (you know T is not available when you typecheck the first argument of `EqInterp*`).\r\nBeing simple the algorithm also looks stupid. My opinion is that there are ways to make it smarter without changing the execution order so drastically. For example by being bidirectional (using the type expected by the context while type checking the term in the context) is very related to reordering unification problems, and in practice can turn many HO problems into first order ones. Another technique I cited and that would solves you problem is the one of unification hints (a generalization of canonical structures). In particular here the hard problem is about inverting a (bijective) function: `INTERP_TYPE ?T = bool`. I know that in your example there is always another unification problem that fixes ?T and that is simpler that this one. But even if there is no extra simple problem fixing ?T, the hard problem has a solution!\r\n\r\nRephrasing your example with canonical structures is convoluted, but can be found in this [paper](https://people.mpi-sws.org/~beta/lessadhoc/) while the more general concept of unification hints is in this [paper](http://www.cs.unibo.it/~sacerdot/PAPERS/tphol09.pdf) and the example of section 4 is not so different from the one you have here IIRC.\r\n\r\nI hope to play with the idea of reordering unification problems in elpi, that being a CLP language has decent support for constraints (eg there is a paper by Abel IIRC that express the entire elaboration algorithm in terms of constraints). Actually I have a prototype elaborator for CIC written in elpi, and in some experiment we (or better my colleagues) tried to \"suspend\" hard unification problems. These experiments turned out into long debugging sessions (mostly by me) and most of the time it was not a bug, it was just that the algorithm would take unexpected decisions (possibilities the algorithm would not have even considered if it had made a, maybe suboptimal, choice earlier). So maybe this explains why I'm skeptical.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/372019727/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/372023578","html_url":"https://github.com/coq/coq/issues/6957#issuecomment-372023578","issue_url":"https://api.github.com/repos/coq/coq/issues/6957","id":372023578,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MjAyMzU3OA==","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2018-03-10T11:42:13Z","updated_at":"2018-03-10T11:42:13Z","author_association":"CONTRIBUTOR","body":">when you check for convertibility of (fun x : T => a) === (fun y : S => b) you skip T === S\r\n\r\nWe don't in Reduction and Evarconv AFAICT, do we do that somewhere else?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/372023578/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/372025529","html_url":"https://github.com/coq/coq/issues/6957#issuecomment-372025529","issue_url":"https://api.github.com/repos/coq/coq/issues/6957","id":372025529,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MjAyNTUyOQ==","user":{"login":"gares","id":1013846,"node_id":"MDQ6VXNlcjEwMTM4NDY=","avatar_url":"https://avatars.githubusercontent.com/u/1013846?v=4","gravatar_id":"","url":"https://api.github.com/users/gares","html_url":"https://github.com/gares","followers_url":"https://api.github.com/users/gares/followers","following_url":"https://api.github.com/users/gares/following{/other_user}","gists_url":"https://api.github.com/users/gares/gists{/gist_id}","starred_url":"https://api.github.com/users/gares/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/gares/subscriptions","organizations_url":"https://api.github.com/users/gares/orgs","repos_url":"https://api.github.com/users/gares/repos","events_url":"https://api.github.com/users/gares/events{/privacy}","received_events_url":"https://api.github.com/users/gares/received_events","type":"User","site_admin":false},"created_at":"2018-03-10T12:17:41Z","updated_at":"2018-03-10T12:22:21Z","author_association":"MEMBER","body":"No we don't, but we discussed a few times about doing it.  Does it interact badly with sprop?\r\nAs of today, the invariant \"the two terms being compared have the same type\" is not always true (since Reduction is called in random places), so we did not add this optimization, but we could during \"kernel type checking\" I believe.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/372025529/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/372025787","html_url":"https://github.com/coq/coq/issues/6957#issuecomment-372025787","issue_url":"https://api.github.com/repos/coq/coq/issues/6957","id":372025787,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MjAyNTc4Nw==","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2018-03-10T12:22:24Z","updated_at":"2018-03-10T12:22:24Z","author_association":"CONTRIBUTOR","body":"Not that I know of.\n\nGaëtan Gilbert\n\nOn 10/03/2018 13:17, Enrico wrote:\n> No we don't, but we discussed a few times about doing it. Does it \n> interact badly with sprop?\n> \n> —\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub \n> <https://github.com/coq/coq/issues/6957#issuecomment-372025529>, or mute \n> the thread \n> <https://github.com/notifications/unsubscribe-auth/ACWQ7DNMmZVCu-csEYaoHYhCauAgaLzqks5tc8RmgaJpZM4Skz-9>.\n> \n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/372025787/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/372085776","html_url":"https://github.com/coq/coq/issues/6957#issuecomment-372085776","issue_url":"https://api.github.com/repos/coq/coq/issues/6957","id":372085776,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MjA4NTc3Ng==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-03-11T03:07:51Z","updated_at":"2018-03-11T03:07:51Z","author_association":"MEMBER","body":"@gares \r\n> These experiments turned out into long debugging sessions (mostly by me) and most of the time it was not a bug, it was just that the algorithm would take unexpected decisions (possibilities the algorithm would not have even considered if it had made a, maybe suboptimal, choice earlier). So maybe this explains why I'm skeptical.\r\n\r\nIt seems like #2229 is possibly an example of such a thing?  In this issue, I'm intending to request a much simpler heuristic: rather than triggering fatal errors in unification, delay the problem.  I agree that there is subtlety in a notion of what constitutes a \"hard\" problem, and I imagine things would get much hairier if we started having heuristics about which problems have unique solutions, etc.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/372085776/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]