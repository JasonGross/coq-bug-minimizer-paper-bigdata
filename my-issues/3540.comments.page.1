[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337522838","html_url":"https://github.com/coq/coq/issues/3540#issuecomment-337522838","issue_url":"https://api.github.com/repos/coq/coq/issues/3540","id":337522838,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMjgzOA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-24T21:06:46Z","updated_at":"2017-10-18T09:28:08Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nMy understanding is that [cut G] should be equivalent to [let H := fresh in assert (H : G); [ | revert H ]; <swap goals>].  Hence [cut G] should not fail when [assert H] succeeds.\n\n(* File reduced by coq-bug-finder from original input, then from 11678 lines to 11330 lines, then from 10721 lines to 9544 lines, then from 9549 lines to 794 lines, then from 810 lines to 785 lines, then from 810 lines to 724 lines, then from 592 lines to 362 lines, then from 327 lines to 255 lines, then from 254 lines to 243 lines *)\n(* coqc version trunk (August 2014) compiled on Aug 22 2014 4:17:28 with OCaml 4.01.0\n   coqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (a67cc6941434124465f20b14a1256f2ede31a60e) *)\n\nSet Implicit Arguments.\nLocal Set Primitive Projections.\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\nNotation \"x * y\" := (prod x y) : type_scope.\nNotation \"( x , y , .. , z )\" := (pair .. (pair x y) .. z) : core_scope.\nDefinition Type1 := Eval hnf in let U := Type in let gt := (Set : U) in U.\nReserved Infix \"o\" (at level 40, left associativity).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where \"x = y\" := (@ paths _ x y) : type_scope.\nArguments idpath {A a} , [A] a.\nDelimit Scope path_scope with path.\nLocal Open Scope path_scope.\nNotation \"1\" := idpath : path_scope.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y := match p with idpath => idpath end.\nInductive Empty : Type1 := .\nDefinition path_prod_uncurried {A B : Type} (z z' : A * B)\n           (pq : (fst z = fst z') * (snd z = snd z'))\n: (z = z')\n  := match fst pq in (_ = z'1), snd pq in (_ = z'2) return z = (z'1, z'2) with\n       | 1, 1 => 1\n     end.\nDefinition path_prod {A B : Type} (z z' : A * B) :\n  (fst z = fst z') -> (snd z = snd z') -> (z = z')\n  := fun p q => path_prod_uncurried z z' (p,q).\nModule Export categories.\n  Module Export Category.\n    Module Export Core.\n\n      Delimit Scope morphism_scope with morphism.\n      Delimit Scope category_scope with category.\n      Delimit Scope object_scope with object.\n\n      Record PreCategory :=\n        Build_PreCategory' {\n            object :> Type;\n            morphism : object -> object -> Type;\n\n            identity : forall x, morphism x x;\n            compose : forall s d d',\n                        morphism d d'\n                        -> morphism s d\n                        -> morphism s d'\n            where \"f 'o' g\" := (compose f g)\n          }.\n\n      Bind Scope category_scope with PreCategory.\n      Arguments identity [!C%category] x%object : rename.\n\n      Definition Build_PreCategory\n                 object morphism compose identity\n\n        := @ Build_PreCategory'\n             object\n             morphism\n             compose\n             identity\n      .\n\n    End Core.\n\n  End Category.\n\nEnd categories.\nModule Export Category.\n  Module Export Sum.\n\n    Section internals.\n      Variable C : PreCategory.\n      Variable D : PreCategory.\n\n      Definition sum_morphism (s d : C + D) : Type\n        := match (s, d) with\n             | (inl s, inl d) => morphism C s d\n             | (inr s, inr d) => morphism D s d\n             | _ => Empty\n           end.\n\n      Definition sum_identity (x : C + D) : sum_morphism x x\n        := match x with\n             | inl x => identity x\n             | inr x => identity x\n           end.\n\n      Definition sum_compose (s d d' : C + D)\n                 (m1 : sum_morphism d d') (m2 : sum_morphism s d)\n      : sum_morphism s d'.\n        admit.\n      Defined.\n    End internals.\n\n    Definition sum (C D : PreCategory) : PreCategory.\n    Proof.\n      refine (@ Build_PreCategory\n                (C + D)%type\n                (sum_morphism C D)\n                (sum_identity C D)\n                (sum_compose C D)\n             ).\n    Defined.\n    Infix \"+\" := sum : category_scope.\n\n    Delimit Scope functor_scope with functor.\n\n    Section Functor.\n      Variable C : PreCategory.\n      Variable D : PreCategory.\n\n      Record Functor :=\n        {\n          object_of :> C -> D;\n          morphism_of : forall s d, morphism C s d\n                                    -> morphism D (object_of s) (object_of d);\n          identity_of : forall x, morphism_of _ _ (identity x)\n                                  = identity (object_of x)\n        }.\n    End Functor.\n    Arguments morphism_of [C%category] [D%category] F%functor [s%object d%object] m%morphism : rename, simpl nomatch.\n\n    Module Export HoTT_DOT_categories_DOT_Functor_DOT_Composition_DOT_Core.\n\n      Section composition.\n        Variable C : PreCategory.\n        Variable D : PreCategory.\n        Variable E : PreCategory.\n        Variable G : Functor D E.\n        Variable F : Functor C D.\n\n        Local Notation c_object_of c := (G (F c)) (only parsing).\n        Local Notation c_morphism_of m := (morphism_of G (morphism_of F m)) (only parsing).\n        Definition compose_identity_of x\n        : c_morphism_of (identity x) = identity (c_object_of x)\n          := transport (@ paths _ _)\n                       (identity_of G _)\n                       (ap (@ morphism_of _ _ G _ _) (identity_of F x)).\n\n        Definition composeF : Functor C E\n          := Build_Functor\n               C E\n               (fun c => G (F c))\n               (fun _ _ m => morphism_of G (morphism_of F m))\n               compose_identity_of.\n      End composition.\n      Infix \"o\" := composeF : functor_scope.\n\n      Local Notation type_inl := inl.\n      Local Notation type_inr := inr.\n\n      Section sum_functors.\n        Variable C : PreCategory.\n        Variable D : PreCategory.\n\n        Definition inl : Functor C (C + D)\n          := Build_Functor C (C + D)\n                           (@ inl _ _)\n                           (fun _ _ m => m)\n                           (fun _ => idpath).\n      End sum_functors.\n\n      Section sum.\n        Variable C : PreCategory.\n        Variable C' : PreCategory.\n        Variable D : PreCategory.\n\n        Definition sum (F : Functor C D) (F' : Functor C' D)\n        : Functor (C + C') D.\n        Proof.\n          refine (Build_Functor\n                    (C + C') D\n                    (fun cc'\n                     => match cc' with\n                          | type_inl c => F c\n                          | type_inr c' => F' c'\n                        end)\n                    (fun s d\n                     => match s, d with\n                          | type_inl cs, type_inl cd\n                            => morphism_of F (s := cs) (d := cd)\n                          | type_inr c's, type_inr c'd\n                            => morphism_of F' (s := c's) (d := c'd)\n                          | _, _ => fun m => match m with end\n                        end)\n                    _); admit.\n        Defined.\n      End sum.\n\n      Goal    forall (D C1 C2 : PreCategory) (fst1 : Functor C1 D)\n                     (snd1 : Functor C2 D) (fst0 : Functor C1 D) (snd0 : Functor C2 D)\n                     (x2 : object C1)\n                     (p0 : @ paths (Functor C1 D)\n                                  (@ composeF C1 (Category.Sum.sum C1 C2) D\n                                             ((@ sum C1 C2 D fst0 snd0))\n                                             (inl C1 C2)) fst0)\n                     (p2 : @ paths (Functor C1 D)\n                                  (@ composeF C1 (Category.Sum.sum C1 C2) D\n                                             ((@ sum C1 C2 D fst1 snd1))\n                                             (inl C1 C2)) fst1) (f : Functor C2 D)\n                     (p : @ paths (Functor C2 D) f snd0) (f0 : Functor C2 D)\n                     (p1 : @ paths (Functor C2 D) f0 snd1)\n                     (m : morphism D (@ object_of C1 D fst1 x2) (@ object_of C1 D fst0 x2)),\n                @ paths (morphism D (@ object_of C1 D fst1 x2) (@ object_of C1 D fst0 x2))\n                       (@ transport (prod (Functor C1 D) (Functor C2 D))\n                                   (fun x : prod (Functor C1 D) (Functor C2 D) =>\n                                      morphism D (@ object_of C1 D fst1 x2) (@ object_of C1 D (fst x) x2))\n                                   (@ pair (Functor C1 D) (Functor C2 D)\n                                          (@ composeF C1 (Category.Sum.sum C1 C2) D\n                                                     ((@ sum C1 C2 D fst0 snd0))\n                                                     (inl C1 C2)) f) (@ pair (Functor C1 D) (Functor C2 D) fst0 snd0)\n                                   (@ path_prod (Functor C1 D) (Functor C2 D)\n                                               (@ pair (Functor C1 D) (Functor C2 D)\n                                                      (@ composeF C1 (Category.Sum.sum C1 C2) D\n                                                                 ((@ sum C1 C2 D fst0 snd0))\n                                                                 (inl C1 C2)) f)\n                                               (@ pair (Functor C1 D) (Functor C2 D) fst0 snd0) p0 p)\n                                   (@ transport (prod (Functor C1 D) (Functor C2 D))\n                                               (fun x : prod (Functor C1 D) (Functor C2 D) =>\n                                                  morphism D (@ object_of C1 D (fst x) x2) (@ object_of C1 D fst0 x2))\n                                               (@ pair (Functor C1 D) (Functor C2 D)\n                                                      (@ composeF C1 (Category.Sum.sum C1 C2) D\n                                                                 ((@ sum C1 C2 D fst1 snd1))\n                                                                 (inl C1 C2)) f0)\n                                               (@ pair (Functor C1 D) (Functor C2 D) fst1 snd1)\n                                               (@ path_prod (Functor C1 D) (Functor C2 D)\n                                                           (@ pair (Functor C1 D) (Functor C2 D)\n                                                                  (@ composeF C1 (Category.Sum.sum C1 C2) D\n                                                                             ((@ sum C1 C2 D fst1 snd1))\n                                                                             (inl C1 C2)) f0)\n                                                           (@ pair (Functor C1 D) (Functor C2 D) fst1 snd1) p2 p1) m)) m.\n        intros.\n        match goal with\n          | |- context G[(sum ?fst1 ?snd1 o inl ?C1 ?C2)%functor]\n            => let G' := context G[fst1] in\n               assert G'\n        end.\n        Undo.\n        match goal with\n          | |- context G[(sum ?fst1 ?snd1 o inl ?C1 ?C2)%functor]\n            => let G' := context G[fst1] in\n               cut G'\n        end.\n(* Toplevel input, characters 197-204:\nIn nested Ltac calls to \"cut\", last call failed.\nError: Not a proposition or a type. *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337522838/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337522840","html_url":"https://github.com/coq/coq/issues/3540#issuecomment-337522840","issue_url":"https://api.github.com/repos/coq/coq/issues/3540","id":337522840,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMjg0MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-08-25T11:59:21Z","updated_at":"2017-10-18T09:28:09Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nI think this is due to the fact that [assert] and [cut] do not use the same interpretation function for terms. Indeed, the [G] you recover is not really a constr, but a context. There must be a missing cast somewhere.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337522840/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337522841","html_url":"https://github.com/coq/coq/issues/3540#issuecomment-337522841","issue_url":"https://api.github.com/repos/coq/coq/issues/3540","id":337522841,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMjg0MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-09-07T10:48:53Z","updated_at":"2017-10-18T09:28:09Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nNow both versions fail on trunk with a type error before evaluating the tactic. The context operation was indeed producing an ill-typed term.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337522841/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]