[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337536118","html_url":"https://github.com/coq/coq/issues/4320#issuecomment-337536118","issue_url":"https://api.github.com/repos/coq/coq/issues/4320","id":337536118,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzNjExOA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-08-14T07:30:32Z","updated_at":"2017-10-18T10:06:15Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nHere is code that works fine in Coq 8.4, and does not work in Coq 8.5:\n\nSet Implicit Arguments.\nSet Asymmetric Patterns.\nRequire Coq.Vectors.Vector.\n\nSection ilist.\n\n  (* Lists of elements whose types depend on an indexing set (CPDT's hlists).\n     These lists are a convenient way to implement finite maps\n     whose elements depend on their keys. The data structures used\n     by our ADT notations uses these to implement notation-friendly\n     method lookups.  *)\n\n  Import Coq.Vectors.VectorDef.VectorNotations.\n\n  Context {A : Type}. (* The indexing type. *)\n  Context {B : A -> Type}. (* The type of indexed elements. *)\n\n  Fixpoint ilist {n} (l : Vector.t A n) : Type :=\n    match l with\n      | [] => unit\n      | a :: l => @ prod (B a) (ilist l)\n    end.\n\n  Definition icons\n             (a : A)\n             {n}\n             {l : Vector.t A n}\n             (b : B a)\n             (il : ilist l)\n  : ilist (a :: l)\n    := pair b il.\n\n  Axiom ilist_hd : forall {n} {As : Vector.t A n} (il : ilist As),\n    match As return ilist As -> Type with\n      | a :: As' => fun il => B a\n      | [] => fun _ => unit\n    end il.\n\n  Axiom ilist_tl : forall {n} {As : Vector.t A n} (il : ilist As),\n    match As return ilist As -> Type with\n      | a :: As' => fun il => ilist As'\n      | [] => fun _ => unit\n    end il.\n\n  Definition ith_body\n             (ith : forall\n                      {m : nat}\n                      {As : Vector.t A m}\n                      (il : ilist As)\n                      (n : Fin.t m),\n                      B (Vector.nth As n))\n             {m : nat}\n             {As : Vector.t A m}\n             (il : ilist As)\n             (n : Fin.t m)\n  : B (Vector.nth As n)\n    := Eval cbv beta iota zeta delta [Vector.caseS] in\n        match n in Fin.t m return\n              forall (As : Vector.t A m),\n                ilist As\n                -> B (Vector.nth As n) with\n          | Fin.F1 k =>\n            fun As =>\n              Vector.caseS (fun n As => ilist As\n                                        -> B (Vector.nth As (@ Fin.F1 n)))\n                           (fun h n t => ilist_hd) As\n          | Fin.FS k n' =>\n            fun As =>\n              Vector.caseS (fun n As => forall n',\n                                          ilist As\n                                          -> B (Vector.nth As (@ Fin.FS n n')))\n                           (fun h n t m il => @ ith _ _ (ilist_tl il) m)\n                           As n'\n        end As il.\n\n  Fixpoint ith\n           {m : nat}\n           {As : Vector.t A m}\n           (il : ilist As)\n           (n : Fin.t m)\n           {struct n}\n    : B (Vector.nth As n) :=\n    @ ith_body (@ ith) m As il n.\n\nI'm going to tentatively assign this to Maxime, though I'm not sure if that's right.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337536118/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337536119","html_url":"https://github.com/coq/coq/issues/4320#issuecomment-337536119","issue_url":"https://api.github.com/repos/coq/coq/issues/4320","id":337536119,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzNjExOQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-05-09T16:18:47Z","updated_at":"2017-10-18T10:06:15Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nMaxime, any comment on that one?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337536119/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337536121","html_url":"https://github.com/coq/coq/issues/4320#issuecomment-337536121","issue_url":"https://api.github.com/repos/coq/coq/issues/4320","id":337536121,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzNjEyMQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-05-23T11:32:55Z","updated_at":"2017-10-18T10:06:16Z","author_association":"CONTRIBUTOR","body":"Comment author: @maximedenes\n\nYes, this is an instance of the stricter guard condition of 8.5. The problem is that Vector.caseS uses a commutative cut with a pattern matching in the return predicate which has itselft a dependent return predicate (!).\n\nIn most cases I've seen so far (including the standard library), caseS is anyway overkill because it generalizes both the vector and the size in the predicate P, when generalizing the vector only is often enough. When this is the case, one should use the new caseS' combinator in Vector.\n\nIn this example, ith_body can be rewritten:\n\n  Definition ith_body\n             (ith : forall\n                      {m : nat}\n                      {As : Vector.t A m}\n                      (il : ilist As)\n                      (n : Fin.t m),\n                      B (Vector.nth As n))\n             {m : nat}\n             {As : Vector.t A m}\n             (il : ilist As)\n             (n : Fin.t m)\n  : B (Vector.nth As n)\n    := Eval cbv beta iota zeta delta [Vector.caseS] in\n        match n in Fin.t m return\n              forall (As : Vector.t A m),\n                ilist As\n                -> B (Vector.nth As n) with\n          | Fin.F1 k =>\n            fun As =>\n              Vector.caseS' As (fun As => ilist As\n                                        -> B (Vector.nth As (@ Fin.F1 k)))\n                               (fun h t => ilist_hd)\n          | Fin.FS k n' =>\n            fun As =>\n              Vector.caseS' As (fun As => ilist As -> B (Vector.nth As (@ Fin.FS k n')))\n                               (fun h t il => @ ith _ _ (ilist_tl il) n')\n        end As il.\n\nThis new definition makes the guard checker happy. Please double check I haven't introduced any error, though :)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337536121/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]