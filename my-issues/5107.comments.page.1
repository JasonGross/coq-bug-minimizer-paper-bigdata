[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547641","html_url":"https://github.com/coq/coq/issues/5107#issuecomment-337547641","issue_url":"https://api.github.com/repos/coq/coq/issues/5107","id":337547641,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NzY0MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-09-29T00:23:46Z","updated_at":"2018-05-13T20:01:30Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n```coq\r\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-R\" \"src\" \"Crypto\" \"-top\" \r\n\"DoubleBounded\") -*- *)\r\n(* File reduced by coq-bug-finder from original input, then from 165 lines to \r\n24 lines, then from 121 lines to 28 lines, then from 146 lines to 29 lines, \r\nthen from 326 lines to 30 lines, then from 44 lines to 30 lines *)\r\n(* coqc version 8.6.0 (September 2016) compiled on Sep 27 2016 19:1:59 with \r\nOCaml 4.02.3\r\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,v8.6 \r\n(72c1fefcfb3f0dff02005034685f6b58ff84b3cc) *)\r\n\r\nFixpoint tuple' T n : Type :=\r\n  match n with\r\n  | O => T\r\n  | S n' => (tuple' T n' * T)%type\r\n  end.\r\n\r\nReserved Notation \"'dlet' x := y 'in' f\"\r\n         (at level 200, f at level 200, format \"'dlet'  x  :=  y  'in' '//' f\").\r\n\r\nDefinition Let_In {A P} (x : A) (f : forall a : A, P a) : P x := let y := x in \r\nf y.\r\nNotation \"'dlet' x := y 'in' f\" := (Let_In y (fun x => f)).\r\nLocal Notation eta x := (fst x, snd x).\r\n\r\nFixpoint ripple_carry_tuple' {T} (f : T -> T -> bool -> bool * T) k\r\n  : forall (xs ys : tuple' T k) (carry : bool), bool * tuple' T k\r\n  := match k return forall (xs ys : tuple' T k) (carry : bool), bool * tuple' T \r\nk with\r\n     | O => f\r\n     | S k' => fun xss yss carry => dlet xss := xss in\r\n                                dlet yss := yss in\r\n                                let '(xs, x) := eta xss in\r\n                                let '(ys, y) := eta yss in\r\n                                dlet addv := (@ ripple_carry_tuple' _ f k' xs ys \r\ncarry) in\r\n                                let '(carry, zs) := eta addv in\r\n                                dlet fxy := (f x y carry) in\r\n                                let '(carry, z) := eta fxy in\r\n                                (carry, (zs, z))\r\n     end. (* Error:\r\nIn environment\r\nripple_carry_tuple' : forall T : Type,\r\n                      (T -> T -> bool -> bool * T) ->\r\n                      forall k : nat, tuple' T k -> tuple' T k -> bool -> bool \r\n* tuple' T k\r\nT : Type\r\nf : T -> T -> bool -> bool * T\r\nk : nat\r\nk' : nat\r\nxss : tuple' T (S k')\r\nyss : tuple' T (S k')\r\ncarry : bool\r\nxss0 : tuple' T (S k')\r\nyss0 : tuple' T (S k')\r\nxs :\r\n(fix tuple' (T : Type) (n : nat) {struct n} : Type :=\r\n   match n with\r\n   | 0 => T\r\n   | S n' => (tuple' T n' * T)%type\r\n   end) T k'\r\nx : T\r\nys :\r\n(fix tuple' (T : Type) (n : nat) {struct n} : Type :=\r\n   match n with\r\n   | 0 => T\r\n   | S n' => (tuple' T n' * T)%type\r\n   end) T k'\r\ny : T\r\naddv : bool * tuple' T k'\r\ncarry0 : bool\r\nzs : tuple' T k'\r\nThe term\r\n \"dlet fxy := f x y carry0 in\r\n let\r\n '(carry, z) as x0 := eta fxy\r\n  return\r\n    (?T@ {xss0:=xss; yss0:=yss; carry0:=carry; xss:=xss0; yss:=yss0; \r\ncarry:=carry0; p0:=x0} fxy)\r\n  in (carry, (zs, z))\" has type\r\n \"?P2@ {xss0:=xss; yss0:=yss; carry0:=carry; xss:=xss0; yss:=yss0; \r\ncarry:=carry0} (f x y carry0)\"\r\nwhile it is expected to have type \"?P1@ {xss0:=xss; yss0:=yss; xss:=xss0; \r\nyss:=yss0} addv\".\r\n *)\r\n```\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547641/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547643","html_url":"https://github.com/coq/coq/issues/5107#issuecomment-337547643","issue_url":"https://api.github.com/repos/coq/coq/issues/5107","id":337547643,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NzY0Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-10-03T19:58:46Z","updated_at":"2018-05-13T20:01:47Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nHere's a slightly shorter example:\r\n```coq\r\nReserved Notation \"'dlet' x := y 'in' f\"\r\n         (at level 200, f at level 200, format \"'dlet'  x  :=  y  'in' '//' f\").\r\nDefinition Let_In {A P} (x : A) (f : forall a : A, P a) : P x := let y := x in  \r\nf y.\r\nNotation \"'dlet' x := y 'in' f\" := (Let_In y (fun x => f)).\r\nCheck (fun T (xss yss : T * T) =>\r\n         ((dlet xss := xss in\r\n           dlet yss := yss in\r\n           let '(xs, x) := (xss : T * T) in\r\n           ((x, x) : T * T))\r\n          : T * T)).\r\n(* Error:\r\nIn environment\r\nT : Type\r\nxss : T * T\r\nyss : T * T\r\nxss0 : T * T\r\nThe term\r\n \"dlet yss0 := yss in\r\n let\r\n '(_, x) as x := xss0 : T * T return (?T@ {xss0:=xss; yss0:=yss; xss:=xss0; \r\nx0:=x} yss0) in\r\n  (x, x) : T * T\" has type \"?T@ {xss0:=xss; yss0:=yss; xss:=xss0; x0:=xss0} yss\"\r\nwhile it is expected to have type \"?P xss0\".\r\n *)\r\n```\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547643/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547645","html_url":"https://github.com/coq/coq/issues/5107#issuecomment-337547645","issue_url":"https://api.github.com/repos/coq/coq/issues/5107","id":337547645,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NzY0NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-10-03T20:11:22Z","updated_at":"2018-05-13T20:02:23Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nRunning my coq-bisect script on the following file:\r\n```coq\r\n(* -*- coq-prog-args: (\"-emacs\" \"-boot\" \"-nois\") -*- *)\r\nReserved Notation \"'dlet' x := y 'in' f\"\r\n         (at level 200, f at level 200, format \"'dlet'  x  :=  y  'in' '//' f\").\r\nDefinition Let_In {A P} (x : A) (f : forall a : A, P a) : P x := let y := x in  \r\nf y.\r\nNotation \"'dlet' x := y 'in' f\" := (Let_In y (fun x => f)).\r\nRecord prod A B := pair { fst : A ; snd : B }.\r\nSet Asymmetric Patterns.\r\nCheck (fun T (xss yss : prod T T) =>\r\n         ((dlet xss := xss in\r\n           dlet yss := yss in\r\n           let '(pair xs x) := (xss : prod T T) in\r\n           ((@ pair _ _ x x) : prod T T))\r\n          : prod T T)).\r\n```\r\n\r\nI get:\r\n\r\n980b434552d73cb990860f8d659b64686f6dbc87 is the first bad commit\r\ncommit 980b434552d73cb990860f8d659b64686f6dbc87\r\nAuthor: Hugo Herbelin <Hugo.Herbelin@ inria.fr>\r\nDate:   Thu Aug 18 13:24:50 2016 +0200\r\n\r\n    Inference of return clause: giving uniformly priority to \"small inversion\".\r\n    \r\n    As noted by Jason Gross on coq-club (Aug 18, 2016), the \"small\r\n    inversion\" heuristic is not used consistently depending on whether the\r\n    variables in the type constraint are Rel or Var.\r\n    \r\n    This commit simply gives uniformly preference to the inversion of the\r\n    predicate along the indices of the type over other heuristics.\r\n    \r\n    The next three commits will improve further a uniform use of the\r\n    different heuristics.\r\n    \r\n    ----------------------------------------------------------------------\r\n    Here are some extra comments on how to go further with the inference\r\n    of the return predicate:\r\n    \r\n    The \"small inversion\" heuristic build_inversion_problem (1) is\r\n    characterized by two features:\r\n    \r\n    - small inversion properly speaking (a), i.e. that is for a match on\r\n      t:I params p1(u11..u1p1) ... pn(un1..unpn) with pi exposing the\r\n      constructor structure of the indices of the type of t, a return\r\n      clause of the form \"fun x1..xn (y:I params x1..xn) => match x1..xn y with\r\n      | p1(z11..z1p1) ... pn(zn1..znpn) => ?T@ {z11..znpn}\r\n      | _ => IDProp\r\n      end\" is used,\r\n    \r\n    - the dependent subterms in the external type constraint U are replaced\r\n      by existential variables (b) which can be filled either by projecting\r\n      (i.e. installing a dependency) or imitating (i.e. no dependency);\r\n      this is obtained by solving the constraint ?T@ {u11..unpn} == U by\r\n      setting ?T@ {z11..znpn} := U'(...?wij@ {zij:=uij}...) where U has been\r\n      written under the form U'(...uij...) highlighting all occurrences of\r\n      each of the uij occurring in U; otherwise said the problem is reduced to\r\n      the question of instantiating each wij, deciding whether wij@ {zij} := zij\r\n      (projection) or wij@ {zij} := uij (imitation) [There may be different\r\n      way to expose the uij in U, e.g. in the presence of overlapping, or of\r\n      evars in U; this is left undetermined].\r\n    \r\n    The two other heuristics used are:\r\n    \r\n    - prepare_predicate_from_arsign_tycon (2): takes the external type\r\n      constraint U and decides that each subterm of the form xi or y for a\r\n      match on \"y:I params x1 ... xn\" is dependent; otherwise said, it\r\n      corresponds to the degenerated form of (1) where\r\n      - no constructor structure is exposed (i.e. each pi is trivial)\r\n      - only uij that are Rel are replaced by an evar ?wij and this evar is\r\n        directly instantiated by projection (hence creating a dependency),\r\n    \r\n    - simple use of of an evar in case no type constraint is given (3):\r\n      this evar is not dependent on the indices nor on the term to match.\r\n    \r\n    Heuristic (1) is not strictly more powerful than other heuristics\r\n    because of (at least) two weaknesses.\r\n    \r\n    - The first weakness is due to feature (b), i.e. to letting\r\n      unification decide whether these evars have to create a dependency\r\n      (projection) or not (imitation).\r\n    \r\n      In particular, the heuristic (2) gives priority to systematic\r\n      abstraction over the dependencies (i.e. giving priority to\r\n      projection over imitation) and it can then be better as the\r\n      following example (from RelationClasses.v) shows:\r\n    \r\n      Fixpoint arrows (l : Tlist) (r : Type) : Type :=\r\n        match l with\r\n        | Tnil => r\r\n        | A :: l' => A -> arrows l' r\r\n        end.\r\n    \r\n      Fixpoint predicate_all (l : Tlist) : arrows l Prop -> Prop :=\r\n        match l with\r\n        | Tnil => fun f => f\r\n        | A :: tl => fun f => forall x : A, predicate_all tl (f x)\r\n        end.\r\n    \r\n      Using (1) fails. It proposes the predicate\r\n      \"fun l' => arrows ?l[l':=l'] Prop\" so that typing the first branch\r\n      leads to unify \"arrows ?l[l:=Tnil] Prop == Prop\", a problem about\r\n      which evarconv unification is not able (yet!) to see what are the\r\n      two possible solutions. Using (2) works. It instead directly\r\n      suggests that the predicate is \"fun l => arrows l Prop\" is used, so\r\n      that unification is not needed.\r\n    \r\n      Even if in practice the (2) is good (and hence could be added to\r\n      (1)), it is not universally better. Consider e.g.\r\n    \r\n         y:bool,H1:P y,H2:P y,f:forall y, P y -> Q y |-\r\n                  match y as z return Q y with\r\n                  | true  => f y H1\r\n                  | false => f y H2\r\n                  end : Q y\r\n    \r\n      There is no way to type it with clause \"as z return Q z\" even if\r\n      trying to generalize H1 and H2 so that they get type P z.\r\n    \r\n    - A second weakness is due to the interaction between small inversion\r\n      and constructors having a type whose indices havex a less refined\r\n      constructor structure than in the term to match, as in:\r\n    \r\n      Inductive I : nat -> Set :=\r\n      | C1 : forall n : nat, listn n -> I n\r\n      | C2 : forall n : nat, I n -> I n.\r\n    \r\n      Check (fun x : I 0 => match x with\r\n                            | C1 n l => 0\r\n                            | C2 n c => 0\r\n                            end).\r\n    \r\n      where the inverted predicate is \"in I n return match n with 0 => ?T | _ \r\n=> IDProp end\"\r\n      but neither C1 nor C2 have fine enough types so that n becomes\r\n      constructed. There is a generic solution to that kind of situation which\r\n      is to compile the above into\r\n    \r\n      Check (fun x : I 0 => match x with\r\n                            | C1 n l => match n with 0 => 0 | _ -> id end\r\n                            | C2 n c => match n with 0 => 0 | _ -> id end\r\n                            end).\r\n    \r\n      but this is not implemented yet.\r\n    \r\n      In the absence of this refinement, heuristic (3) can here work\r\n      better.\r\n    \r\n    So, the current status of the claim is that for (1) to be strictly\r\n    more powerful than other current heuristics, work has to be done\r\n    \r\n    - (A) at the unification level (by either being able to reduce problems of\r\n      the form \"match ?x[constructor] with ... end = a-rigid-term\", or, at\r\n      worst, by being able to use the heuristic favoring projecting for such\r\n      a problem), so that it is better than (2),\r\n    \r\n    - (B) at the match compilation level, by enforcing that, in each branch,\r\n      the corresponding constructor is refined so has to match (or\r\n      discriminate) the constraints given by the type of the term to\r\n      match, and hence being better than (3).\r\n    \r\n    Moreover, (2) and (3) are disjoint. Here is an example which (3) can\r\n    solve but not (2) (and (1) cannot because of (B)). [To be fixed in\r\n    next commit.]\r\n    \r\n    Inductive I : bool -> bool -> Type := C : I true true | D x : I x x.\r\n    \r\n    Check fun z P Q (y:I true z) (H1 H2:P y) (f:forall y, P y -> Q y z) =>\r\n                  match y with\r\n                  | C  => f y H1\r\n                  | D _ => f y H2\r\n                  end : Q y z.\r\n    \r\n    Indeed, (2) infers \"as y' in I b z return Q y z\" which does not work.\r\n    \r\n    Here is an example which (2) can solve but not (3) (and (1) cannot\r\n    because of (B) again). [To be fixed in 2nd next commit].\r\n    \r\n    Check fun z P Q (y:I true z) (H1 H2:P y) (f:forall y z, P y -> Q y z) =>\r\n                  match y with\r\n                  | C  => f y true H1\r\n                  | D b => f y b H2\r\n                  end : Q y z.\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547645/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547647","html_url":"https://github.com/coq/coq/issues/5107#issuecomment-337547647","issue_url":"https://api.github.com/repos/coq/coq/issues/5107","id":337547647,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NzY0Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-10-03T20:12:13Z","updated_at":"2017-10-18T10:42:34Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI'm a bit surprised, given that the descriptions of the subsequent commits \nsuggests that all three strategies are used for return clause inference...\n\nHugo, any feedback on this?\n\ncommit 0658ba7b908dad946200f872f44260d0e4893a94\nAuthor: Hugo Herbelin <Hugo.Herbelin@ inria.fr>\nDate:   Sat Aug 20 17:29:26 2016 +0200\n\n    Posssible abstractions over goal variables when inferring match return \nclause.\n    \n    The no-inversion and maximal abstraction over dependencies now\n    supports abstraction over goal variables rather than only on \"rel\"\n    variables. In particular, it now works consistently using\n    \"intro H; refine (match H with ... end)\" or\n    \"refine (fun H => match H with ... end)\".\n    \n    By doing so, we ensure that all three strategies are tried in all\n    situations where a return clause has to be inferred, even in the\n    context of a \"refine\".\n    \n    See antepenultimate commit for discussion.\n\ncommit 292f365185b7acdee79f3ff7b158551c2764c548\nAuthor: Hugo Herbelin <Hugo.Herbelin@ inria.fr>\nDate:   Sat Aug 20 17:13:58 2016 +0200\n\n    Trying an abstracting dependencies heuristic for the match return clause \neven when no type constraint is given.\n    \n    This no-inversion and maximal abstraction over dependencies in (rel)\n    variables heuristic was used only when a type constraint was given.\n    \n    By doing so, we ensure that all three strategies \"inversion with\n    dependencies as evars\", \"no-inversion and maximal abstraction over\n    dependencies in (rel) variables\", \"no-inversion and no abstraction\n    over dependencies\" are tried in all situations where a return clause\n    has to be inferred.\n    \n    See penultimate commit for discussion.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547647/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547652","html_url":"https://github.com/coq/coq/issues/5107#issuecomment-337547652","issue_url":"https://api.github.com/repos/coq/coq/issues/5107","id":337547652,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NzY1Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-10-04T16:30:30Z","updated_at":"2018-05-13T20:04:04Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\r\n\r\nWhat happens is that the indicated commit gives priority to a dependent return clause for the `let '(xs, x) := (xss : T * T) in ...` pattern-matching, while before a non-dependent return clause was tried first.\r\n\r\nBecause of the dependency, the unification problem `?P xss0 = ?T@ {xss0:=xss; yss0:=yss; xss:=xss0; x0:=xss0} yss` is not anymore a single-solution problem and we enter the class of problems where unification is not strong enough to deal with the generality of the \"small inversion\" algorithm.\r\n\r\nThe cast should have helped but did not: it leads to a unification problem of the form\r\n\r\n  `prod T T = ?U@ {p:=(y,z),T:=T} x`\r\n\r\nwhich the naive algorithm used for flex-rigid problems is only able to postpone. There is a smarter pattern-unification algorithm with pruning used in evar-evar problems which would solve it, but it would take some time to experiment using it for flex-rigid problems (in particular I'm unsure to be able to finely control its complexity wrt the number of hypotheses and the number of let-ins in the context).\r\n\r\nSo, in the short term, I would suggest to revert the \"return clause\" commit, since there were already discussions about its timeliness for v8.6.\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547652/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547653","html_url":"https://github.com/coq/coq/issues/5107#issuecomment-337547653","issue_url":"https://api.github.com/repos/coq/coq/issues/5107","id":337547653,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NzY1Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-10-04T16:47:03Z","updated_at":"2017-10-18T10:42:35Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI would agree: I'm in favor of adding this to the test suite, reverting the change in unification, and then planning for the unification change to be in 8.7, and finding a way to make it handle this example.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547653/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547655","html_url":"https://github.com/coq/coq/issues/5107#issuecomment-337547655","issue_url":"https://api.github.com/repos/coq/coq/issues/5107","id":337547655,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NzY1NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-10-11T10:04:29Z","updated_at":"2017-10-18T10:42:35Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nIt seems we all agree on removing that commit. Hopefully we can still salvage \nthe cleanup ones still?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547655/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547656","html_url":"https://github.com/coq/coq/issues/5107#issuecomment-337547656","issue_url":"https://api.github.com/repos/coq/coq/issues/5107","id":337547656,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NzY1Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-10-11T10:47:45Z","updated_at":"2017-10-18T10:42:36Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nRemoved from 8.6. Rescheduled for next 8.x.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337547656/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/388652746","html_url":"https://github.com/coq/coq/issues/5107#issuecomment-388652746","issue_url":"https://api.github.com/repos/coq/coq/issues/5107","id":388652746,"node_id":"MDEyOklzc3VlQ29tbWVudDM4ODY1Mjc0Ng==","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2018-05-13T20:11:57Z","updated_at":"2018-05-13T20:11:57Z","author_association":"MEMBER","body":"A cast on the `let '` helps though. The following (expanded) example, works:\r\n```coq\r\nAxiom Let_In : forall P (x : bool) (f : forall a : bool, P a), P x.\r\nCheck fun T xss yss =>\r\n         Let_In ?[P] true (fun y => \r\n         Let_In ?[Q] true (fun y => \r\n         let '(pair xs x) := xss return _ in\r\n         (xs,x))).\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/388652746/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]