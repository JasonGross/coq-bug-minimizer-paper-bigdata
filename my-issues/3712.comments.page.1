[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525616","html_url":"https://github.com/coq/coq/issues/3712#issuecomment-337525616","issue_url":"https://api.github.com/repos/coq/coq/issues/3712","id":337525616,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTYxNg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-10T03:26:28Z","updated_at":"2017-10-18T09:35:51Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n(* File reduced by coq-bug-finder from original input, then from 13477 lines to 1457 lines, then from 1553 lines to 1586 lines, then from 1577 lines to 1520 lines, then from 1533 lines to 879 lines, then from 883 lines to 580 lines, then from 567 lines to 398 lines, then from 392 lines to 377 lines, then from 389 lines to 377 lines, then from 378 lines to 363 lines *)\n(* coqc version trunk (October 2014) compiled on Oct 8 2014 13:38:17 with OCaml 4.01.0\n   coqtop version cagnode16:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (335cf2860bfd9e714d14228d75a52fd2c88db386) *)\n\nSet Universe Polymorphism.\nSet Primitive Projections.\nSet Implicit Arguments.\nRecord sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\nNotation \"{ x : A & P }\" := (sigT (fun x:A => P)) : type_scope.\nDefinition relation (A : Type) := A -> A -> Type.\nClass Reflexive {A} (R : relation A) := reflexivity : forall x : A, R x x.\nClass Symmetric {A} (R : relation A) := symmetry : forall x y, R x y -> R y x.\nNotation idmap := (fun x => x).\nNotation \"x .1\" := (projT1 x) (at level 3, format \"x '.1'\").\nReserved Infix \"o\" (at level 40, left associativity).\nGlobal Instance symmetric_paths {A} : Symmetric (@ eq A) | 0.\nadmit.\nDefined.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y.\n  destruct p; exact u.\nDefined.\nAxiom ap : forall {A B:Type} (f:A -> B) {x y:A} (p:x = y), f x = f y.\nMonomorphic Axiom dummy_funext_type : Set.\nMonomorphic Class Funext := { dummy_funext_value : dummy_funext_type }.\nDelimit Scope morphism_scope with morphism.\nDelimit Scope category_scope with category.\nDelimit Scope object_scope with object.\nRecord PreCategory :=\n  Build_PreCategory' {\n      object :> Type;\n      morphism : object -> object -> Type;\n\n      identity : forall x, morphism x x;\n      compose : forall s d d',\n                  morphism d d'\n                  -> morphism s d\n                  -> morphism s d'\n      where \"f 'o' g\" := (compose f g);\n\n      associativity : forall x1 x2 x3 x4\n                             (m1 : morphism x1 x2)\n                             (m2 : morphism x2 x3)\n                             (m3 : morphism x3 x4),\n                        (m3 o m2) o m1 = m3 o (m2 o m1);\n\n      associativity_sym : forall x1 x2 x3 x4\n                                 (m1 : morphism x1 x2)\n                                 (m2 : morphism x2 x3)\n                                 (m3 : morphism x3 x4),\n                            m3 o (m2 o m1) = (m3 o m2) o m1;\n\n      left_identity : forall a b (f : morphism a b), identity b o f = f;\n      right_identity : forall a b (f : morphism a b), f o identity a = f\n    }.\nBind Scope morphism_scope with morphism.\nArguments identity {!C%category} / x%object : rename.\n\nDefinition Build_PreCategory\n           object morphism compose identity\n           associativity left_identity right_identity\n  := @ Build_PreCategory'\n       object\n       morphism\n       compose\n       identity\n       associativity\n       (fun _ _ _ _ _ _ _ => symmetry _ _ (associativity _ _ _ _ _ _ _))\n       left_identity\n       right_identity.\nInfix \"o\" := (@ compose _ _ _ _) : morphism_scope.\nDelimit Scope functor_scope with functor.\n\nLocal Open Scope morphism_scope.\n\nSection Functor.\n\n  Record Functor (C D : PreCategory) :=\n    {\n      object_of :> C -> D;\n      morphism_of : forall s d, morphism C s d\n                                -> morphism D (object_of s) (object_of d);\n      composition_of : forall s d d'\n                              (m1 : morphism C s d) (m2: morphism C d d'),\n                         morphism_of _ _ (m2 o m1)\n                         = (morphism_of _ _ m2) o (morphism_of _ _ m1);\n      identity_of : forall x, morphism_of _ _ (identity x)\n                              = identity (object_of x)\n    }.\nEnd Functor.\n\nBind Scope functor_scope with Functor.\nArguments morphism_of [C%category] [D%category] F%functor [s%object d%object] m%morphism : rename, simpl nomatch.\nNotation \"F '_1' m\" := (morphism_of F m) (at level 10, no associativity) : morphism_scope.\n\nLocal Open Scope category_scope.\n\nClass Isomorphic {C : PreCategory} s d := { morphism_isomorphic :> morphism C s d }.\nCoercion morphism_isomorphic : Isomorphic >-> morphism.\nLocal Infix \"<~=~>\" := Isomorphic (at level 70, no associativity) : category_scope.\nSection iso_equiv_relation.\n  Variable C : PreCategory.\n  Global Instance isomorphic_refl : Reflexive (@ Isomorphic C).\n  exact (fun x : C => {| morphism_isomorphic := identity x |}).\n  Defined.\n  Definition idtoiso (x y : C) (H : x = y) : Isomorphic x y.\n    admit.\n  Defined.\nEnd iso_equiv_relation.\n\nSection composition.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n  Variable E : PreCategory.\n  Variable G : Functor D E.\n  Variable F : Functor C D.\n  Definition composeF : Functor C E.\n    exact (Build_Functor\n             C E\n             (fun c => G (F c))\n             (fun _ _ m => morphism_of G (morphism_of F m))\n             $(admit)$\n             $(admit)$).\n  Defined.\nEnd composition.\nInfix \"o\" := composeF : functor_scope.\n\nSection identity.\n  Definition identityF C : Functor C C.\n    admit.\n  Defined.\nEnd identity.\n\n\nSection composition_lemmas.\n\n  Variable B : PreCategory.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n  Variable E : PreCategory.\n\n  Local Open Scope functor_scope.\n\n  Lemma associativityF\n        (F : Functor B C) (G : Functor C D) (H : Functor D E)\n  : (H o G) o F = H o (G o F).\n    admit.\n  Defined.\nEnd composition_lemmas.\n\nLocal Open Scope functor_scope.\nDefinition sub_pre_cat `{fs : Funext} {P : PreCategory -> Type} : PreCategory.\n  exact (@ Build_PreCategory\n           { C : PreCategory & P C }\n           (fun C D => Functor C.1 D.1)\n           (fun C => identityF C.1)\n           (fun _ _ _ F G => F o G)\n           (fun _ _ _ _ _ _ _ => @ associativityF _ _ _ _ _ _ _)\n           $(admit)$\n           $(admit)$).\nDefined.\n\nLocal Open Scope morphism_scope.\n\nSection NaturalTransformation.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n  Variables F G : Functor C D.\n\n  Record NaturalTransformation :=\n    Build_NaturalTransformation' {\n        components_of :> forall c, morphism D (F c) (G c);\n        commutes : forall s d (m : morphism C s d),\n                     components_of d o F _1 m = G _1 m o components_of s;\n\n        commutes_sym : forall s d (m : C.(morphism) s d),\n                         G _1 m o components_of s = components_of d o F _1 m\n      }.\n\n  Definition Build_NaturalTransformation CO COM\n    := Build_NaturalTransformation'\n         CO\n         COM\n         (fun _ _ _ => symmetry _ _ (COM _ _ _)).\nEnd NaturalTransformation.\n\nSection compose.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n  Variables F F' F'' : Functor C D.\n\n  Variable T' : NaturalTransformation F' F''.\n  Variable T : NaturalTransformation F F'.\n  Definition composeT\n  : NaturalTransformation F F''.\n    exact (Build_NaturalTransformation' F F''\n                                        (fun c => T' c o T c)\n                                        $(admit)$\n                                        $(admit)$).\n  Defined.\nEnd compose.\n\nSection whisker.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n  Variable E : PreCategory.\n\n  Section L.\n    Variable F : Functor D E.\n    Variables G G' : Functor C D.\n    Variable T : NaturalTransformation G G'.\n\n    Definition whisker_l\n      := Build_NaturalTransformation\n           (F o G) (F o G')\n           (fun c => morphism_of F (T c))\n           $(admit)$.\n  End L.\n\n  Section R.\n    Variables F F' : Functor D E.\n    Variable T : NaturalTransformation F F'.\n    Variable G : Functor C D.\n\n    Definition whisker_r\n      := Build_NaturalTransformation\n           (F o G) (F' o G)\n           (fun c => T (G c))\n           $(admit)$.\n  End R.\nEnd whisker.\nInfix \"o\" := composeT : natural_transformation_scope.\nInfix \"oL\" := whisker_l (at level 40, left associativity) : natural_transformation_scope.\nInfix \"oR\" := whisker_r (at level 40, left associativity) : natural_transformation_scope.\n\nSection identity'.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n\n  Section generalized.\n    Variables F G : Functor C D.\n    Hypothesis HO : object_of F = object_of G.\n\n    Local Notation CO c := (transport (fun GO => morphism D (F c) (GO c))\n                                      HO\n                                      (identity (F c))).\n    Definition generalized_identity\n    : NaturalTransformation F G.\n      exact (Build_NaturalTransformation'\n               F G\n               (fun c => CO c)\n               $(admit)$\n               $(admit)$).\n    Defined.\n  End generalized.\n\n  Definition identityT (F : Functor C D)\n  : NaturalTransformation F F\n    := Eval simpl in @ generalized_identity F F eq_refl.\nEnd identity'.\nNotation \"1\" := (identityT _) : natural_transformation_scope.\nLocal Open Scope natural_transformation_scope.\n\nSection functors.\n  Variable B : PreCategory.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n  Variable E : PreCategory.\n  Variable F : Functor D E.\n  Variable G : Functor C D.\n  Variable H : Functor B C.\n\n  Local Notation F0 := ((F o G) o H)%functor.\n  Local Notation F1 := (F o (G o H))%functor.\n\n  Definition associator_1 : NaturalTransformation F0 F1\n    := Eval simpl in\n        generalized_identity F0 F1 eq_refl.\nEnd functors.\nDefinition functor_category (C D : PreCategory) : PreCategory.\n  exact (@ Build_PreCategory (Functor C D)\n                            (@ NaturalTransformation C D)\n                            (@ identityT C D)\n                            (@ composeT C D)\n                            $(admit)$\n                            $(admit)$\n                            $(admit)$).\nDefined.\nLocal Notation \"C -> D\" := (functor_category C D) : category_scope.\nDefinition NaturalIsomorphism (C D : PreCategory) F G := @ Isomorphic (C -> D) F G.\nCoercion natural_transformation_of_natural_isomorphism C D F G\n         (T : @ NaturalIsomorphism C D F G)\n: NaturalTransformation F G\n  := T : morphism _ _ _.\n\nLocal Infix \"<~=~>\" := NaturalIsomorphism : natural_transformation_scope.\n\nRecord Pseudofunctor (C : PreCategory) :=\n  {\n    p_object_of :> C -> PreCategory;\n    p_morphism_of : forall s d, morphism C s d\n                                -> Functor (p_object_of s) (p_object_of d);\n    p_composition_of : forall s d d'\n                              (m1 : morphism C d d') (m2 : morphism C s d),\n                         (p_morphism_of _ _ (m1 o m2))\n                           <~=~> (p_morphism_of _ _ m1 o p_morphism_of _ _ m2)%functor;\n    p_composition_of_coherent\n    : forall w x y z\n             (f : morphism C w x) (g : morphism C x y) (h : morphism C y z),\n        ((associator_1 (p_morphism_of y z h) (p_morphism_of x y g) (p_morphism_of w x f))\n           o ((p_composition_of x y z h g oR p_morphism_of w x f)\n                o (p_composition_of w x z (h o g) f)))\n        = ((p_morphism_of y z h oL p_composition_of w x y g f)\n             o ((p_composition_of w y z h (g o f))\n                  o (idtoiso (_ -> _) (ap (p_morphism_of w z) (associativity C w x y z f g h)) : morphism _ _ _)))\n  }.\nContext `{fs : Funext}.\nContext `{P : PreCategory -> Type}.\n\nLocal Notation cat := (@ sub_pre_cat _ P).\nLocal Notation cat' := (@ sub_pre_cat fs P).\n\nLemma identity_associativity\n      (w x y z : PreCategory) (f : Functor w x)\n      (g : Functor x y) (h : Functor y z)\n: associator_1 h g f o (1 oR f o 1) =\n  h oL 1 o (1 o @ morphism_isomorphic _ _ _ (idtoiso (w -> z) (ap idmap (associativityF f g h)))).\n  admit.\nDefined.\nGlobal Instance reflexive_natural_isomorphism C D\n: Reflexive (@ NaturalIsomorphism C D) | 0.\nexact (_).\nDefined.\n\nTime Definition f0 := Build_Pseudofunctor\n                   cat\n                   (fun C => C.1)\n                   (fun _ _ F => F)\n                   (fun _ _ _ _ _ => reflexivity _). (* 0.013 s *)\nTime Definition g0 := (fun x y z w : cat => @ identity_associativity x.1 y.1 z.1 w.1). (* 0.003 s *)\nTime Definition f0g0 := f0 g0. (* 0.003 s *)\nTime Definition identityP : Pseudofunctor cat\n  := let x := @ reflexive_natural_isomorphism in\n     let y := f0g0 in\n     Build_Pseudofunctor\n       cat\n       (fun C => C.1)\n       (fun _ _ F => F)\n       (fun _ _ _ _ _ => reflexivity _)\n       (fun x y z w => @ identity_associativity x.1 y.1 z.1 w.1). (* 5.827 s *)\nTime Definition identityP' : Pseudofunctor cat\n  := f0 (fun x y z w => @ identity_associativity x.1 y.1 z.1 w.1). (* 0.005 s *)\nTime Definition identityP'' : Pseudofunctor cat\n  := Build_Pseudofunctor\n       cat\n       (fun C => C.1)\n       (fun _ _ F => F)\n       (fun _ _ _ _ _ => reflexivity _)\n       g0. (* 3.477 s *)\nTime Definition identityP''' : Pseudofunctor cat'\n  := Build_Pseudofunctor\n       cat'\n       (fun C => C.1)\n       (fun _ _ F => F)\n       (fun _ _ _ _ _ => reflexivity _)\n       (fun x y z w => @ identity_associativity x.1 y.1 z.1 w.1). (* 1.724 s *)\nTime Definition identityP'''' : Pseudofunctor cat\n  := let f0' := Build_Pseudofunctor\n                  cat\n                  (fun C => C.1)\n                  (fun _ _ F => F)\n                  (fun _ _ _ _ _ => reflexivity _) in\n     let g0' := (fun x y z w => @ identity_associativity x.1 y.1 z.1 w.1) in\n     f0' g0'. (* 11.467 s *)\nTime Definition identityP''''' : Pseudofunctor cat\n  := (fun f0' g0' => f0' g0')\n       (Build_Pseudofunctor\n          cat\n          (fun C => C.1)\n          (fun _ _ F => F)\n          (fun _ _ _ _ _ => reflexivity _))\n       ((fun x y z w => @ identity_associativity x.1 y.1 z.1 w.1)). (* 5.609 s *)\n\nFor the test suite, these [Time]s should be changed to [Timeout 1].\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525616/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525621","html_url":"https://github.com/coq/coq/issues/3712#issuecomment-337525621","issue_url":"https://api.github.com/repos/coq/coq/issues/3712","id":337525621,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTYyMQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-10T03:27:48Z","updated_at":"2017-10-18T09:35:51Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nThe fact that filling in the fs : Funext manually makes it go much faster, and that doing it as separate definitions is less than 0.1 s while doing it all together is 5-6 s both seem wrong.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525621/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525622","html_url":"https://github.com/coq/coq/issues/3712#issuecomment-337525622","issue_url":"https://api.github.com/repos/coq/coq/issues/3712","id":337525622,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTYyMg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-10T03:29:09Z","updated_at":"2017-10-18T09:35:52Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI tried to check if it was universes, but -type-in-type is broken.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525622/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525623","html_url":"https://github.com/coq/coq/issues/3712#issuecomment-337525623","issue_url":"https://api.github.com/repos/coq/coq/issues/3712","id":337525623,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTYyMw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-10-10T16:37:31Z","updated_at":"2017-10-18T09:35:52Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nThat's due to my commit two weeks ago which does systematic expansion of primitive projections during unification, so as to be compatible with the existing projections... of course that can incur an exponential time penalty. The explanation for the cases in which the slowdown occurs is simple: if the terms have existentials, conversion cannot be used and all the computation is done using unification, which is much slower. When you define things separately, you have more ground terms, and more conversion can happen (which doesn't need to do expansion of primitive projections).\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525623/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525625","html_url":"https://github.com/coq/coq/issues/3712#issuecomment-337525625","issue_url":"https://api.github.com/repos/coq/coq/issues/3712","id":337525625,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyNTYyNQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-03-03T22:52:23Z","updated_at":"2017-10-18T09:35:52Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nPerformance is much better now but the problem will remain due to the compatibility layer and late instantiation of typeclass instances.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337525625/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]