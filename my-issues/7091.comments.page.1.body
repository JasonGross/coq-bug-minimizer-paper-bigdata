What do you mean by "run `patterns`"? Do you mean "call the `pattern` tactic"? At first view, that would not be (too) complicated to extend pattern-matching problems of the form `@?f x1 ... xn` == `t` to problems of the form `@?f t1 ... tn` == `t` when `t1`, ..., `tn` are non-overlapping closed terms, using some kind of equality such as either syntactic equality (up to Î±-conversion) or even an equality modulo some reduction rules.

If these terms have holes themselves, we shall have other design choices to take into account. Like in the case of say a `destruct (S _)`, this is for instance less clear what to do when matching against `@?f u` when `u` has holes. Do we take the first subterm matching as the subterm to be matched and collect all other subterms that match this first subterm (so-called `LikeFirst` strategy in `Find_subterm`)? Do we fail if there are several disjoint subterms matching? Which notion of "disjoint" do we use?

OK, let's not necessarily address the most sophisticated cases at once. I have listed some of the design decisions we may have to eventually take, but if you are only interested at the current time with disjoint arguments compared up to syntactic equality (or even full conversion), that's probably a good first issue to be implemented, indeed inserting a call to `Tacred.pattern_occs` in the `PSoApp` case of `Constr_matching.matching_core`, and relaxing the syntax of `PSoApp` in the grammar to support arbitrary terms.

[Edited for refining]

PS: I believe that supporting this is (morally) independent of Ltac or Ltac2 (up to syntactic considerations).
Yes, I mean "calls the ` pattern` tactic.  Since `pattern` accepts a list of identifiers to simultaneously pattern, I think there is no problem with saying that `@?f x1 ... xn` == `t` is solved by running `eval pattern x1, ..., xn in t`, and that this equivalence should be documented. Since `pattern` already handles overlapping terms, this neatly solves the question of what to do with overlap.

I think that holes should be resolved in exactly the same way that they are resolved when passing `uconstr`s to `pattern` in Ltac, and it should be a compile- time or syntax error to have a new pattern variable in one of the patterns (i.e. `?@f ?x` should be a compile time error, as should `?@f (?x + ?y)` (while these things can undoubtedly be given meaning, and may even be useful in some cases, I think they introduce needless complication, and I prefer uniformity with the `pattern` tactic)).
Oops, did not mean to click "close"
This seems to me quite unatomic. It brings the semantic problems of the `pattern` tactic into Ltac matching, while you could do that in two passes by simply calling that tactic over the argument and then matching that. If you don't have a good justification for that (e.g. the above scheme doesn't work) then I don't think we should implement this change.

@ppedrot the above scheme works fine at the toplevel, but if I want it under binders (as in the example I gave), it requires about a dozen lines of boilerplate plus an invocation of fresh for every binder plus an extra cbv delta call for every binder if I want to avoid beta reduction. This is an enormous amount of overhead for something as simple as generalization/patterning.

(The overhead comes from the fact that the scheme you describe requires tactics in terms which (a) incur boilerplate and (b) don't work at all with open terms involving nameless or shadowed binders, incuring even more overhead.)

What are the semantic problems of the `pattern` tactic?
Sorry but I don't think suggesting a newcomer to work on this is a good idea. Even if the feature was agreed upon, I would not be able myself to implement it... as a consequence I would not ask a newcomer to do it either.
Duplicate of #3147.
Or maybe of #3148, I can't tell the difference between those 2 issues.
This is a duplicate of #3148 (I hadn't realized I'd requested this feature before).  Though perhaps that one should be closed as a duplicate of this one, since this one has more discussion.

The difference between this / #3148, and "@? patterns should not have to match the entire term" is that here, I'm asking for an extension to the kinds of arguments `@?` accepts, whereas in the other one, I'm asking for a way to bracket the `@?` syntax so that I can say "I want an app node with one argument, and the function part should match `@?f x y` or something.
@JasonGross The `pattern` tactic depends on term equality, and it is somewhat folklore that term equality is very subtle, e.g. do we take universes into account? (if yes, how? unify? syntactic equality?), how do we handle evars generated by the pattern? etc.
Maybe an intermediate solution would be to rely strictly on `pattern` as it is implemented now, even if, when term equality is eventually made better understood in `pattern`, Ltac pattern-matching will take benefit of it also.
