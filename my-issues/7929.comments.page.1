[{"url":"https://api.github.com/repos/coq/coq/issues/comments/400364508","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-400364508","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":400364508,"node_id":"MDEyOklzc3VlQ29tbWVudDQwMDM2NDUwOA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-06-26T15:57:05Z","updated_at":"2018-06-26T15:57:05Z","author_association":"MEMBER","body":"In fact, it seems like this is already the algorithm being used for parameters of the inductive type?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/400364508/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/400376700","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-400376700","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":400376700,"node_id":"MDEyOklzc3VlQ29tbWVudDQwMDM3NjcwMA==","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2018-06-26T16:27:11Z","updated_at":"2018-06-26T16:27:11Z","author_association":"CONTRIBUTOR","body":"For each non-parameter argument `name : type : sort` of a constructor the level of the inductive must be at least `sort`. `c1` has an argument `A : Type@{Top.3} : Type@{Top.3+1}`.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/400376700/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/400382978","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-400382978","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":400382978,"node_id":"MDEyOklzc3VlQ29tbWVudDQwMDM4Mjk3OA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-06-26T16:41:09Z","updated_at":"2018-06-26T16:41:09Z","author_association":"MEMBER","body":"Right, that is what is currently implemented.  What goes wrong if instead we say:\r\nFor each argument (parameter or otherwise) `name : type : sort` of a constructor, if `type` is itself a sort, then the level of the inductive must be at least `type`, otherwise it must be at least `sort`?\r\n\r\nI could not get Hurkens to go through with this weakening, and it seems like there should be an isomorphism that shows that it is consistent with what is already implemented.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/400382978/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/400383687","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-400383687","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":400383687,"node_id":"MDEyOklzc3VlQ29tbWVudDQwMDM4MzY4Nw==","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2018-06-26T16:43:03Z","updated_at":"2018-06-26T16:43:03Z","author_association":"CONTRIBUTOR","body":"That's inconsistent\r\n~~~coq\r\nRecord boxt : Type@{i} := { unboxt : Type@{i} }.\r\n~~~\r\nThis makes a type at level `i` which is equivalent to `Type@{i}`.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/400383687/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/400384621","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-400384621","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":400384621,"node_id":"MDEyOklzc3VlQ29tbWVudDQwMDM4NDYyMQ==","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2018-06-26T16:45:57Z","updated_at":"2018-06-26T16:45:57Z","author_association":"CONTRIBUTOR","body":"What you can do is not count arguments which appear in pattern position in the indices.\r\nBasically recognising that you can do the transformation to the parameter version.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/400384621/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/400385645","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-400385645","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":400385645,"node_id":"MDEyOklzc3VlQ29tbWVudDQwMDM4NTY0NQ==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-06-26T16:49:03Z","updated_at":"2018-06-26T16:49:03Z","author_association":"MEMBER","body":"Oh, I see, thanks.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/400385645/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/400527255","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-400527255","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":400527255,"node_id":"MDEyOklzc3VlQ29tbWVudDQwMDUyNzI1NQ==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-06-27T02:57:11Z","updated_at":"2018-06-27T02:57:11Z","author_association":"MEMBER","body":"> What you can do is not count arguments which appear in pattern position in the indices.\r\n\r\nOh, hm.  Would it be reasonable to implement that in Coq?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/400527255/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/447753094","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-447753094","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":447753094,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0Nzc1MzA5NA==","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2018-12-17T07:54:39Z","updated_at":"2018-12-17T07:54:39Z","author_association":"MEMBER","body":"> Oh, hm. Would it be reasonable to implement that in Coq?\r\n\r\nI think so. To be in pattern position is a particular case of \"small inversion\" where any pattern structure can be inverted and thus not being counted as a proper part of the arguments of the constructors (e.g. in `v : Vector.t A (S n)`, even if a `cons` contains a `n` argument, this `n` is forced).\r\n\r\nI would vote in favor of this refinement.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/447753094/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/447789337","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-447789337","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":447789337,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0Nzc4OTMzNw==","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2018-12-17T10:07:00Z","updated_at":"2018-12-17T10:07:00Z","author_association":"CONTRIBUTOR","body":"Forced arguments not counting towards universes is almost done in my sprop branch, it's just disabled to be compatible with extraction. Maybe we could do that by treating Prop/SProp specially and enable the feature for inductives in Set/Type though.\r\n~~~coq\r\nInductive NonZero : nat -> Prop := nonzero : forall n, NonZero (S n).\r\nDefinition pred n (H:NonZero n) := match H with nonzero k => k end.\r\nExtraction pred. (* what should this say? *)\r\n~~~","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/447789337/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/448256248","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-448256248","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":448256248,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0ODI1NjI0OA==","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2018-12-18T15:19:44Z","updated_at":"2018-12-18T15:19:44Z","author_association":"CONTRIBUTOR","body":"> Maybe we could do that by treating Prop/SProp specially and enable the feature for inductives in Set/Type though.\r\n\r\nActually that's what I did already, I just didn't remember (0549e1c4b3).","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/448256248/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/448284624","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-448284624","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":448284624,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0ODI4NDYyNA==","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2018-12-18T16:37:08Z","updated_at":"2018-12-18T16:39:33Z","author_association":"MEMBER","body":"> Actually that's what I did already, I just didn't remember (0549e1c).\r\n\r\nHappy to learn that this is already done!\r\n\r\n(And moreover that it allows more `match`, what I did not realize at once.)","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/448284624/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/448287428","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-448287428","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":448287428,"node_id":"MDEyOklzc3VlQ29tbWVudDQ0ODI4NzQyOA==","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2018-12-18T16:44:54Z","updated_at":"2018-12-18T16:44:54Z","author_association":"MEMBER","body":"```\r\nInductive NonZero : nat -> Prop := nonzero : forall n, NonZero (S n).\r\nDefinition pred n (H:NonZero n) := match H with nonzero k => k end.\r\nExtraction pred. (* what should this say? *)\r\n```\r\nThe reason `n` does not have to be counted as relevant in the constructor is that it can be canonically reconstructed from the type. So, I would say that `Extraction pred` should return `let pred n = n` (i.e. dropping the `H` because in `Prop` and returning `n`, i.e. the first parameter, rather than the `n` copied under name `k` in the branch of the `match`).","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/448287428/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/473326798","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-473326798","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":473326798,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MzMyNjc5OA==","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2019-03-15T15:18:31Z","updated_at":"2019-03-15T15:18:31Z","author_association":"CONTRIBUTOR","body":">Forced arguments not counting towards universes is almost done in my sprop branch\r\n\r\nSo in the end it didn't make it in the sprop PR. It could still be done as a separate change, not sure if it's worth the added kernel complexity.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/473326798/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/473519325","html_url":"https://github.com/coq/coq/issues/7929#issuecomment-473519325","issue_url":"https://api.github.com/repos/coq/coq/issues/7929","id":473519325,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MzUxOTMyNQ==","user":{"login":"mattam82","id":98373,"node_id":"MDQ6VXNlcjk4Mzcz","avatar_url":"https://avatars.githubusercontent.com/u/98373?v=4","gravatar_id":"","url":"https://api.github.com/users/mattam82","html_url":"https://github.com/mattam82","followers_url":"https://api.github.com/users/mattam82/followers","following_url":"https://api.github.com/users/mattam82/following{/other_user}","gists_url":"https://api.github.com/users/mattam82/gists{/gist_id}","starred_url":"https://api.github.com/users/mattam82/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mattam82/subscriptions","organizations_url":"https://api.github.com/users/mattam82/orgs","repos_url":"https://api.github.com/users/mattam82/repos","events_url":"https://api.github.com/users/mattam82/events{/privacy}","received_events_url":"https://api.github.com/users/mattam82/received_events","type":"User","site_admin":false},"created_at":"2019-03-16T10:40:09Z","updated_at":"2019-03-16T10:40:09Z","author_association":"MEMBER","body":"It would be incorrect to have ‘pred n = n’, we should rather have ‘pred n = match n with 0 => assert false | S n => n` The match on NonZero is incorrect as you write it because NonZero is not a singleton whereas ‘NonZero n = match n with 0 => False | S n’ => S n’ = n` is fine (this is what the inversion yo put it in SProp would produce more or less). With a bit of dependent elimination at least `pred` can be defined such that it extracts to the right pred.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/473519325/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]