[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533498","html_url":"https://github.com/coq/coq/issues/4155#issuecomment-337533498","issue_url":"https://api.github.com/repos/coq/coq/issues/4155","id":337533498,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzQ5OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-03-24T20:24:21Z","updated_at":"2017-10-18T09:58:43Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nHere is code that worked in 8.4, and does not in 8.5:\n\n(* File reduced by coq-bug-finder from original input, then from 740 lines to 323 lines, then from 330 lines to 139 lines, then from 148 lines to 84 lines, then from 244 lines to 233 lines *)\n(* coqc version 8.5beta1 (March 2015) compiled on Mar 17 2015 12:34:25 with OCaml 4.01.0\n   coqtop version cagnode13:/afs/csail.mit.edu/u/j/jgross/coq-8.5-require-on-the-fly,require-on-the-fly (b0bbfbcfb933b8d99268994376ffcccafa150f9b) *)\nAxiom proof_admitted : False.\nTactic Notation \"admit\" := case proof_admitted.\nRequire Coq.Sorting.Permutation.\nRequire Coq.Strings.String.\n\nGlobal Set Implicit Arguments.\n\nLemma filter_map :\n  forall {A B} f g seq,\n    List.filter f (@ List.map A B g seq) =\n    List.map g (List.filter (fun x => f (g x)) seq).\n  admit.\nDefined.\n\nSection IndexedEnsembles.\n\n  Context {ElementType : Type}.\n\n  Record IndexedElement :=\n    { elementIndex : nat;\n      indexedElement : ElementType }.\n\nEnd IndexedEnsembles.\n\nSection ilist.\n\n  Variable A : Type.\n\n  Variable B : A -> Type.\n\n  Inductive ilist : list A -> Type :=\n  | icons : forall a As, B a -> ilist As -> ilist (a :: As)\n  | inil : ilist nil.\n\nEnd ilist.\n\nExport Coq.Sorting.Permutation.\n\nDefinition BagInsertEnumerate\n           {TContainer TItem: Type}\n           (RepInv : TContainer -> Prop)\n           (benumerate : TContainer -> list TItem)\n           (binsert    : TContainer -> TItem -> TContainer) :=\n  forall inserted container\n         (containerCorrect : RepInv container),\n    Permutation\n      (benumerate (binsert container inserted))\n      (inserted :: benumerate container).\n\nDefinition BagEnumerateEmpty\n           {TContainer TItem: Type}\n           (benumerate : TContainer -> list TItem)\n           (bempty     : TContainer) :=\n  forall item, ~ List.In item (benumerate bempty).\n\nDefinition BagFindCorrect\n           {TContainer TItem TSearchTerm: Type}\n           (RepInv : TContainer -> Prop)\n           (bfind         : TContainer -> TSearchTerm -> list TItem)\n           (bfind_matcher : TSearchTerm -> TItem -> bool)\n           (benumerate : TContainer -> list TItem) :=\n  forall container search_term\n         (containerCorrect : RepInv container),\n    Permutation\n      (List.filter (bfind_matcher search_term) (benumerate container))\n      (bfind container search_term).\n\nDefinition BagCountCorrect\n           {TContainer TItem TSearchTerm: Type}\n           (RepInv : TContainer -> Prop)\n           (bcount        : TContainer -> TSearchTerm -> nat)\n           (bfind         : TContainer -> TSearchTerm -> list TItem) :=\n  forall container search_term\n         (containerCorrect : RepInv container),\n    List.length (bfind container search_term) = (bcount container search_term).\n\nDefinition BagDeleteCorrect\n           {TContainer TItem TSearchTerm: Type}\n           (RepInv : TContainer -> Prop)\n           (bfind         : TContainer -> TSearchTerm -> list TItem)\n           (bfind_matcher : TSearchTerm -> TItem -> bool)\n           (benumerate : TContainer -> list TItem)\n           (bdelete    : TContainer -> TSearchTerm -> (list TItem) * TContainer) :=\n  forall container search_term\n         (containerCorrect : RepInv container),\n    Permutation (benumerate (snd (bdelete container search_term)))\n                (snd (List.partition (bfind_matcher search_term)\n                                     (benumerate container)))\n    /\\ Permutation (fst (bdelete container search_term))\n                   (fst (List.partition (bfind_matcher search_term)\n                                        (benumerate container))).\n\nDefinition BagUpdateCorrect\n           {TContainer TItem TSearchTerm TUpdateTerm : Type}\n           (RepInv : TContainer -> Prop)\n           (ValidUpdate : TUpdateTerm -> Prop)\n           (bfind         : TContainer -> TSearchTerm -> list TItem)\n           (bfind_matcher : TSearchTerm -> TItem -> bool)\n           (benumerate : TContainer -> list TItem)\n           (bupdate_transform : TUpdateTerm -> TItem -> TItem)\n           (bupdate    : TContainer -> TSearchTerm -> TUpdateTerm -> list TItem * TContainer) :=\n  forall container search_term update_term\n         (containerCorrect : RepInv container)\n         (valid_update : ValidUpdate update_term),\n    Permutation (benumerate (snd (bupdate container search_term update_term)))\n                ((snd (List.partition (bfind_matcher search_term)\n                                      (benumerate container)))\n                   ++ List.map (bupdate_transform update_term)\n                   (fst (List.partition (bfind_matcher search_term)\n                                        (benumerate container))))\n    /\\ Permutation (fst (bupdate container search_term update_term))\n                   (fst (List.partition (bfind_matcher search_term)\n                                        (benumerate container))).\n\nDefinition binsert_Preserves_RepInv\n           {TContainer TItem: Type}\n           (RepInv : TContainer -> Prop)\n           (binsert    : TContainer -> TItem -> TContainer)\n  := forall container item\n            (containerCorrect : RepInv container),\n       RepInv (binsert container item).\n\nDefinition bdelete_Preserves_RepInv\n           {TContainer TItem TSearchTerm: Type}\n           (RepInv : TContainer -> Prop)\n           (bdelete    : TContainer -> TSearchTerm -> (list TItem) * TContainer)\n  := forall container search_term\n            (containerCorrect : RepInv container),\n       RepInv (snd (bdelete container search_term)).\n\nDefinition bupdate_Preserves_RepInv\n           {TContainer TItem TSearchTerm TUpdateTerm : Type}\n           (RepInv : TContainer -> Prop)\n           (ValidUpdate       : TUpdateTerm -> Prop)\n           (bupdate    : TContainer -> TSearchTerm -> TUpdateTerm -> (list TItem) * TContainer)\n  := forall container search_term update_term\n            (containerCorrect : RepInv container)\n            (valid_update : ValidUpdate update_term),\n       RepInv (snd (bupdate container search_term update_term)).\n\nClass Bag (BagType TItem SearchTermType UpdateTermType : Type) :=\n  {\n\n    bempty            : BagType;\n    bfind_matcher     : SearchTermType -> TItem -> bool;\n    bupdate_transform : UpdateTermType -> TItem -> TItem;\n\n    benumerate : BagType -> list TItem;\n    bfind      : BagType -> SearchTermType -> list TItem;\n    binsert    : BagType -> TItem -> BagType;\n    bcount     : BagType -> SearchTermType -> nat;\n    bdelete    : BagType -> SearchTermType -> (list TItem) * BagType;\n    bupdate    : BagType -> SearchTermType -> UpdateTermType -> (list TItem) * BagType\n  }.\n\nClass CorrectBag\n      {BagType TItem SearchTermType UpdateTermType : Type}\n      (RepInv            : BagType -> Prop)\n      (ValidUpdate       : UpdateTermType -> Prop)\n      (BagImplementation : Bag BagType TItem SearchTermType UpdateTermType) :=\n  {\n\n    bempty_RepInv     : RepInv bempty;\n    binsert_RepInv    : binsert_Preserves_RepInv RepInv binsert;\n    bdelete_RepInv    : bdelete_Preserves_RepInv RepInv bdelete ;\n    bupdate_RepInv    : bupdate_Preserves_RepInv RepInv ValidUpdate bupdate;\n\n    benumerate_empty  : BagEnumerateEmpty benumerate bempty;\n    binsert_enumerate : BagInsertEnumerate RepInv benumerate binsert;\n    bfind_correct     : BagFindCorrect RepInv bfind bfind_matcher benumerate;\n    bcount_correct    : BagCountCorrect RepInv bcount bfind;\n    bdelete_correct   : BagDeleteCorrect RepInv bfind bfind_matcher benumerate bdelete;\n    bupdate_correct   : BagUpdateCorrect RepInv ValidUpdate bfind bfind_matcher benumerate bupdate_transform bupdate\n  }.\n\nImport Coq.Strings.String.\n\nRecord Attribute :=\n  { attrName : string;\n    attrType : Type }.\n\nRecord Heading :=\n  { AttrList : list Attribute }.\n\nDefinition Tuple {heading : Heading} :=\n  ilist attrType (AttrList heading).\n\nExport Coq.Lists.List.\n\nGoal forall (heading : Heading)\n            (SearchTermTypePlus UpdateTermTypePlus BagTypePlus : Type)\n            (BagPlus : Bag BagTypePlus (@ Tuple heading) SearchTermTypePlus\n                           UpdateTermTypePlus) (search_term : SearchTermTypePlus)\n            (x0 : list (@ IndexedElement (@ Tuple heading))),\n       @ Permutation (@ Tuple heading)\n                    (@ map (@ IndexedElement (@ Tuple heading)) (@ Tuple heading)\n                          (@ indexedElement (@ Tuple heading))\n                          (@ filter (@ IndexedElement (@ Tuple heading))\n                                   (fun t : @ IndexedElement (@ Tuple heading) =>\n                                      negb\n                                        (@ bfind_matcher BagTypePlus (@ Tuple heading) SearchTermTypePlus\n                                                        UpdateTermTypePlus BagPlus search_term\n                                                        (@ indexedElement (@ Tuple heading) t))) x0))\n                    (@ map (@ IndexedElement (@ Tuple heading)) (@ Tuple heading)\n                          (@ indexedElement (@ Tuple heading))\n                          (@ filter (@ IndexedElement (@ Tuple heading))\n                                   (fun t : @ IndexedElement (@ Tuple heading) =>\n                                      negb\n                                        (@ bfind_matcher BagTypePlus (@ Tuple heading) SearchTermTypePlus\n                                                        UpdateTermTypePlus BagPlus search_term\n                                                        (@ indexedElement (@ Tuple heading) t))) x0)).\n  intros.\n  let lem := constr:(fun A => @ filter_map A _ (fun t => negb (bfind_matcher search_term t)))\n  in rewrite <- lem.\n  rewrite <- (fun A => @ filter_map A _ (fun t => negb (bfind_matcher search_term t))).\n(* Toplevel input, characters 53-66:\nError:\nIn environment\nheading : Heading\nSearchTermTypePlus : Type\nUpdateTermTypePlus : Type\nBagTypePlus : Type\nBagPlus : Bag BagTypePlus Tuple SearchTermTypePlus UpdateTermTypePlus\nsearch_term : SearchTermTypePlus\nx0 : list IndexedElement\nUnable to unify \"?TItem@ {A:=?M1598}\" with \"?TItem@ {A:=?A}\". *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533498/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/353596567","html_url":"https://github.com/coq/coq/issues/4155#issuecomment-353596567","issue_url":"https://api.github.com/repos/coq/coq/issues/4155","id":353596567,"node_id":"MDEyOklzc3VlQ29tbWVudDM1MzU5NjU2Nw==","user":{"login":"ppedrot","id":1202327,"node_id":"MDQ6VXNlcjEyMDIzMjc=","avatar_url":"https://avatars.githubusercontent.com/u/1202327?v=4","gravatar_id":"","url":"https://api.github.com/users/ppedrot","html_url":"https://github.com/ppedrot","followers_url":"https://api.github.com/users/ppedrot/followers","following_url":"https://api.github.com/users/ppedrot/following{/other_user}","gists_url":"https://api.github.com/users/ppedrot/gists{/gist_id}","starred_url":"https://api.github.com/users/ppedrot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ppedrot/subscriptions","organizations_url":"https://api.github.com/users/ppedrot/orgs","repos_url":"https://api.github.com/users/ppedrot/repos","events_url":"https://api.github.com/users/ppedrot/events{/privacy}","received_events_url":"https://api.github.com/users/ppedrot/received_events","type":"User","site_admin":false},"created_at":"2017-12-22T13:16:49Z","updated_at":"2017-12-22T13:16:49Z","author_association":"MEMBER","body":"This is a bug affecting an already old version, and it is unlikely both that we fix it and that it would help you. Therefore I'll close it as WONTFIX.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/353596567/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]