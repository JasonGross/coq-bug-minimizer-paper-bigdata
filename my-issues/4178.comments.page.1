[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533851","html_url":"https://github.com/coq/coq/issues/4178#issuecomment-337533851","issue_url":"https://api.github.com/repos/coq/coq/issues/4178","id":337533851,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzg1MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-02T22:40:45Z","updated_at":"2022-01-29T16:38:01Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nI don't want to have to manually write lemmas like this:\r\n\r\n```coq\r\nRequire Import Coq.Lists.List.\r\nRequire Import Coq.Strings.String.\r\n\r\nGlobal Coercion is_true : bool >-> Sortclass.\r\nCoercion bool_of_sumbool {A B} (x : {A} + {B}) : bool := if x then true else false.\r\n\r\nScheme Equality for bool.\r\nScheme Equality for Ascii.ascii.\r\nScheme Equality for string.\r\nScheme Equality for list.\r\nScheme Equality for option.\r\n\r\nSection beq_correct.\r\n  Local Ltac t rew_t :=\r\n    match goal with\r\n      | [ |- _ = bool_of_sumbool (?eq_dec ?x ?y) ]\r\n        => revert y; induction x; intro y; simpl\r\n    end;\r\n    match goal with\r\n      | [ |- _ = bool_of_sumbool (?eq_dec ?x ?y) ]\r\n        => destruct (eq_dec x y)\r\n    end;\r\n    subst; simpl in *;\r\n    try solve [ repeat match goal with\r\n                         | [ H : _ <> ?y |- _ ] => is_var y; destruct y\r\n                         | [ H : ?x <> ?x |- _ ] => destruct (H eq_refl)\r\n                         | [ H : _ |- _ ] => rewrite !H; []\r\n                         | _ => progress rew_t\r\n                         | _ => progress simpl in *\r\n                         | _ => split; (congruence || discriminate)\r\n                         | _ => progress subst\r\n                         | [ |- context[bool_of_sumbool ?e] ]\r\n                           => destruct e; simpl\r\n                         | [ |- true = false ] => exfalso\r\n                         | [ |- false = true ] => exfalso\r\n                         | [ H : _ <> _ |- False ] => apply H; clear H\r\n                         | [ |- ?x = false ] => case_eq x; intro\r\n                       end ].\r\n\r\n  Lemma bool_beq_correct {x y} : bool_beq x y = bool_eq_dec x y.\r\n  Proof. t idtac. Qed.\r\n  Lemma ascii_beq_correct {x y} : ascii_beq x y = ascii_eq_dec x y.\r\n  Proof. t ltac:(rewrite !bool_beq_correct). Qed.\r\n  Lemma string_beq_correct {x y} : string_beq x y = string_eq_dec x y.\r\n  Proof. t ltac:(rewrite !ascii_beq_correct). Qed.\r\n  Lemma list_beq_correct {A eq_A}\r\n        (A_bl : forall x y : A, eq_A x y = true -> x = y)\r\n        (A_lb : forall x y : A, x = y -> eq_A x y = true)\r\n        {x y : list A}\r\n  : list_beq eq_A x y = list_eq_dec eq_A A_bl A_lb x y.\r\n  Proof.\r\n    t ltac:(first [ rewrite !(A_lb _ _) by congruence\r\n                  | erewrite (A_bl _ _) by eassumption\r\n                  | rewrite Bool.andb_true_r\r\n                  | rewrite Bool.andb_false_r ]).\r\n  Qed.\r\n  Definition list_eq_dec' {A} (dec_eq_A : forall x y : A, {x = y} + {x <> y})\r\n  : forall x y : list A, {x = y} + {x <> y}.\r\n  Proof.\r\n    refine (list_eq_dec dec_eq_A _ _);\r\n    abstract (intros; edestruct dec_eq_A; simpl in *; subst; congruence).\r\n  Defined.\r\n  Lemma list_beq_correct' {A} {eq_A : A -> A -> bool} {dec_eq_A : forall x y : A, {x = y} + {x <> y}}\r\n        (eq_A_correct : forall x y, eq_A x y = dec_eq_A x y)\r\n        {x y : list A}\r\n  : list_beq eq_A x y = list_eq_dec' dec_eq_A x y.\r\n  Proof.\r\n    unfold list_eq_dec'; erewrite list_beq_correct.\r\n    do 2 edestruct list_eq_dec; subst; simpl; congruence.\r\n    Grab Existential Variables.\r\n    intros ??; rewrite eq_A_correct; edestruct dec_eq_A; simpl; congruence.\r\n    intros ??; rewrite eq_A_correct; edestruct dec_eq_A; simpl; congruence.\r\n  Qed.\r\n  Lemma option_beq_correct {A eq_A}\r\n        (A_bl : forall x y : A, eq_A x y = true -> x = y)\r\n        (A_lb : forall x y : A, x = y -> eq_A x y = true)\r\n        {x y : option A}\r\n  : option_beq eq_A x y = option_eq_dec eq_A A_bl A_lb x y.\r\n  Proof.\r\n    t ltac:(first [ rewrite !(A_lb _ _) by congruence\r\n                  | erewrite (A_bl _ _) by eassumption\r\n                  | rewrite Bool.andb_true_r\r\n                  | rewrite Bool.andb_false_r ]).\r\n  Qed.\r\n  Definition option_eq_dec' {A} (dec_eq_A : forall x y : A, {x = y} + {x <> y})\r\n  : forall x y : option A, {x = y} + {x <> y}.\r\n  Proof.\r\n    refine (option_eq_dec dec_eq_A _ _);\r\n    abstract (intros; edestruct dec_eq_A; simpl in *; subst; congruence).\r\n  Defined.\r\n  Lemma option_beq_correct' {A} {eq_A : A -> A -> bool} {dec_eq_A : forall x y : A, {x = y} + {x <> y}}\r\n        (eq_A_correct : forall x y, eq_A x y = dec_eq_A x y)\r\n        {x y : option A}\r\n  : option_beq eq_A x y = option_eq_dec' dec_eq_A x y.\r\n  Proof.\r\n    unfold option_eq_dec'; erewrite option_beq_correct.\r\n    do 2 edestruct option_eq_dec; subst; simpl; congruence.\r\n    Grab Existential Variables.\r\n    intros ??; rewrite eq_A_correct; edestruct dec_eq_A; simpl; congruence.\r\n    intros ??; rewrite eq_A_correct; edestruct dec_eq_A; simpl; congruence.\r\n  Qed.\r\nEnd beq_correct.\r\n\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533851/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533852","html_url":"https://github.com/coq/coq/issues/4178#issuecomment-337533852","issue_url":"https://api.github.com/repos/coq/coq/issues/4178","id":337533852,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzg1Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-02T23:03:38Z","updated_at":"2022-01-29T16:38:48Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nActually, given the way the [*_eq_dec] lemmas are set up, the following are probably the relevant correctness lemmas:\r\n```coq\r\nSection beq_bl_lb.\r\n  Local Ltac t rew_t :=\r\n    let x := match goal with\r\n               | [ |- _ -> ?beq ?x ?y = true ] => constr:x\r\n               | [ |- _ -> ?x = ?y ] => constr:x\r\n             end in\r\n    let y := match goal with\r\n               | [ |- _ -> ?beq ?x ?y = true ] => constr:y\r\n               | [ |- _ -> ?x = ?y ] => constr:y\r\n             end in\r\n    revert y; induction x; intro y; destruct y;\r\n    simpl in *;\r\n    subst;\r\n    repeat match goal with\r\n             | _ => progress subst\r\n             | _ => congruence\r\n             | _ => setoid_rewrite Bool.andb_true_iff\r\n             | [ H : forall y, _ -> _ = true |- _ ] => setoid_rewrite <- (H _ : impl _ _)\r\n             | [ H : forall y, _ = true -> _ = _ |- _ ] => setoid_rewrite (H _ : impl _ _)\r\n             | [ H : forall x y, _ -> _ = true |- _ ] => setoid_rewrite <- (H _ _ : impl _ _)\r\n             | [ H : forall x y, _ = true -> _ = _ |- _ ] => setoid_rewrite (H _ _ : impl _ _)\r\n             | [ H : _ /\\ _ |- _ ] => destruct H\r\n             | [ |- _ /\\ _ ] => split\r\n             | _ => progress rew_t\r\n           end.\r\n\r\n  Lemma bool_bl {x y} : bool_beq x y = true -> x = y.\r\n  Proof. t idtac. Qed.\r\n  Lemma bool_lb {x y} : x = y -> bool_beq x y = true.\r\n  Proof. t idtac. Qed.\r\n  Lemma ascii_bl {x y} : ascii_beq x y = true -> x = y.\r\n  Proof. t ltac:(setoid_rewrite (@ bool_bl _ _ : impl _ _) || intro). Qed.\r\n  Lemma ascii_lb {x y} : x = y -> ascii_beq x y = true.\r\n  Proof. t ltac:(setoid_rewrite <- (@ bool_lb _ _ : impl _ _) || intro). Qed.\r\n  Lemma string_bl {x y} : string_beq x y = true -> x = y.\r\n  Proof. t ltac:(setoid_rewrite (@ ascii_bl _ _ : impl _ _) || intro). Qed.\r\n  Lemma string_lb {x y} : x = y -> string_beq x y = true.\r\n  Proof. t ltac:(setoid_rewrite <- (@ ascii_lb _ _ : impl _ _) || intro). Qed.\r\n  Lemma list_bl {A eq_A} (A_bl : forall x y : A, eq_A x y = true -> x = y) {x y} \r\n  : list_beq eq_A x y = true -> x = y.\r\n  Proof. t intro. Qed.\r\n  Lemma list_lb {A eq_A} (A_lb : forall x y : A, x = y -> eq_A x y = true) {x y} \r\n  : x = y -> list_beq eq_A x y = true.\r\n  Proof. t intro. Qed.\r\n  Lemma option_bl {A eq_A} (A_bl : forall x y : A, eq_A x y = true -> x = y) {x y} \r\n  : option_beq eq_A x y = true -> x = y.\r\n  Proof. t intro. Qed.\r\n  Lemma option_lb {A eq_A} (A_lb : forall x y : A, x = y -> eq_A x y = true) {x y} \r\n  : x = y -> option_beq eq_A x y = true.\r\n  Proof. t intro. Qed.\r\nEnd beq_bl_lb.\r\n\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533852/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533855","html_url":"https://github.com/coq/coq/issues/4178#issuecomment-337533855","issue_url":"https://api.github.com/repos/coq/coq/issues/4178","id":337533855,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzg1NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-03T06:05:27Z","updated_at":"2022-01-29T16:38:57Z","author_association":"CONTRIBUTOR","body":"Comment author: @silene\r\n\r\nI am a bit confused. The lemmas generated by Scheme Equality seem to be quite close to the ones you are asking for. Sure, their names are awfully long, but they don't warrant doing the proofs by hand:\r\n```coq\r\nLemma bool_bl {x y} : bool_beq x y = true -> x = y.\r\nProof. now apply internal_bool_dec_bl. Qed.\r\nLemma bool_lb {x y} : x = y -> bool_beq x y = true.\r\nProof. now apply internal_bool_dec_lb. Qed.\r\nLemma ascii_bl {x y} : ascii_beq x y = true -> x = y.\r\nProof. now apply internal_ascii_dec_bl. Qed.\r\nLemma ascii_lb {x y} : x = y -> ascii_beq x y = true.\r\nProof. now apply internal_ascii_dec_lb. Qed.\r\nLemma string_bl {x y} : string_beq x y = true -> x = y.\r\nProof. now apply internal_string_dec_bl. Qed.\r\nLemma string_lb {x y} : x = y -> string_beq x y = true.\r\nProof. now apply internal_string_dec_lb. Qed.\r\nLemma list_bl {A eq_A} (A_bl : forall x y : A, eq_A x y = true -> x = y) {x y} \r\n  : list_beq A eq_A x y = true -> x = y.\r\nProof. now apply internal_list_dec_bl. Qed.\r\nLemma list_lb {A eq_A} (A_lb : forall x y : A, x = y -> eq_A x y = true) {x y} \r\n  : x = y -> list_beq A eq_A x y = true.\r\nProof. now apply internal_list_dec_lb. Qed.\r\nLemma option_bl {A eq_A} (A_bl : forall x y : A, eq_A x y = true -> x = y) {x y} \r\n  : option_beq A eq_A x y = true -> x = y.\r\nProof. now apply internal_option_dec_bl. Qed.\r\nLemma option_lb {A eq_A} (A_lb : forall x y : A, x = y -> eq_A x y = true) {x y} \r\n  : x = y -> option_beq A eq_A x y = true.\r\nProof. now apply internal_option_dec_lb. Qed.\r\n```\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533855/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533857","html_url":"https://github.com/coq/coq/issues/4178#issuecomment-337533857","issue_url":"https://api.github.com/repos/coq/coq/issues/4178","id":337533857,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzg1Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-09T21:05:10Z","updated_at":"2017-10-18T09:59:41Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n[Scheme Equality for bool.] prints:\n\nbool_beq is defined\nbool_eq_dec is defined\n\nPerhaps internal_bool_dec_bl and internal_bool_dec_lb should be renamed to strip off the internal_ prefix, and should be printed in the output?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533857/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533859","html_url":"https://github.com/coq/coq/issues/4178#issuecomment-337533859","issue_url":"https://api.github.com/repos/coq/coq/issues/4178","id":337533859,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzg1OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-10T05:26:01Z","updated_at":"2017-10-18T09:59:41Z","author_association":"CONTRIBUTOR","body":"Comment author: @silene\n\nRenaming is not a solution since it would break existing developments. I guess we could add shorter-named synonyms though.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533859/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533861","html_url":"https://github.com/coq/coq/issues/4178#issuecomment-337533861","issue_url":"https://api.github.com/repos/coq/coq/issues/4178","id":337533861,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzg2MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-10T09:59:39Z","updated_at":"2017-10-18T09:59:41Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nDon't know if my comment will help as long as it is just a comment and no acting, but my view about these inductive schemes is more and more that they should enter a name space canonically bound to the inductive type (e.g. Coq.Init.Datatypes.bool.beq, Coq.Init.Datatypes.bool.eq_dec, ...) seen as a name space virtually populated with all possible schemes, and the schemes generated lazily on demand, with no need for Scheme Equality, nor for names with prefix \"internal_\". Just referring to bool.beq should force the effective construction of the scheme.\n\nMaking it a comment though to see if this possibly echoes the view of others.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533861/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533863","html_url":"https://github.com/coq/coq/issues/4178#issuecomment-337533863","issue_url":"https://api.github.com/repos/coq/coq/issues/4178","id":337533863,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzg2Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-10T10:28:52Z","updated_at":"2017-10-18T09:59:42Z","author_association":"CONTRIBUTOR","body":"Comment author: @silene\n\nI am fine with the general idea of generating schemes on the fly (though this does not solve the issue of naming and statement of the theorems). But I always wonder how coqchk will deal with such generated definitions. Will the checker have to be modified to generate them on the fly or will they be redundantly stored inside the .vo files?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533863/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533866","html_url":"https://github.com/coq/coq/issues/4178#issuecomment-337533866","issue_url":"https://api.github.com/repos/coq/coq/issues/4178","id":337533866,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzg2Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-10T16:04:37Z","updated_at":"2017-10-18T09:59:42Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nGood question. This would complicate the checker to have it able to rebuild the schemes, so these schemes would still be put in the environment as it is now when using Scheme, and as it was in 8.4 when generated them internally. \nThen, they would be duplicated across different files, like it was for internal ones in 8.4, and like it is now for internal ones with the grain being the proof.\n\nWrt the stm, having them as \"side-effect\" does not look worse to me than when e.g. adding universe constraints produced by Qed proofs as a side-effect. This is actually better since universe constraints do not always have a consistent superset (in a way similar to what happened in pre-8.5 with file-level  modularity) while schemes always have a consistent superset. Maybe another motivation to get rid of \"spaghetti\" code and rolling up the side-effects produced by commands e.g. at the level of at least vernacentries.ml...\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533866/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533867","html_url":"https://github.com/coq/coq/issues/4178#issuecomment-337533867","issue_url":"https://api.github.com/repos/coq/coq/issues/4178","id":337533867,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMzg2Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-04-13T08:55:42Z","updated_at":"2017-10-18T09:59:42Z","author_association":"CONTRIBUTOR","body":"Comment author: @aspiwack\n\nGenerating schemes on the fly is kind of orthogonal to having them tucked in a dedicated namespace. I'm quite in favour of the latter, while I'm not entirely sure what benefits on-the-fly generation brings in most cases.\n\nIt also requires strong commutation properties -- which, as Hugo notes in [BZ#7](https://github.com/coq/coq/issues?q=is%3Aissue%20%22Original%20bug%20ID%3A%20BZ%237%22), is acceptable -- as the schemes could be generated in two different files, and requiring both files would add the scheme twice to the environment. It's probably not an easy thing to do.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337533867/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]