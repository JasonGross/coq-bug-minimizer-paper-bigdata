[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520525","html_url":"https://github.com/coq/coq/issues/3393#issuecomment-337520525","issue_url":"https://api.github.com/repos/coq/coq/issues/3393","id":337520525,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMDUyNQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-06-22T22:08:29Z","updated_at":"2017-10-18T09:21:11Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n(This has been fixed in trunk, so I'm just making this report to have a name to give the test-suite file.\n\n(* -*- coq-prog-args: (\"-emacs\" \"-indices-matter\") -*- *)\n(* File reduced by coq-bug-finder from original input, then from 8760 lines to 7519 lines, then from 7050 lines to 909 lines, then from 846 lines to 578 lines, then from 497 lines to 392 lines, then from 365 lines to 322 lines, then from 252 lines to 205 lines, then from 215 lines to 204 lines, then from 210 lines to 182 lines, then from 175 lines to 157 lines *)\nSet Universe Polymorphism.\nAxiom admit : forall {T}, T.\nSet Implicit Arguments.\nGeneralizable All Variables.\nReserved Notation \"g 'o' f\" (at level 40, left associativity).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where \"a = b\" := (@ paths _ a b) : type_scope.\nArguments idpath {A a} , [A] a.\nDefinition apD10 {A} {B:A->Type} {f g : forall x, B x} (h:f=g) : forall x, f x = g x := fun x => match h with idpath => idpath end.\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv { equiv_inv : B -> A }.\nDelimit Scope equiv_scope with equiv.\nLocal Open Scope equiv_scope.\nNotation \"f ^-1\" := (@ equiv_inv _ _ f _) (at level 3) : equiv_scope.\nClass Funext := { isequiv_apD10 :> forall (A : Type) (P : A -> Type) f g, IsEquiv (@ apD10 A P f g) }.\nDefinition path_forall `{Funext} {A : Type} {P : A -> Type} (f g : forall x : A, P x) : (forall x, f x = g x) -> f = g := (@ apD10 A P\\\n f g)^-1.\nRecord PreCategory :=\n  { object :> Type;\n    morphism : object -> object -> Type;\n    compose : forall s d d', morphism d d' -> morphism s d -> morphism s d' where \"f 'o' g\" := (compose f g);\n    associativity : forall x1 x2 x3 x4 (m1 : morphism x1 x2) (m2 : morphism x2 x3) (m3 : morphism x3 x4), (m3 o m2) o m1 = m3 o (m2 o\\\n m1)\n  }.\nBind Scope category_scope with PreCategory.\nBind Scope morphism_scope with morphism.\nInfix \"o\" := (@ compose _ _ _ _) : morphism_scope.\nDelimit Scope functor_scope with functor.\nRecord Functor (C D : PreCategory) :=\n  { object_of :> C -> D;\n    morphism_of : forall s d, morphism C s d -> morphism D (object_of s) (object_of d) }.\nBind Scope functor_scope with Functor.\nNotation \"F '_1' m\" := (@ morphism_of _ _ F _ _ m) (at level 10, no associativity) : morphism_scope.\nClass IsIsomorphism {C : PreCategory} {s d} (m : morphism C s d) := { morphism_inverse : morphism C d s }.\nLocal Notation \"m ^-1\" := (morphism_inverse (m := m)) : morphism_scope.\nClass Isomorphic {C : PreCategory} s d :=\n  { morphism_isomorphic :> morphism C s d;\n    isisomorphism_isomorphic :> IsIsomorphism morphism_isomorphic }.\nCoercion morphism_isomorphic : Isomorphic >-> morphism.\nDefinition isisomorphism_inverse `(@ IsIsomorphism C x y m) : IsIsomorphism m^-1 := {| morphism_inverse := m |}.\n\nGlobal Instance isisomorphism_compose `(@ IsIsomorphism C y z m0) `(@ IsIsomorphism C x y m1) : IsIsomorphism (m0 o m1).\nAdmitted.\nInfix \"<~=~>\" := Isomorphic (at level 70, no associativity) : category_scope.\nDefinition composef C D E (G : Functor D E) (F : Functor C D) : Functor C E\n  := Build_Functor\n       C E\n       (fun c => G (F c))\n       (fun _ _ m => @ morphism_of _ _ G _ _ (@ morphism_of _ _ F _ _ m)).\nInfix \"o\" := composef : functor_scope.\nDelimit Scope natural_transformation_scope with natural_transformation.\n\nLocal Open Scope morphism_scope.\nRecord NaturalTransformation C D (F G : Functor C D) :=\n  { components_of :> forall c, morphism D (F c) (G c);\n    commutes : forall s d (m : morphism C s d), components_of d o F _1 m = G _1 m o components_of s }.\n\nDefinition composet C D (F F' F'' : Functor C D) (T' : NaturalTransformation F' F'') (T : NaturalTransformation F F')\n: NaturalTransformation F F''\n  := Build_NaturalTransformation F F'' (fun c => T' c o T c) admit.\nInfix \"o\" := composet : natural_transformation_scope.\nSection path_natural_transformation.\n  Context `{Funext}.\n  Variable C : PreCategory.\n  Variable D : PreCategory.\n  Variables F G : Functor C D.\n  Section path.\n    Variables T U : NaturalTransformation F G.\n    Lemma path'_natural_transformation\n    : components_of T = components_of U\n      -> T = U.\n      admit.\n    Defined.\n    Lemma path_natural_transformation\n    : (forall x, components_of T x = components_of U x)\n      -> T = U.\n    Proof.\n      intros.\n      apply path'_natural_transformation.\n      apply path_forall; assumption.\n    Qed.\n  End path.\nEnd path_natural_transformation.\nLtac path_natural_transformation :=\n  repeat match goal with\n           | _ => intro\n           | _ => apply path_natural_transformation; simpl\n         end.\n\nLocal Open Scope natural_transformation_scope.\nDefinition associativityt `{fs : Funext}\n           C D F G H I\n           (V : @ NaturalTransformation C D F G)\n           (U : @ NaturalTransformation C D G H)\n           (T : @ NaturalTransformation C D H I)\n: (T o U) o V = T o (U o V).\nProof.\n  path_natural_transformation.\n  apply associativity.\nQed.\nDefinition functor_category `{Funext} (C D : PreCategory) : PreCategory\n  := @ Build_PreCategory (Functor C D) (@ NaturalTransformation C D) (@ composet C D) (@ associativityt _ C D).\nNotation \"C -> D\" := (functor_category C D) : category_scope.\nDefinition NaturalIsomorphism `{Funext} (C D : PreCategory) F G := @ Isomorphic (C -> D) F G.\nInfix \"<~=~>\" := NaturalIsomorphism : natural_transformation_scope.\nGlobal Instance isisomorphism_compose' `{Funext}\n       `(T' : @ NaturalTransformation C D F' F'')\n       `(T : @ NaturalTransformation C D F F')\n       `{@ IsIsomorphism (C -> D) F' F'' T'}\n       `{@ IsIsomorphism (C -> D) F F' T}\n: @ IsIsomorphism (C -> D) F F'' (T' o T)%natural_transformation\n  := @ isisomorphism_compose (C -> D) _ _ T' _ _ T _.\nSection lemmas.\n  Context `{Funext}.\n  Variable C : PreCategory.\n  Variable F : C -> PreCategory.\n  Context\n    {w y z}\n    {f : Functor (F w) (F z)} {f0 : Functor (F w) (F y)}\n    {f2 : Functor (F y) (F z)}\n    {f5 : Functor (F w) (F z)}\n    {n2 : f <~=~> (f2 o f0)%functor}.\n  Lemma p_composition_of_coherent_iso_for_rewrite__isisomorphism_helper' XX\n  : @ IsIsomorphism\n      (F w -> F z) f5 f\n      (n2 ^-1 o XX)%natural_transformation.\n  Proof.\n    eapply isisomorphism_compose'.\n    eapply isisomorphism_inverse. (* Toplevel input, characters 22-43:\nError:\nIn environment\nH : Funext\nC : PreCategory\nF : C -> PreCategory\nw : C\ny : C\nz : C\nf : Functor (F w) (F z)\nf0 : Functor (F w) (F y)\nf2 : Functor (F y) (F z)\nf5 : Functor (F w) (F z)\nn2 : f <~=~> (f2 o f0)%functor\nXX : NaturalTransformation f5 (f2 o f0)\nUnable to unify\n \"{|\n  object := Functor (F w) (F z);\n  morphism := NaturalTransformation (D:=F z);\n  compose := composet (D:=F z);\n  associativity := associativityt (D:=F z) |}\" with\n \"{|\n  object := Functor (F w) (F z);\n  morphism := NaturalTransformation (D:=F z);\n  compose := composet (D:=F z);\n  associativity := associativityt (D:=F z) |}\". *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520525/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]