[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337531446","html_url":"https://github.com/coq/coq/issues/4057#issuecomment-337531446","issue_url":"https://api.github.com/repos/coq/coq/issues/4057","id":337531446,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMTQ0Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-02-17T21:08:28Z","updated_at":"2017-10-18T09:52:47Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n(* File reduced by coq-bug-finder from original input, then from 6051 lines to \n233 lines, then from 210 lines to 194 lines *)\n(* coqc version 8.4pl5 (December 2014) compiled on Dec 28 2014 03:23:16 with \nOCaml 4.01.0\n   coqtop version 8.4pl5 (December 2014) *)\nRequire Coq.Strings.String.\n\nSet Implicit Arguments.\n\nReserved Notation \"[ x ]\".\n\nRecord string_like (CharType : Type) :=\n  {\n    String :> Type;\n    Singleton : CharType -> String where \"[ x ]\" := (Singleton x);\n    Empty : String;\n    Concat : String -> String -> String where \"x ++ y\" := (Concat x y);\n    bool_eq : String -> String -> bool;\n    bool_eq_correct : forall x y : String, bool_eq x y = true <-> x = y;\n    Length : String -> nat\n  }.\n\nDelimit Scope string_like_scope with string_like.\nBind Scope string_like_scope with String.\nArguments Length {_%type_scope _} _%string_like.\nInfix \"++\" := (@ Concat _ _) : string_like_scope.\n\nDefinition str_le {CharType} {String : string_like CharType} (s1 s2 : String)\n  := Length s1 < Length s2 \\/ s1 = s2.\nInfix \"â‰¤s\" := str_le (at level 70, right associativity).\n\nModule Export ContextFreeGrammar.\n  Import Coq.Strings.String.\n  Import Coq.Lists.List.\n\n  Section cfg.\n    Variable CharType : Type.\n\n    Section definitions.\n\n      Inductive item :=\n    | NonTerminal (name : string).\n\n      Definition production := list item.\n      Definition productions := list production.\n\n      Record grammar :=\n        {\n          Start_symbol :> string;\n          Lookup :> string -> productions\n        }.\n    End definitions.\n\n    Section parse.\n      Variable String : string_like CharType.\n      Variable G : grammar.\n\n      Inductive parse_of : String -> productions -> Type :=\n      | ParseHead : forall str pat pats, parse_of_production str pat\n                                         -> parse_of str (pat::pats)\n      | ParseTail : forall str pat pats, parse_of str pats\n                                         -> parse_of str (pat::pats)\n      with parse_of_production : String -> production -> Type :=\n      | ParseProductionCons : forall str pat strs pats,\n                                parse_of_item str pat\n                                -> parse_of_production strs pats\n                                -> parse_of_production (str ++ strs) (pat::pats)\n      with parse_of_item : String -> item -> Type :=\n      | ParseNonTerminal : forall name str, parse_of str (Lookup G name)\n                                            -> parse_of_item str (NonTerminal \nname).\n    End parse.\n  End cfg.\n\nEnd ContextFreeGrammar.\nModule Export ContextFreeGrammarProperties.\n\n  Section cfg.\n    Context CharType (String : string_like CharType) (G : grammar)\n            (P : String.string -> Type).\n\n    Fixpoint Forall_parse_of {str pats} (p : parse_of String G str pats)\n      := match p with\n           | ParseHead str pat pats p'\n             => Forall_parse_of_production p'\n           | ParseTail _ _ _ p'\n             => Forall_parse_of p'\n         end\n    with Forall_parse_of_production {str pat} (p : parse_of_production String G \nstr pat)\n         := let Forall_parse_of_item {str it} (p : parse_of_item String G str \nit)\n                := match p return Type with\n                     | ParseNonTerminal name str p'\n                       => (P name * Forall_parse_of p')%type\n                   end in\n            match p return Type with\n              | ParseProductionCons str pat strs pats p' p''\n                => (Forall_parse_of_item p' * Forall_parse_of_production \np'')%type\n            end.\n\n    Definition Forall_parse_of_item {str it} (p : parse_of_item String G str it)\n      := match p return Type with\n           | ParseNonTerminal name str p'\n             => (P name * Forall_parse_of p')%type\n         end.\n  End cfg.\n\nEnd ContextFreeGrammarProperties.\n\nModule Export DependentlyTyped.\n  Import Coq.Strings.String.\n\n  Section recursive_descent_parser.\n\n    Class parser_computational_predataT :=\n      { nonterminal_names_listT : Type;\n        initial_nonterminal_names_data : nonterminal_names_listT;\n        is_valid_nonterminal_name : nonterminal_names_listT -> string -> bool;\n        remove_nonterminal_name : nonterminal_names_listT -> string -> \nnonterminal_names_listT }.\n\n  End recursive_descent_parser.\n\nEnd DependentlyTyped.\nImport Coq.Strings.String.\nImport Coq.Lists.List.\n\nSection cfg.\n  Context CharType (String : string_like CharType) (G : grammar).\n  Context (names_listT : Type)\n          (initial_names_data : names_listT)\n          (is_valid_name : names_listT -> string -> bool)\n          (remove_name : names_listT -> string -> names_listT).\n\n  Inductive minimal_parse_of\n  : forall (str0 : String) (valid : names_listT)\n           (str : String),\n      productions -> Type :=\n  | MinParseHead : forall str0 valid str pat pats,\n                     @ minimal_parse_of_production str0 valid str pat\n                     -> @ minimal_parse_of str0 valid str (pat::pats)\n  | MinParseTail : forall str0 valid str pat pats,\n                     @ minimal_parse_of str0 valid str pats\n                     -> @ minimal_parse_of str0 valid str (pat::pats)\n  with minimal_parse_of_production\n       : forall (str0 : String) (valid : names_listT)\n                (str : String),\n           production -> Type :=\n  | MinParseProductionNil : forall str0 valid,\n                              @ minimal_parse_of_production str0 valid (Empty _) \nnil\n  | MinParseProductionCons : forall str0 valid str strs pat pats,\n                               str ++ strs â‰¤s str0\n                               -> @ minimal_parse_of_item str0 valid str pat\n                               -> @ minimal_parse_of_production str0 valid strs \npats\n                               -> @ minimal_parse_of_production str0 valid (str \n++ strs) (pat::pats)\n  with minimal_parse_of_item\n       : forall (str0 : String) (valid : names_listT)\n                (str : String),\n           item -> Type :=\n  | MinParseNonTerminal\n    : forall str0 valid str name,\n        @ minimal_parse_of_name str0 valid str name\n        -> @ minimal_parse_of_item str0 valid str (NonTerminal name)\n  with minimal_parse_of_name\n       : forall (str0 : String) (valid : names_listT)\n                (str : String),\n           string -> Type :=\n  | MinParseNonTerminalStrLt\n    : forall str0 valid name str,\n        @ minimal_parse_of str initial_names_data str (Lookup G name)\n        -> @ minimal_parse_of_name str0 valid str name\n  | MinParseNonTerminalStrEq\n    : forall str valid name,\n        @ minimal_parse_of str (remove_name valid name) str (Lookup G name)\n        -> @ minimal_parse_of_name str valid str name.\n  Definition parse_of_item_name__of__minimal_parse_of_name\n  : forall {str0 valid str name} (p : @ minimal_parse_of_name str0 valid str \nname),\n      parse_of_item String G str (NonTerminal name).\n    admit.\n  Defined.\n\nEnd cfg.\n\nSection recursive_descent_parser.\n  Context (CharType : Type)\n          (String : string_like CharType)\n          (G : grammar).\n  Context {premethods : parser_computational_predataT}.\n  Let P : string -> Prop.\n    admit.\n  Defined.\n\n  Let mp_parse_nonterminal_name str0 valid str nonterminal_name\n    := { p' : minimal_parse_of_name String G initial_nonterminal_names_data \nremove_nonterminal_name str0 valid str nonterminal_name & Forall_parse_of_item \nP (parse_of_item_name__of__minimal_parse_of_name p') }.\n\n  Goal False.\n    clear -mp_parse_nonterminal_name.\n    subst P.\n    simpl in *.\n    admit. (* Anomaly: Cannot take the successor of a non variable universe:\n(maybe a bugged tactic).\nPlease report.\n *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337531446/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337531447","html_url":"https://github.com/coq/coq/issues/4057#issuecomment-337531447","issue_url":"https://api.github.com/repos/coq/coq/issues/4057","id":337531447,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMTQ0Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-06-02T17:13:48Z","updated_at":"2017-10-18T09:52:48Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nSeems fixed in trunk.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337531447/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]