[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337545793","html_url":"https://github.com/coq/coq/issues/4977#issuecomment-337545793","issue_url":"https://api.github.com/repos/coq/coq/issues/4977","id":337545793,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NTc5Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-07-29T23:10:42Z","updated_at":"2021-06-04T01:15:46Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nGiven the fact that explicit unfolding speeds up the code by 10x, I suspect \r\nsomething in the refolding machinery?\r\n\r\nThis is with Coq 8.6 dabe6d0e1d1782d3e9647e04aa1bf161765ad882.\r\n\r\n```coq\r\nRequire Import Coq.ZArith.Zpower Coq.ZArith.Znumtheory Coq.ZArith.ZArith \r\nCoq.ZArith.Zdiv.\r\nRequire Import Coq.Classes.RelationClasses Coq.Classes.Morphisms.\r\nRequire Import Coq.Structures.Equalities.\r\nRequire Import Coq.omega.Omega Coq.micromega.Psatz \r\nCoq.Numbers.Natural.Peano.NPeano Coq.Arith.Arith.\r\n\r\nCreate HintDb push_Zmod discriminated.\r\n\r\nLocal Open Scope Z.\r\n\r\nLemma mul_mod_l a b n : n <> 0 -> (a * b) mod n = ((a mod n) * b) mod n.\r\nProof.\r\n  intros; rewrite (Z.mul_mod a b), (Z.mul_mod (a mod n) b) by lia.\r\n  rewrite Z.mod_mod by lia; lia.\r\nQed.\r\n\r\nLemma mul_mod_r a b n : n <> 0 -> (a * b) mod n = (a * (b mod n)) mod n.\r\nProof.\r\n  intros; rewrite (Z.mul_mod a b), (Z.mul_mod a (b mod n)) by lia.\r\n  rewrite Z.mod_mod by lia; lia.\r\nQed.\r\n\r\nLemma add_mod_l a b n : n <> 0 -> (a + b) mod n = ((a mod n) + b) mod n.\r\nProof.\r\n  intros; rewrite (Z.add_mod a b), (Z.add_mod (a mod n) b) by lia.\r\n  rewrite Z.mod_mod by lia; lia.\r\nQed.\r\n\r\nLemma add_mod_r a b n : n <> 0 -> (a + b) mod n = (a + (b mod n)) mod n.\r\nProof.\r\n  intros; rewrite (Z.add_mod a b), (Z.add_mod a (b mod n)) by lia.\r\n  rewrite Z.mod_mod by lia; lia.\r\nQed.\r\n\r\nDefinition NoZMod (x : Z) := True.\r\nLtac NoZMod :=\r\n  lazymatch goal with\r\n  | [ |- NoZMod (?x mod ?y) ] => fail 0 \"Goal has\" x \"mod\" y\r\n  | [ |- NoZMod _ ] => constructor\r\n  end.\r\n\r\nLemma mul_mod_push a b n : n <> 0 -> NoZMod a -> NoZMod b -> (a * b) mod n = \r\n((a mod n) * (b mod n)) mod n.\r\nProof. intros; apply Z.mul_mod; assumption. Qed.\r\nHint Rewrite mul_mod_push using solve [ NoZMod | lia ] : push_Zmod.\r\n\r\nLemma add_mod_push a b n : n <> 0 -> NoZMod a -> NoZMod b -> (a + b) mod n = \r\n((a mod n) + (b mod n)) mod n.\r\nProof. intros; apply Z.add_mod; assumption. Qed.\r\nHint Rewrite add_mod_push using solve [ NoZMod | lia ] : push_Zmod.\r\n\r\nLemma mul_mod_l_push a b n : n <> 0 -> NoZMod a -> (a * b) mod n = ((a mod n) * \r\nb) mod n.\r\nProof. intros; apply mul_mod_l; assumption. Qed.\r\nHint Rewrite mul_mod_l_push using solve [ NoZMod | lia ] : push_Zmod.\r\n\r\nLemma mul_mod_r_push a b n : n <> 0 -> NoZMod b -> (a * b) mod n = (a * (b mod \r\nn)) mod n.\r\nProof. intros; apply mul_mod_r; assumption. Qed.\r\nHint Rewrite mul_mod_r_push using solve [ NoZMod | lia ] : push_Zmod.\r\n\r\nLemma add_mod_l_push a b n : n <> 0 -> NoZMod a -> (a + b) mod n = ((a mod n) + \r\nb) mod n.\r\nProof. intros; apply add_mod_l; assumption. Qed.\r\nHint Rewrite add_mod_l_push using solve [ NoZMod | lia ] : push_Zmod.\r\n\r\nLemma add_mod_r_push a b n : n <> 0 -> NoZMod b -> (a + b) mod n = (a + (b mod \r\nn)) mod n.\r\nProof. intros; apply add_mod_r; assumption. Qed.\r\nHint Rewrite add_mod_r_push using solve [ NoZMod | lia ] : push_Zmod.\r\n\r\nLemma sub_mod_push a b n : n <> 0 -> NoZMod a -> NoZMod b -> (a - b) mod n = \r\n((a mod n) - (b mod n)) mod n.\r\nProof. intros; apply Zminus_mod; assumption. Qed.\r\nHint Rewrite sub_mod_push using solve [ NoZMod | lia ] : push_Zmod.\r\n\r\nLemma sub_mod_l_push a b n : n <> 0 -> NoZMod a -> (a - b) mod n = ((a mod n) - \r\nb) mod n.\r\nProof. intros; symmetry; apply Zminus_mod_idemp_l; assumption. Qed.\r\nHint Rewrite sub_mod_l_push using solve [ NoZMod | lia ] : push_Zmod.\r\n\r\nLemma sub_mod_r_push a b n : n <> 0 -> NoZMod b -> (a - b) mod n = (a - (b mod \r\nn)) mod n.\r\nProof. intros; symmetry; apply Zminus_mod_idemp_r; assumption. Qed.\r\nHint Rewrite sub_mod_r_push using solve [ NoZMod | lia ] : push_Zmod.\r\n\r\nSection equiv_modulo.\r\n  Context (N : Z).\r\n  Definition equiv_modulo x y := x mod N = y mod N.\r\n  Local Infix \"==\" := equiv_modulo (at level 70, no associativity).\r\n\r\n  Local Instance equiv_modulo_Reflexive : Reflexive equiv_modulo := fun _ => \r\nLogic.eq_refl.\r\n  Local Instance equiv_modulo_Symmetric : Symmetric equiv_modulo := fun _ _ => \r\n@ Logic.eq_sym _ _ _.\r\n  Local Instance equiv_modulo_Transitive : Transitive equiv_modulo := fun _ _ _ \r\n=> @ Logic.eq_trans _ _ _ _.\r\n\r\n  Lemma mul_mod_Proper : Proper (equiv_modulo ==> equiv_modulo ==> \r\nequiv_modulo) Z.mul.\r\n  Admitted.\r\n\r\n  Lemma add_mod_Proper : Proper (equiv_modulo ==> equiv_modulo ==> \r\nequiv_modulo) Z.add.\r\n  Admitted.\r\n\r\n  Lemma sub_mod_Proper : Proper (equiv_modulo ==> equiv_modulo ==> \r\nequiv_modulo) Z.sub.\r\n  Admitted.\r\n\r\n  Lemma opp_mod_Proper : Proper (equiv_modulo ==> equiv_modulo) Z.opp.\r\n  Admitted.\r\n\r\n  Lemma modulo_equiv_modulo_Proper\r\n    : Proper (equiv_modulo ==> (fun x y => x = N /\\ N = y) ==> Logic.eq) \r\nZ.modulo.\r\n  Proof.\r\n    repeat intro; hnf in *; intuition congruence.\r\n  Qed.\r\n  Lemma eq_to_ProperProxy : ProperProxy (fun x y : Z => x = N /\\ N = y) N.\r\n  Proof. split; reflexivity. Qed.\r\nEnd equiv_modulo.\r\n\r\nModule Import EquivModuloInstances.\r\n  Existing Instance equiv_modulo_Reflexive.\r\n  Existing Instance equiv_modulo_Symmetric.\r\n  Existing Instance equiv_modulo_Transitive.\r\n  Existing Instance mul_mod_Proper.\r\n  Existing Instance add_mod_Proper.\r\n  Existing Instance sub_mod_Proper.\r\n  Existing Instance opp_mod_Proper.\r\n  Existing Instance modulo_equiv_modulo_Proper.\r\n  Existing Instance eq_to_ProperProxy.\r\nEnd EquivModuloInstances.\r\n\r\n\r\nGoal forall T N' R N R', N <> 0 -> 0 < R -> equiv_modulo N ((T + (T * N') mod R \r\n* N - (T + (T * N') mod R * N) mod R) * R' - N * R * R') (T * R').\r\nProof.\r\n  intros.\r\n  Time (autorewrite with push_Zmod; rewrite_strat topdown hints push_Zmod). (* \r\nFinished transaction in 0.376 secs (0.375u,0.s) (successful) *)\r\n  match goal with\r\n  | |- equiv_modulo N\r\n    ((T + (T mod R * (N' mod R)) mod R * N -\r\n      (T mod R + ((T mod R * (N' mod R)) mod R * (N mod R)) mod R) mod R) * R' \r\n- \r\n     N * R * R') (T * R') => idtac end.\r\n  Undo 2.\r\n  Time (unfold equiv_modulo; rewrite_strat topdown hints push_Zmod). (* \r\nFinished transaction in 1.279 secs (1.274u,0.004s) (successful) *)\r\n  Undo.\r\n  Time (unfold equiv_modulo; autorewrite with push_Zmod; rewrite_strat topdown \r\nhints push_Zmod). (* Finished transaction in 1.418 secs (1.413u,0.s) \r\n(successful) *)\r\n  Undo.\r\n  Time rewrite_strat topdown hints push_Zmod. (* Finished transaction in 9.542 \r\nsecs (9.528u,0.s) (successful) *)\r\n  match goal with\r\n  | |- equiv_modulo N\r\n    ((T + (T mod R * (N' mod R)) mod R * N -\r\n      (T mod R + ((T mod R * (N' mod R)) mod R * (N mod R)) mod R) mod R) * R' \r\n- \r\n     N * R * R') (T * R') => idtac end.\r\n\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337545793/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]