[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337518306","html_url":"https://github.com/coq/coq/issues/3263#issuecomment-337518306","issue_url":"https://api.github.com/repos/coq/coq/issues/3263","id":337518306,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxODMwNg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-03-24T18:09:54Z","updated_at":"2017-10-18T09:14:54Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI would like to be able to control the evaluation strategy of [Defined].  In particular, sometimes, [simpl in *; exact H.] is almost instantaneous, while [exact H] takes an extremely long time (on the order of minutes, if not more).  However, [Defined] will take a very long time.  So I would like to have [Defined] \"remember\" the evaluation strategy of the proof script, or, at least, be able to say \"for this proof, when checking things in the kernel, if they don't unify, first try [simpl], and if they still don't unify, then go ahead and unfold things in the default order\".\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337518306/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337518308","html_url":"https://github.com/coq/coq/issues/3263#issuecomment-337518308","issue_url":"https://api.github.com/repos/coq/coq/issues/3263","id":337518308,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxODMwOA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-03-27T17:02:08Z","updated_at":"2017-11-18T23:38:48Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nHere is an example where [Defined] takes well over a minute, but the corresponding [exact] takes well under a tenth of a second, and a trick with identity functions which brings the total time ([exact] + [Defined]) to around a second:\r\n``` coq\r\n(* File reduced by coq-bug-finder from originally 10918 lines, then 3649 lines to 3177 lines, then from 3189 lines to 3164 lines, then from 2653 lines to 2496 lines,  2653 lines, then from 1642 lines to 651 lines, then from 736 lines to 473 lines, then from 433 lines to 275 lines, then from 258 lines to 235 lines. *)\r\nGeneralizable All Variables.\r\nSet Implicit Arguments.\r\n\r\nArguments fst {_ _} _.\r\nArguments snd {_ _} _.\r\n\r\nAxiom cheat : forall {T}, T.\r\n\r\nReserved Notation \"g 'o' f\" (at level 40, left associativity).\r\n\r\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\r\nArguments idpath {A a} , [A] a.\r\nNotation \"x = y\" := (paths x y) : type_scope.\r\n\r\nDefinition symmetry {A : Type} {x y : A} (p : x = y) : y = x\r\n  := match p with idpath => idpath end.\r\n\r\nDelimit Scope morphism_scope with morphism.\r\nDelimit Scope category_scope with category.\r\nDelimit Scope object_scope with object.\r\nRecord PreCategory (object : Type) :=\r\n  Build_PreCategory' {\r\n      object :> Type := object;\r\n      morphism : object -> object -> Type;\r\n      identity : forall x, morphism x x;\r\n      compose : forall s d d',\r\n                  morphism d d'\r\n                  -> morphism s d\r\n                  -> morphism s d'\r\n                              where \"f 'o' g\" := (compose f g);\r\n      associativity : forall x1 x2 x3 x4\r\n                             (m1 : morphism x1 x2)\r\n                             (m2 : morphism x2 x3)\r\n                             (m3 : morphism x3 x4),\r\n                        (m3 o m2) o m1 = m3 o (m2 o m1);\r\n      associativity_sym : forall x1 x2 x3 x4\r\n                                 (m1 : morphism x1 x2)\r\n                                 (m2 : morphism x2 x3)\r\n                                 (m3 : morphism x3 x4),\r\n                            m3 o (m2 o m1) = (m3 o m2) o m1;\r\n      left_identity : forall a b (f : morphism a b), identity b o f = f;\r\n      right_identity : forall a b (f : morphism a b), f o identity a = f;\r\n      identity_identity : forall x, identity x o identity x = identity x\r\n    }.\r\nBind Scope category_scope with PreCategory.\r\nArguments PreCategory {_}.\r\nArguments identity {_} [!C%category] x%object : rename.\r\n\r\nArguments compose {_} [!C%category s%object d%object d'%object] m1%morphism m2%morphism : rename.\r\n\r\nInfix \"o\" := compose : morphism_scope.\r\n\r\nDelimit Scope functor_scope with functor.\r\nLocal Open Scope morphism_scope.\r\nRecord Functor `(C : @ PreCategory objC, D : @ PreCategory objD) :=\r\n  {\r\n    object_of :> C -> D;\r\n    morphism_of : forall s d, morphism C s d\r\n                              -> morphism D (object_of s) (object_of d);\r\n    composition_of : forall s d d'\r\n                            (m1 : morphism C s d) (m2: morphism C d d'),\r\n                       morphism_of _ _ (m2 o m1)\r\n                       = (morphism_of _ _ m2) o (morphism_of _ _ m1);\r\n    identity_of : forall x, morphism_of _ _ (identity x)\r\n                            = identity (object_of x)\r\n  }.\r\nBind Scope functor_scope with Functor.\r\n\r\nArguments morphism_of {_} [C%category] {_} [D%category] F%functor [s%object d%object] m%morphism : rename, simpl nomatch.\r\n\r\nNotation \"F '_1' m\" := (morphism_of F m) (at level 10, no associativity) : morphism_scope.\r\n\r\nClass IsIsomorphism `{C : @ PreCategory objC} {s d} (m : morphism C s d) :=\r\n  {\r\n    morphism_inverse : morphism C d s;\r\n    left_inverse : morphism_inverse o m = identity _;\r\n    right_inverse : m o morphism_inverse = identity _\r\n  }.\r\n\r\nDefinition opposite `(C : @ PreCategory objC) : PreCategory\r\n  := @ Build_PreCategory'\r\n       C\r\n       (fun s d => morphism C d s)\r\n       (identity (C := C))\r\n       (fun _ _ _ m1 m2 => m2 o m1)\r\n       (fun _ _ _ _ _ _ _ => @ associativity_sym _ _ _ _ _ _ _ _ _)\r\n       (fun _ _ _ _ _ _ _ => @ associativity _ _ _ _ _ _ _ _ _)\r\n       (fun _ _ => @ right_identity _ _ _ _)\r\n       (fun _ _ => @ left_identity _ _ _ _)\r\n       (@ identity_identity _ C).\r\n\r\nNotation \"C ^op\" := (opposite C) (at level 3) : category_scope.\r\n\r\nDefinition prod `(C : @ PreCategory objC, D : @ PreCategory objD) : @ PreCategory (objC * objD).\r\n  refine (@ Build_PreCategory'\r\n            (C * D)%type\r\n            (fun s d => (morphism C (fst s) (fst d)\r\n                         * morphism D (snd s) (snd d))%type)\r\n            (fun x => (identity (fst x), identity (snd x)))\r\n            (fun s d d' m2 m1 => (fst m2 o fst m1, snd m2 o snd m1))\r\n            _\r\n            _\r\n            _\r\n            _\r\n            _); admit.\r\nDefined.\r\nInfix \"*\" := prod : category_scope.\r\n\r\nDefinition compose_functor `(C : @ PreCategory objC, D : @ PreCategory objD, E : @ PreCategory objE) (G : Functor D E) (F : Functor C D) : Functor C E\r\n  := Build_Functor\r\n       C E\r\n       (fun c => G (F c))\r\n       (fun _ _ m => morphism_of G (morphism_of F m))\r\n       cheat\r\n       cheat.\r\n\r\nInfix \"o\" := compose_functor : functor_scope.\r\n\r\nRecord NaturalTransformation `(C : @ PreCategory objC, D : @ PreCategory objD) (F G : Functor C D) :=\r\n  Build_NaturalTransformation' {\r\n      components_of :> forall c, morphism D (F c) (G c);\r\n      commutes : forall s d (m : morphism C s d),\r\n                   components_of d o F _1 m = G _1 m o components_of s;\r\n\r\n      commutes_sym : forall s d (m : C.(morphism) s d),\r\n                       G _1 m o components_of s = components_of d o F _1 m\r\n    }.\r\nDefinition functor_category `(C : @ PreCategory objC, D : @ PreCategory objD) : PreCategory\r\n  := @ Build_PreCategory' (Functor C D)\r\n                         (@ NaturalTransformation _ C _ D)\r\n                         cheat\r\n                         cheat\r\n                         cheat\r\n                         cheat\r\n                         cheat\r\n                         cheat\r\n                         cheat.\r\n\r\nDefinition opposite_functor `(F : @ Functor objC C objD D) : Functor C^op D^op\r\n  := Build_Functor (C^op) (D^op)\r\n                   (object_of F)\r\n                   (fun s d => morphism_of F (s := d) (d := s))\r\n                   (fun d' d s m1 m2 => composition_of F s d d' m2 m1)\r\n                   (identity_of F).\r\n\r\nDefinition opposite_invL `(F : @ Functor objC C^op objD D) : Functor C D^op\r\n  := Build_Functor C (D^op)\r\n                   (object_of F)\r\n                   (fun s d => morphism_of F (s := d) (d := s))\r\n                   (fun d' d s m1 m2 => composition_of F s d d' m2 m1)\r\n                   (identity_of F).\r\nNotation \"F ^op\" := (opposite_functor F) : functor_scope.\r\n\r\nNotation \"F ^op'L\" := (opposite_invL F) (at level 3) : functor_scope.\r\nDefinition fst `{C : @ PreCategory objC, D : @ PreCategory objD} : Functor (C * D) C\r\n  := Build_Functor (C * D) C\r\n                   (@ fst _ _)\r\n                   (fun _ _ => @ fst _ _)\r\n                   (fun _ _ _ _ _ => idpath)\r\n                   (fun _ => idpath).\r\n\r\nDefinition snd `{C : @ PreCategory objC, D : @ PreCategory objD} : Functor (C * D) D\r\n  := Build_Functor (C * D) D\r\n                   (@ snd _ _)\r\n                   (fun _ _ => @ snd _ _)\r\n                   (fun _ _ _ _ _ => idpath)\r\n                   (fun _ => idpath).\r\nDefinition prod_functor `(F : @ Functor objC C objD D, F' : @ Functor objC C objD' D')\r\n: Functor C (D * D')\r\n  := Build_Functor\r\n       C (D * D')\r\n       (fun c => (F c, F' c))\r\n       (fun s d m => (F _1 m, F' _1 m))%morphism\r\n       cheat\r\n       cheat.\r\nDefinition pair `(F : @ Functor objC C objD D, F' : @ Functor objC' C' objD' D') : Functor (C * C') (D * D')\r\n  := (prod_functor (F o fst) (F' o snd))%functor.\r\nNotation cat_of obj :=\r\n  (@ Build_PreCategory' obj\r\n                       (fun x y => forall _ : x, y)\r\n                       (fun _ x => x)\r\n                       (fun _ _ _ f g x => f (g x))%core\r\n                       (fun _ _ _ _ _ _ _ => idpath)\r\n                       (fun _ _ _ _ _ _ _ => idpath)\r\n                       (fun _ _ _ => idpath)\r\n                       (fun _ _ _ => idpath)\r\n                       (fun _ => idpath)).\r\n\r\nDefinition hom_functor `(C : @ PreCategory objC) : Functor (C^op * C) (cat_of Type)\r\n  := Build_Functor _ _ cheat cheat cheat cheat.\r\n\r\nDefinition induced_hom_natural_transformation `(F : @ Functor objC C objD D)\r\n: NaturalTransformation (hom_functor C) (hom_functor D o pair F^op F)\r\n  := Build_NaturalTransformation' _ _ cheat cheat cheat.\r\n\r\nClass IsFullyFaithful `(F : @ Functor objC C objD D)\r\n  := is_fully_faithful\r\n     : forall x y : C,\r\n         IsIsomorphism (induced_hom_natural_transformation F (x, y)).\r\n\r\nDefinition coyoneda `(A : @ PreCategory objA) : Functor A^op (@ functor_category _ A _ (cat_of Type))\r\n  := cheat.\r\n\r\nDefinition yoneda `(A : @ PreCategory objA) : Functor A (@ functor_category _ A^op _ (cat_of Type))\r\n  := (((coyoneda A^op)^op'L)^op'L)%functor.\r\nDefinition coyoneda_embedding `(A : @ PreCategory objA) : @ IsFullyFaithful _ _ _ _ (@ coyoneda _ A).\r\nAdmitted.\r\n\r\nDefinition yoneda_embedding_fast `(A : @ PreCategory objA) : @ IsFullyFaithful _ _ _ _ (@ yoneda _ A).\r\nProof.\r\n  intros a b.\r\n  pose proof (coyoneda_embedding A^op a b) as CYE.\r\n  unfold yoneda.\r\n  Time let t := (type of CYE) in\r\n  let t' := (eval simpl in t) in pose proof ((fun (x : t) => (x : t')) CYE) as CYE'. (* Finished transaction in 0. secs (0.216013u,0.004s) *)\r\n  Time let t := match goal with |- ?G => constr:(G) end in\r\n  let t' := (eval simpl in t) in exact ((fun (x : t') => (x : t)) CYE'). (* Finished transaction in 0. secs (0.248016u,0.s) *)\r\nTime Defined. (* Finished transaction in 1. secs (0.432027u,0.s) *)\r\n\r\nDefinition yoneda_embedding `(A : @ PreCategory objA) : @ IsFullyFaithful _ _ _ _ (@ yoneda _ A).\r\nProof.\r\n  intros a b.\r\n  pose proof (coyoneda_embedding A^op a b) as CYE.\r\n  unfold yoneda; simpl in *.\r\n  Time exact CYE. (* Finished transaction in 0. secs (0.012001u,0.s) *)\r\nTimeout 60 Defined. (* Timeout! *)\r\n\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337518308/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337518313","html_url":"https://github.com/coq/coq/issues/3263#issuecomment-337518313","issue_url":"https://api.github.com/repos/coq/coq/issues/3263","id":337518313,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxODMxMw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-06-23T00:16:26Z","updated_at":"2017-10-18T09:14:54Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nThe first [Time .. exact] now takes 11.904 secs, and the Defined takes 12.369 secs.  This is worrisome.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337518313/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]