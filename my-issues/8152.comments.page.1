[{"url":"https://api.github.com/repos/coq/coq/issues/comments/407823772","html_url":"https://github.com/coq/coq/issues/8152#issuecomment-407823772","issue_url":"https://api.github.com/repos/coq/coq/issues/8152","id":407823772,"node_id":"MDEyOklzc3VlQ29tbWVudDQwNzgyMzc3Mg==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-07-25T16:56:41Z","updated_at":"2018-07-25T16:56:41Z","author_association":"MEMBER","body":"Here is a small example:\r\n```coq\r\nRequire Import Coq.extraction.Extraction.\r\n\r\nReserved Notation \"'dlet' x .. y := v 'in' f\"\r\n         (at level 200, x binder, y binder, f at level 200, format \"'dlet'  x .. y  :=  v  'in' '//' f\").\r\nDefinition Let_In {A P} (x : A) (f : forall a : A, P a) : P x := let y := x in f y.\r\nNotation \"'dlet' x .. y := v 'in' f\" := (Let_In v (fun x => .. (fun y => f) .. )).\r\n\r\nLocal Set Warnings Append \"-extraction-opaque-accessed\".\r\nExtraction Language Haskell.\r\nAxiom IO_unit : Type.\r\nAxiom io_unit : IO_unit.\r\nExtract Inlined Constant IO_unit => \"GHC.Base.IO ()\".\r\nExtraction Inline io_unit.\r\n\r\nModule Import A.\r\n  Inductive fooT := barT (v : nat) | bazT (v : bool).\r\n  Inductive foo := bar | baz.\r\n\r\n  Definition full_types (v : foo) : Type\r\n    := match v return Type with\r\n       | bar => nat\r\n       | baz => bool\r\n       end.\r\n\r\n  Definition invert_bind_args (v : fooT) (v' : foo) : option (full_types v')\r\n    := match v', v return option (full_types v') with\r\n       | bar, barT v => Some v\r\n       | baz, bazT v => Some v\r\n       | bar, _\r\n       | baz, _\r\n         => None\r\n       end.\r\nEnd A.\r\n\r\nModule B := A.\r\n\r\nDefinition bind {A B} (v : option A) (f : A -> option B) := match v with Some a => f a | None => None end.\r\n\r\nDefinition mkpair {T} (v : full_types T) := Some (existT (fun _ : full_types T => full_types T) v v).\r\n\r\nDefinition bad (v : A.fooT) := bind (B.invert_bind_args v baz) (fun b : full_types baz => mkpair b).\r\n\r\nDefinition main : IO_unit := dlet v := bad in io_unit.\r\nRedirect \"bad.hs\" Recursive Extraction main.\r\n```\r\ngenerates\r\n```haskell\r\n{-# OPTIONS_GHC -cpp -XMagicHash #-}\r\n{- For Hugs, use the option -F\"cpp -P -traditional\" -}\r\n\r\nmodule Main where\r\n\r\nimport qualified Prelude\r\n\r\n#ifdef __GLASGOW_HASKELL__\r\nimport qualified GHC.Base\r\n#else\r\n-- HUGS\r\nimport qualified IOExts\r\n#endif\r\n\r\n#ifdef __GLASGOW_HASKELL__\r\nunsafeCoerce :: a -> b\r\nunsafeCoerce = GHC.Base.unsafeCoerce#\r\n#else\r\n-- HUGS\r\nunsafeCoerce :: a -> b\r\nunsafeCoerce = IOExts.unsafeCoerce\r\n#endif\r\n\r\n#ifdef __GLASGOW_HASKELL__\r\ntype Any = GHC.Base.Any\r\n#else\r\n-- HUGS\r\ntype Any = ()\r\n#endif\r\n\r\ndata Bool =\r\n   True\r\n | False\r\n\r\ndata Nat =\r\n   O\r\n | S Nat\r\n\r\ndata Option a =\r\n   Some a\r\n | None\r\n\r\ndata SigT a p =\r\n   ExistT a p\r\n\r\nlet_In :: a1 -> (a1 -> a2) -> a2\r\nlet_In x f =\r\n  f x\r\n\r\ndata FooT =\r\n   BarT Nat\r\n | BazT Bool\r\n\r\ndata Foo =\r\n   Bar\r\n | Baz\r\n\r\ntype Full_types = Any\r\n\r\ndata FooT0 =\r\n   BarT0 Nat\r\n | BazT0 Bool\r\n\r\nfooT_rect :: (Nat -> a1) -> (Bool -> a1) -> FooT0 -> a1\r\nfooT_rect f f0 f1 =\r\n  case f1 of {\r\n   BarT0 x -> f x;\r\n   BazT0 x -> f0 x}\r\n\r\nfooT_rec :: (Nat -> a1) -> (Bool -> a1) -> FooT0 -> a1\r\nfooT_rec =\r\n  fooT_rect\r\n\r\ndata Foo0 =\r\n   Bar0\r\n | Baz0\r\n\r\nfoo_rect :: a1 -> a1 -> Foo0 -> a1\r\nfoo_rect f f0 f1 =\r\n  case f1 of {\r\n   Bar0 -> f;\r\n   Baz0 -> f0}\r\n\r\nfoo_rec :: a1 -> a1 -> Foo0 -> a1\r\nfoo_rec =\r\n  foo_rect\r\n\r\ntype Full_types0 = Any\r\n\r\ninvert_bind_args :: FooT0 -> Foo0 -> Option Full_types0\r\ninvert_bind_args v v' =\r\n  case v' of {\r\n   Bar0 -> case v of {\r\n            BarT0 v0 -> Some (unsafeCoerce v0);\r\n            BazT0 _ -> None};\r\n   Baz0 -> case v of {\r\n            BarT0 _ -> None;\r\n            BazT0 v0 -> Some (unsafeCoerce v0)}}\r\n\r\nbind :: (Option a1) -> (a1 -> Option a2) -> Option a2\r\nbind v f =\r\n  case v of {\r\n   Some a -> f a;\r\n   None -> None}\r\n\r\nmkpair :: Foo -> Full_types -> Option (SigT Full_types Full_types)\r\nmkpair _ v =\r\n  Some (ExistT v v)\r\n\r\nbad :: FooT -> Option (SigT Bool Bool)\r\nbad v =\r\n  bind (invert_bind_args v Baz) (\\b -> unsafeCoerce mkpair Baz b)\r\n\r\nmain :: GHC.Base.IO ()\r\nmain =\r\n  let_In bad (\\_ -> Prelude.error \"AXIOM TO BE REALIZED\")\r\n```\r\nwhich errors on ghc with\r\n```\r\n[1 of 1] Compiling Main             ( bad.hs, bad.o )\r\n\r\nbad.hs:112:26: error:\r\n    • Couldn't match expected type ‘FooT0’ with actual type ‘FooT’\r\n    • In the first argument of ‘invert_bind_args’, namely ‘v’\r\n      In the first argument of ‘bind’, namely ‘(invert_bind_args v Baz)’\r\n      In the expression:\r\n        bind (invert_bind_args v Baz) (\\ b -> unsafeCoerce mkpair Baz b)\r\n\r\nbad.hs:112:28: error:\r\n    • Couldn't match expected type ‘Foo0’ with actual type ‘Foo’\r\n    • In the second argument of ‘invert_bind_args’, namely ‘Baz’\r\n      In the first argument of ‘bind’, namely ‘(invert_bind_args v Baz)’\r\n      In the expression:\r\n        bind (invert_bind_args v Baz) (\\ b -> unsafeCoerce mkpair Baz b)\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/407823772/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/499441549","html_url":"https://github.com/coq/coq/issues/8152#issuecomment-499441549","issue_url":"https://api.github.com/repos/coq/coq/issues/8152","id":499441549,"node_id":"MDEyOklzc3VlQ29tbWVudDQ5OTQ0MTU0OQ==","user":{"login":"llelf","id":870172,"node_id":"MDQ6VXNlcjg3MDE3Mg==","avatar_url":"https://avatars.githubusercontent.com/u/870172?v=4","gravatar_id":"","url":"https://api.github.com/users/llelf","html_url":"https://github.com/llelf","followers_url":"https://api.github.com/users/llelf/followers","following_url":"https://api.github.com/users/llelf/following{/other_user}","gists_url":"https://api.github.com/users/llelf/gists{/gist_id}","starred_url":"https://api.github.com/users/llelf/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/llelf/subscriptions","organizations_url":"https://api.github.com/users/llelf/orgs","repos_url":"https://api.github.com/users/llelf/repos","events_url":"https://api.github.com/users/llelf/events{/privacy}","received_events_url":"https://api.github.com/users/llelf/received_events","type":"User","site_admin":false},"created_at":"2019-06-06T10:33:31Z","updated_at":"2019-06-06T10:33:31Z","author_association":"CONTRIBUTOR","body":"Related: https://github.com/coq/coq/issues/5754","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/499441549/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/599143549","html_url":"https://github.com/coq/coq/issues/8152#issuecomment-599143549","issue_url":"https://api.github.com/repos/coq/coq/issues/8152","id":599143549,"node_id":"MDEyOklzc3VlQ29tbWVudDU5OTE0MzU0OQ==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2020-03-14T22:38:33Z","updated_at":"2020-03-14T22:38:33Z","author_association":"MEMBER","body":"Here is an even smaller example:\r\n```coq\r\nRequire Import Coq.extraction.Extraction.\r\nExtraction Language Haskell.\r\nAxiom IO_unit : Type.\r\nAxiom io_unit : IO_unit.\r\nExtract Inlined Constant IO_unit => \"Prelude.IO ()\".\r\nExtraction Inline io_unit.\r\n\r\nLocal Unset Elimination Schemes.\r\n\r\nModule A.\r\n  Inductive T := t1 | t2.\r\nEnd A.\r\n\r\nModule B := A.\r\n\r\nDefinition foo (f : A.T -> B.T) : IO_unit := io_unit.\r\n\r\nDefinition main := foo (fun x => x).\r\n\r\nExtraction \"foo.hs\" main.\r\n```\r\nIn `foo.hs`:\r\n```haskell\r\nmodule Foo where\r\n\r\nimport qualified Prelude\r\n\r\ndata T =\r\n   T1\r\n | T2\r\n\r\ndata T4 =\r\n   T0\r\n | T3\r\n\r\nfoo :: (T -> T4) -> Prelude.IO ()\r\nfoo _ =\r\n  Prelude.error \"AXIOM TO BE REALIZED\"\r\n\r\nmain :: Prelude.IO ()\r\nmain =\r\n  foo (\\x -> x)\r\n```\r\nwhich gives\r\n```\r\n$ ghc foo.hs\r\n[1 of 1] Compiling Foo              ( foo.hs, foo.o )\r\n\r\nfoo.hs:19:14: error:\r\n    • Couldn't match expected type ‘T4’ with actual type ‘T’\r\n    • In the expression: x\r\n      In the first argument of ‘foo’, namely ‘(\\ x -> x)’\r\n      In the expression: foo (\\ x -> x)\r\n```\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/599143549/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]