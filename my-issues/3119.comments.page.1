[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515745","html_url":"https://github.com/coq/coq/issues/3119#issuecomment-337515745","issue_url":"https://api.github.com/repos/coq/coq/issues/3119","id":337515745,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTc0NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-08-31T23:37:23Z","updated_at":"2017-10-18T09:07:30Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nIt would be extremely useful to have eta conversion for records, e.g., so that the double-opposite of a category is judgmentally equal to itself, and so that the double-opposite of a functor can be asserted equal to itself without transport across paths.\n\nMore generally, I would like to have eta-conversion for inductive datatypes with one constructor and no indices (only parameters, so, e.g., [sigT] is fine, but [eq] is not).  This would not decrease the expressiveness of Coq, as changing parameters into indices would give back the old behavior.\n\nPerhaps more generally, it would be nice if we had the following two eta rules about matches for any inductive data type T (regardless of whether or not it has indices):\n\n  forall (x : T),\n       x ≡ \n         match x return T with\n           | constructor1 a1 ... an => constructor1 a1 ... an\n           | ...\n           | constructorm a1 ... ap => constructorm a1 ... ap\n         end\n\nand then some kind of rule about commutativity of [match] which says that\n  let (a1, ..., an) := x in constructor a1 ... an\nis convertible with something whose head is [constructor] (i.e., the version of [existT _ (projT1 x) (projT2 x)], but for arbitrary inductive datatypes with one constructor and no indices.\n\nBut I would be very happy with just eta conversion for records.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515745/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515746","html_url":"https://github.com/coq/coq/issues/3119#issuecomment-337515746","issue_url":"https://api.github.com/repos/coq/coq/issues/3119","id":337515746,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTc0Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-09-02T01:51:01Z","updated_at":"2017-10-18T09:07:30Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI was talking with Saizan and xplat on #agda, and I think the appropriate generalized eta rule is that [match] commutes with any function which is polymorphic over the indices of the inductive data type.  So, for example, with [eq] which has two parameters ([A : Type] and [x : A]) and one index (of type A), the rule is\n\n  ∀ A (x y : A) (P : ∀ a, x = a → Type) (f : ∀ a (p : x = a), P a p) (p : x = y),\n    f _ p\n    = match p as p0 in (_ = y0) return (P y0 p0) with\n        | eq_refl ⇒ f _ eq_refl\n      end.\n\nand for [JMeq], the rule is\n\n  ∀ A (x : A) (P : ∀ B (b : B), JMeq x b → Type) (f : ∀ B (y : B) (p : JMeq x y) → P B y p) B (y : B) (p : JMeq x y),\n    f _ _ p\n    = match p as p0 in (@ JMeq _ _ B0 y0) return (P B0 y0 p0) with\n        | JMeq_refl ⇒ f _ _ JMeq_refl\n      end.\n\nand for [sum], the rule is\n\n  ∀ A B (P : A + B → Type) (f : ∀ x, P x) (x : A + B),\n    f x\n    = match x as x0 return P x0 with\n        | inl a ⇒ f (inl a)\n        | inr b ⇒ f (inr b)\n      end.\n\nIt would be nice to have these rules judgmentally, and by combining the case that [f] is a constructor with the case that [f] is the identity, I think these rules suffice to obtain eta for records.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515746/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515749","html_url":"https://github.com/coq/coq/issues/3119#issuecomment-337515749","issue_url":"https://api.github.com/repos/coq/coq/issues/3119","id":337515749,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTc0OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-11-03T22:21:17Z","updated_at":"2017-10-18T09:07:30Z","author_association":"CONTRIBUTOR","body":"Comment author: @pirbo\n\nThis is a HUGE change. it is way too big to be only a bug.\n\nIt IS interesting feel absolutely free to spend the month in kernel/closure.ml it requires to figure out how it could be implemented in practice and the month it requires to make the correction proof of the implementation. Make a talk at (t least) the next coq workshop because other people will definitely be interested the research !\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515749/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515751","html_url":"https://github.com/coq/coq/issues/3119#issuecomment-337515751","issue_url":"https://api.github.com/repos/coq/coq/issues/3119","id":337515751,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTc1MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-02-26T04:53:45Z","updated_at":"2017-10-18T09:07:31Z","author_association":"CONTRIBUTOR","body":"Comment author: @silene\n\nI am no specialist, but it seems you are suggesting that (x: Acc ...) should be convertible to Acc_intro (match x with Acc_intro y => y end). Does that not break strong normalization and make type checking undecidable? If so, it is not just a matter of proving the correctness of the implementation; there are many theoretical implications to consider first. So let us close this report.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515751/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515752","html_url":"https://github.com/coq/coq/issues/3119#issuecomment-337515752","issue_url":"https://api.github.com/repos/coq/coq/issues/3119","id":337515752,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTc1Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-06-29T19:59:08Z","updated_at":"2017-10-18T09:07:31Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nFor future reference: after discussing with Thorsten Altenkirch and Paolo Capriotti at the HoTT/UF Workshop, I learned that this rule implies equality reflection.  If we have\n\n  ∀ A (x y : A) (P : ∀ a, x = a → Type) (f : ∀ a (p : x = a), P a p) (p : x = y),\n    f _ p\n    ≡ match p as p0 in (_ = y0) return (P y0 p0) with\n        | eq_refl ⇒ f _ eq_refl\n      end.\n\nthen, given [A] and [x : A], take [P _ _ := A], [f _ _ := x], and [g y _ := y], so that [f x eq_refl ≡ g x eq_refl ≡ x].  Then, assuming [y : A] and [p : x = y], using this match-commutation rule on the second and second-to-last-step, we get\n\n\n    x\n    ≡ f y (match p as p0 in (_ = y0) return (P y0 p0) with\n             | eq_refl ⇒ x\n           end)\n    ≡ match p as p0 in (_ = y0) return (P y0 p0) with\n        | eq_refl ⇒ f _ eq_refl\n      end\n    ≡ match p as p0 in (_ = y0) return (P y0 p0) with\n        | eq_refl ⇒ x\n      end\n    ≡ match p as p0 in (_ = y0) return (P y0 p0) with\n        | eq_refl ⇒ g _ eq_refl\n      end\n    ≡ g y (match p as p0 in (_ = y0) return (P y0 p0) with\n             | eq_refl ⇒ g _ eq_refl\n           end)\n    ≡ y\n\nand hence [x ≡ y].\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515752/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]