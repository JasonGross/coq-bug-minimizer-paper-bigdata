[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515688","html_url":"https://github.com/coq/coq/issues/3115#issuecomment-337515688","issue_url":"https://api.github.com/repos/coq/coq/issues/3115","id":337515688,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTY4OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-08-17T00:01:56Z","updated_at":"2018-05-10T00:21:36Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\n[Identity Coercion]s in their current state seem useless to me.  I do not see what I can do with them that I could not do without them.  For example:\r\n```coq\r\nAxioms A B : Type -> Type.\r\nAxiom f : A nat -> B Type.\r\n\r\nDefinition A' := A nat.\r\nDefinition f' : A' -> B Type := f.\r\nCoercion f' : A' >-> B.\r\nCheck (_ : A nat) : A'.\r\nFail Check (_ : A nat) : B Type. (* The term \"?11:A nat\" has type \"A nat\" while it is expected to have type \"B Type\". *)\r\nCheck ((_ : A nat) : A') : B Type. (* ((?11:A nat):A'):B Type *)\r\n\r\nFail Identity Coercion f'_id : A >-> A'. (* Error: in build_id_coercion: A must be a transparent constant. *)\r\nIdentity Coercion f'_id : A' >-> A.\r\n\r\nFail Check (_ : A nat) : B Type. (* The term \"?11:A nat\" has type \"A nat\" while it is expected to have type \"B Type\". *)\r\n\r\nCoercion f : A >-> B. (* Warning: f does not respect the uniform inheritance condition *)\r\n\r\nCheck (_ : A nat) : B Type. (* Anomaly: apply_coercion_args. Please report. *)\r\n```\r\n\r\nI thought the point of [Identity Coercion]s was to get around the uniform inheritance condition.  If I could reverse the direction of the arrow, so that the identity coercion was from [A nat] to [A'] rather than from [A'] to [A nat], then they would be very useful.  But as they are, they do not seem to help me get around the uniform inheritance condition.\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515688/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515689","html_url":"https://github.com/coq/coq/issues/3115#issuecomment-337515689","issue_url":"https://api.github.com/repos/coq/coq/issues/3115","id":337515689,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTY4OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-06-20T12:45:45Z","updated_at":"2018-05-10T00:21:48Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nMore generally, it would be nice to remove the restriction on identity coercions all-together, and simply require that the source and target, appropriately instantiated, be unifiable, and provide a way to provide the instantiation hints.  (Alternatively, allowing identity coercions to be one level of either folding or unfolding would be enough to get this by chaining them together.)\r\n\r\nGeorges Gonthier has shown me a hack used in ssreflect that can be used to get around this when the source is not an inductive type:\r\n```coq\r\nModule Export Def.\r\n  Axiom A : Type.\r\n  Axiom B : Type.\r\nEnd Def.\r\nDefinition C (b : bool) := if b then A else B.\r\nModule Type DefSig.\r\n  Definition A := C true.\r\nEnd DefSig.\r\nModule CoerT (P : DefSig).\r\n  Identity Coercion coer : P.A >-> C.\r\nEnd CoerT.\r\nModule Export CoerAT := CoerT Def.\r\n\r\nCheck ((_ : A) : C _).\r\n```\r\nThe [Module Export] at the end fails, though if [A] is an inductive type.\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515689/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]