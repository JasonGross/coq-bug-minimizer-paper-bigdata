Comment author: @JasonGross

I expect [exact $(foo)$.] to be the same as [foo.]  It is not when [foo] contains underscores.

Tactic Notation "evarr" open_constr(x) := let y := constr:(x) in exact y.

Goal True.
  evarr _.
Admitted.
Goal True.
  exact $(evarr _)$. (* Error: Cannot infer this placeholder. *)


Comment author: @ppedrot

As a general remark, messing with tactic notations is hackish and should not be encouraged. We should provide you with better Ltac primitives one day (or just throw Ltac away anyway).

In the precise example you give, I think it comes from the way tactics in terms are evaluated. The precise moment of their computation is not specified, and you shall not rely on the equally non specified unification, which may explain your error here. I'll have a look at it to be sure.


Comment author: @ppedrot

OK, I localized the problem. I am unsure how to fix it properly though. Terms interpreted by tactics expect to have all their holes which are not generated by maximally inserted implicit arguments to be resolved at the time of their interpretation. Here the tactic adds new holes, which does not please the exact tactic.

I may add some unification somewhere or drop the silly heuristic in Pretyping.check_extra_evars_are_solved...


Comment author: @JasonGross

This might be too radical a change, or nonsensical, but it seems to me that the relevant distinction for tactics writers isn't constr vs open_constr (we have has_evars or whatever, for that), but instead "how much inference has been run?", i.e., has typeclasses been run, has canonical structures been run?  Perhaps everything should be an open_constr by default, [exact foo] should just be [refine foo; []], etc?


Comment author: @ppedrot

That's precisely what [eexact] do, and this is for historical reasons. Before the evar machinery, tactics were manipulating metas, hence the somewhat artificial difference between the with-or-without evar versions of tactics (eapply, eexists, eexact, etc.).


I think that this bug report is INVALID.
