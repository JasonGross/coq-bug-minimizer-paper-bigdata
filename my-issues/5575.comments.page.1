[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337554697","html_url":"https://github.com/coq/coq/issues/5575#issuecomment-337554697","issue_url":"https://api.github.com/repos/coq/coq/issues/5575","id":337554697,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU1NDY5Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-06-02T23:01:57Z","updated_at":"2017-10-18T11:05:05Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nRequire Import Coq.Classes.RelationClasses Coq.Classes.Morphisms \nCoq.Setoids.Setoid.\nAxiom sr : subrelation eq (Basics.flip Basics.impl).\nExisting Instance sr.\nAxiom silly : True = False.\nAxiom P : Prop -> Prop.\nGoal P True.\n  Typeclasses eauto := debug.\n  pose proof (_ : Proper (eq ==> Basics.flip Basics.impl) P).\n  (* Debug: 1: looking for (Proper (eq ==> Basics.flip Basics.impl) P) without \nbacktracking\nDebug: 1.1: (*external*) proper_reflexive on (Proper (eq ==> Basics.flip \nBasics.impl) P), 1 subgoal(s)\nDebug: 1.1.2 : (Reflexive (eq ==> Basics.flip Basics.impl)%signature)\nDebug: 1.1.2: looking for (Reflexive (eq ==> Basics.flip \nBasics.impl)%signature) without backtracking\nDebug: 1.1.2.1: simple apply @ reflexive_eq_dom_reflexive on (Reflexive (eq ==> \nBasics.flip Basics.impl)%signature), 1 subgoal(s)\nDebug: 1.1.2.1.2 : (Reflexive (Basics.flip Basics.impl))\nDebug: 1.1.2.1.2: looking for (Reflexive (Basics.flip Basics.impl)) without \nbacktracking\nDebug: 1.1.2.1.2.1: simple apply @ Equivalence_Reflexive on (Reflexive \n(Basics.flip Basics.impl)), 1 subgoal(s)\nDebug: 1.1.2.1.2.1.2 : (Equivalence (Basics.flip Basics.impl))\nDebug: 1.1.2.1.2.1.2: looking for (Equivalence (Basics.flip Basics.impl)) \nwithout backtracking\nDebug: 1.1.2.1.2.1.2: no match for (Equivalence (Basics.flip Basics.impl)) , 0 \npossibilities\nDebug: 1.1.2.1.2.2: simple apply @ PreOrder_Reflexive on (Reflexive (Basics.flip \nBasics.impl)), 1 subgoal(s)\nDebug: 1.1.2.1.2.2.2 : (PreOrder (Basics.flip Basics.impl))\nDebug: 1.1.2.1.2.2.2: looking for (PreOrder (Basics.flip Basics.impl)) without \nbacktracking\nDebug: 1.1.2.1.2.2.2.1: (*external*) (class_apply @ flip_PreOrder) on (PreOrder \n(Basics.flip Basics.impl)), 1 subgoal(s)\nDebug: 1.1.2.1.2.2.2.1.2 : (PreOrder Basics.impl)\nDebug: 1.1.2.1.2.2.2.1.2: looking for (PreOrder Basics.impl) without \nbacktracking\nDebug: 1.1.2.1.2.2.2.1.2.1: simple apply @ Equivalence_PreOrder on (PreOrder \nBasics.impl), 1 subgoal(s)\nDebug: 1.1.2.1.2.2.2.1.2.1.2 : (Equivalence Basics.impl)\nDebug: 1.1.2.1.2.2.2.1.2.1.2: looking for (Equivalence Basics.impl) without \nbacktracking\nDebug: 1.1.2.1.2.2.2.1.2.1.2: no match for (Equivalence Basics.impl) , 0 \npossibilities\nDebug: 1.1.2.1.2.2.2.2: simple apply @ Equivalence_PreOrder on (PreOrder \n(Basics.flip Basics.impl)), 1 subgoal(s)\nDebug: 1.1.2.1.2.2.2.2.2 : (Equivalence (Basics.flip Basics.impl))\nDebug: 1.1.2.1.2.2.2.2.2: looking for (Equivalence (Basics.flip Basics.impl)) \nwithout backtracking\nDebug: 1.1.2.1.2.2.2.2.2: no match for (Equivalence (Basics.flip Basics.impl)) \n, 0 possibilities\nDebug: 1: looking for (Reflexive Basics.impl) without backtracking\nDebug: 1.1: exact impl_Reflexive on (Reflexive Basics.impl), 0 subgoal(s)\nDebug: 1.1.2.1.2.3: (*external*) (apply flip_Reflexive) on (Reflexive \n(Basics.flip Basics.impl)), 0 subgoal(s)\n *)\n  Undo.\n  setoid_rewrite silly. (* Debug: 1: looking for (Proper (eq ==> Basics.flip \nBasics.impl) P) without backtracking\nDebug: 1.1: (*external*) proper_subrelation on (Proper (eq ==> Basics.flip \nBasics.impl) P), 3 subgoal(s)\nDebug: 1.1.4 : (Proper ?R' P)\nDebug: 1.1.4: looking for (Proper ?R' P) with backtracking\nDebug: 1.1.4.1: (*external*) proper_reflexive on (Proper ?R' P), 0 subgoal(s)\nDebug: 1.1.4 : (Unconvertible (relation (Prop -> Prop)) (eq ==> Basics.flip \nBasics.impl)%signature eq)\nDebug:\n1.1.4: looking for (Unconvertible (relation (Prop -> Prop)) (eq ==> Basics.flip \nBasics.impl)%signature eq) without backtracking\nDebug: 1.1.4.1: (*external*) unconvertible on\n(Unconvertible (relation (Prop -> Prop)) (eq ==> Basics.flip \nBasics.impl)%signature eq), 0 subgoal(s)\nDebug: 1.1.4 : (subrelation eq (eq ==> Basics.flip Basics.impl)%signature)\nDebug: 1.1.4: looking for (subrelation eq (eq ==> Basics.flip \nBasics.impl)%signature) without backtracking\nDebug: 1.1.4: no match for (subrelation eq (eq ==> Basics.flip \nBasics.impl)%signature) , 1 possibilities\nDebug: 1.2: (*external*) proper_normalization on (Proper (eq ==> Basics.flip \nBasics.impl) P), 2 subgoal(s)\nDebug: 1.2.3 : (Normalizes (Prop -> Prop) (eq ==> Basics.flip \nBasics.impl)%signature ?R1)\nDebug: 1.2.3: looking for (Normalizes (Prop -> Prop) (eq ==> Basics.flip \nBasics.impl)%signature ?R1) with backtracking\nDebug: 1.2.3.1: (*external*) normalizes on (Normalizes (Prop -> Prop) (eq ==> \nBasics.flip Basics.impl)%signature ?R1), 2 subgoal(s)\nDebug: 1.2.3.1.3 : (Normalizes Prop eq (Basics.flip ?Goal1))\nDebug: 1.2.3.1.3: looking for (Normalizes Prop eq (Basics.flip ?Goal1)) with \nbacktracking\nDebug: 1.2.3.1.3.1: (*external*) normalizes on (Normalizes Prop eq (Basics.flip \n?Goal1)), 0 subgoal(s)\nDebug: 1.2.3.1.3 : (Normalizes Prop (Basics.flip Basics.impl) (Basics.flip \n?Goal1))\nDebug: 1.2.3.1.3: looking for (Normalizes Prop (Basics.flip Basics.impl) \n(Basics.flip ?Goal1)) with backtracking\nDebug: 1.2.3.1.3.1: (*external*) normalizes on (Normalizes Prop (Basics.flip \nBasics.impl) (Basics.flip ?Goal1)), 0 subgoal(s)\nDebug: 1.2.3 : (Proper (Basics.flip (eq --> Basics.flip (Basics.flip \nBasics.impl))%signature) P)\nDebug: 1.2.3: looking for (Proper (Basics.flip (eq --> Basics.flip (Basics.flip \nBasics.impl))%signature) P) without backtracking\nDebug: 1.2.3.1: (*external*) (class_apply @ proper_flip_proper) on\n(Proper (Basics.flip (eq --> Basics.flip (Basics.flip Basics.impl))%signature) \nP), 1 subgoal(s)\nDebug: 1.2.3.1.2 : (Proper (eq --> Basics.flip (Basics.flip Basics.impl)) P)\nDebug: 1.2.3.1.2: looking for (Proper (eq --> Basics.flip (Basics.flip \nBasics.impl)) P) without backtracking\nDebug: 1.2.3.1.2.1: (*external*) proper_subrelation on (Proper (eq --> \nBasics.flip (Basics.flip Basics.impl)) P), 3 subgoal(s)\nDebug: 1.2.3.1.2.1.4 : (Proper ?R' P)\nDebug: 1.2.3.1.2.1.4: looking for (Proper ?R' P) with backtracking\nDebug: 1.2.3.1.2.1.4: no match for (Proper ?R' P) , 17 possibilities\nDebug: 1.2.3.2: (*external*) proper_subrelation on\n(Proper (Basics.flip (eq --> Basics.flip (Basics.flip Basics.impl))%signature) \nP), 3 subgoal(s)\nDebug: 1.2.3.2.4 : (Proper ?R' P)\nDebug: 1.2.3.2.4: looking for (Proper ?R' P) with backtracking\nDebug: 1.2.3.2.4: no match for (Proper ?R' P) , 17 possibilities\nDebug: 1.3: (*external*) proper_reflexive on (Proper (eq ==> Basics.flip \nBasics.impl) P), 1 subgoal(s)\nDebug: 1.3.2 : (Reflexive (eq ==> Basics.flip Basics.impl)%signature)\nDebug: 1.3.2: looking for (Reflexive (eq ==> Basics.flip \nBasics.impl)%signature) without backtracking\nDebug: 1.3.2.1: simple apply @ reflexive_eq_dom_reflexive on (Reflexive (eq ==> \nBasics.flip Basics.impl)%signature), 1 subgoal(s)\nDebug: 1.3.2.1.2 : (Reflexive (Basics.flip Basics.impl))\nDebug: 1.3.2.1.2: looking for (Reflexive (Basics.flip Basics.impl)) without \nbacktracking\nDebug: 1.3.2.1.2.1: simple apply @ Equivalence_Reflexive on (Reflexive \n(Basics.flip Basics.impl)), 1 subgoal(s)\nDebug: 1.3.2.1.2.1.2 : (Equivalence (Basics.flip Basics.impl))\nDebug: 1.3.2.1.2.1.2: looking for (Equivalence (Basics.flip Basics.impl)) \nwithout backtracking\nDebug: 1.3.2.1.2.1.2: no match for (Equivalence (Basics.flip Basics.impl)) , 0 \npossibilities\nDebug: 1.3.2.1.2.2: simple apply @ PreOrder_Reflexive on (Reflexive (Basics.flip \nBasics.impl)), 1 subgoal(s)\nDebug: 1.3.2.1.2.2.2 : (PreOrder (Basics.flip Basics.impl))\nDebug: 1.3.2.1.2.2.2: looking for (PreOrder (Basics.flip Basics.impl)) without \nbacktracking\nDebug: 1.3.2.1.2.2.2.1: (*external*) (class_apply @ flip_PreOrder) on (PreOrder \n(Basics.flip Basics.impl)), 1 subgoal(s)\nDebug: 1.3.2.1.2.2.2.1.2 : (PreOrder Basics.impl)\nDebug: 1.3.2.1.2.2.2.1.2: looking for (PreOrder Basics.impl) without \nbacktracking\nDebug: 1.3.2.1.2.2.2.1.2.1: simple apply @ Equivalence_PreOrder on (PreOrder \nBasics.impl), 1 subgoal(s)\nDebug: 1.3.2.1.2.2.2.1.2.1.2 : (Equivalence Basics.impl)\nDebug: 1.3.2.1.2.2.2.1.2.1.2: looking for (Equivalence Basics.impl) without \nbacktracking\nDebug: 1.3.2.1.2.2.2.1.2.1.2: no match for (Equivalence Basics.impl) , 0 \npossibilities\nDebug: 1.3.2.1.2.2.2.2: simple apply @ Equivalence_PreOrder on (PreOrder \n(Basics.flip Basics.impl)), 1 subgoal(s)\nDebug: 1.3.2.1.2.2.2.2.2 : (Equivalence (Basics.flip Basics.impl))\nDebug: 1.3.2.1.2.2.2.2.2: looking for (Equivalence (Basics.flip Basics.impl)) \nwithout backtracking\nDebug: 1.3.2.1.2.2.2.2.2: no match for (Equivalence (Basics.flip Basics.impl)) \n, 0 possibilities\nDebug: 1: looking for (Reflexive Basics.impl) without backtracking\nDebug: 1.1: exact impl_Reflexive on (Reflexive Basics.impl), 0 subgoal(s)\nDebug: 1.3.2.1.2.3: (*external*) (apply flip_Reflexive) on (Reflexive \n(Basics.flip Basics.impl)), 0 subgoal(s)\n*)\n\nNotice that [pose proof] tries [proper_reflexive] first (level 7), while \n[setoid_rewrite] tries [proper_subrelation] first (level 5).  I suspect this is \npart of what causes setoid_rewrite to sometimes be slow.\n\nWhat's going on here?\n\nFixing this (if it is a bug) will certainly break backwards compatibility, so \nit may be best to put it under some sort of compatibility option.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337554697/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337554698","html_url":"https://github.com/coq/coq/issues/5575#issuecomment-337554698","issue_url":"https://api.github.com/repos/coq/coq/issues/5575","id":337554698,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU1NDY5OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-06-05T16:17:38Z","updated_at":"2017-10-18T11:05:05Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nsetoid_rewrite does not generate exactly the same goal, it adds a do_subrelation hypothesis to the goals, that allows to fire the \"subtyping\" rule proper_subrelation (only once) first, while for pose proof this hint is not applicable (it's not in the trace as you can see). There is certainly a compromise to choose between the reflexive or subrelation instances, we favor the later as its usually the one you want for morphisms introduced by the user, it finds directly the declared instances and test if they give rise to subrelations of the inferred relation, while proper_reflexive can wastefully check for a reflexivity proof of a relation that is all but reflexive.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337554698/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337554699","html_url":"https://github.com/coq/coq/issues/5575#issuecomment-337554699","issue_url":"https://api.github.com/repos/coq/coq/issues/5575","id":337554699,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU1NDY5OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-06-05T19:21:23Z","updated_at":"2017-10-18T11:05:05Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n> while proper_reflexive can wastefully check for a reflexivity proof of a relation that is all but reflexive\n\nThat actually seems exactly backwards to me; frequently there will be multiple Proper instances for a given connective (e.g., `Proper (eq ==> eq ==> eq) impl` and `Proper (iff ==> iff ==> iff) impl` and `Proper (impl ==> flip impl ==> flip impl) impl` and `Proper (flip impl ==> impl ==> impl) impl`), and it takes time to check all of them, and even if one is found that is a subrelation, that might make future subgoals impossible because the evars were instantiated wrong.  On the other hand, checking for reflexivity is typically quick, and involves minimal backtracking.\n\nQuestion: Under what conditions do multiple tc Proper subgoals share evars in the relations?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337554699/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]