[{"url":"https://api.github.com/repos/coq/coq/issues/comments/482704634","html_url":"https://github.com/coq/coq/issues/9955#issuecomment-482704634","issue_url":"https://api.github.com/repos/coq/coq/issues/9955","id":482704634,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4MjcwNDYzNA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-04-12T20:03:24Z","updated_at":"2019-04-12T20:03:24Z","author_association":"MEMBER","body":"More minimal version:\r\n```coq\r\n(* -*- coq-prog-args: (\"-nois\" \"-boot\") -*- *)\r\nInductive bool := true | false.\r\nAxiom x : bool.\r\nDefinition foo\r\n  := (fun (T : forall b : bool, Type)\r\n          (f : forall b, T b)\r\n      => true)\r\n       _\r\n       (fun _ : bool\r\n        => match x with true => true | false => false end).\r\n```\r\nNote that this issue does not show up with `if` statements","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/482704634/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/482704875","html_url":"https://github.com/coq/coq/issues/9955#issuecomment-482704875","issue_url":"https://api.github.com/repos/coq/coq/issues/9955","id":482704875,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4MjcwNDg3NQ==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-04-12T20:04:21Z","updated_at":"2019-04-12T20:04:21Z","author_association":"MEMBER","body":"Note also that inserting `return _` makes the code pass.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/482704875/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/482706115","html_url":"https://github.com/coq/coq/issues/9955#issuecomment-482706115","issue_url":"https://api.github.com/repos/coq/coq/issues/9955","id":482706115,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4MjcwNjExNQ==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-04-12T20:08:50Z","updated_at":"2019-04-12T20:14:25Z","author_association":"MEMBER","body":"Bisect blames https://github.com/coq/coq/pull/262:\r\n\r\n> af622fc60e42ee40c83b4e2b744b8212616b681d is the first bad commit\r\n> commit af622fc60e42ee40c83b4e2b744b8212616b681d\r\n> Author: Hugo Herbelin <Hugo.Herbelin@inria.fr>\r\n> Date:   Thu Aug 18 13:24:50 2016 +0200\r\n> \r\n>     Inference of return clause: giving uniformly priority to \"small inversion\".\r\n>     \r\n>     As noted by Jason Gross on coq-club (Aug 18, 2016), the \"small\r\n>     inversion\" heuristic is not used consistently depending on whether the\r\n>     variables in the type constraint are Rel or Var.\r\n>     \r\n>     This commit simply gives uniformly preference to the inversion of the\r\n>     predicate along the indices of the type over other heuristics.\r\n>     \r\n>     The next three commits will improve further a uniform use of the\r\n>     different heuristics.\r\n>     \r\n>     ----------------------------------------------------------------------\r\n>     Here are some extra comments on how to go further with the inference\r\n>     of the return predicate:\r\n>     \r\n>     The \"small inversion\" heuristic build_inversion_problem (1) is\r\n>     characterized by two features:\r\n>     \r\n>     - small inversion properly speaking (a), i.e. that is for a match on\r\n>       t:I params p1(u11..u1p1) ... pn(un1..unpn) with pi exposing the\r\n>       constructor structure of the indices of the type of t, a return\r\n>       clause of the form \"fun x1..xn (y:I params x1..xn) => match x1..xn y with\r\n>       | p1(z11..z1p1) ... pn(zn1..znpn) => ?T@{z11..znpn}\r\n>       | _ => IDProp\r\n>       end\" is used,\r\n>     \r\n>     - the dependent subterms in the external type constraint U are replaced\r\n>       by existential variables (b) which can be filled either by projecting\r\n>       (i.e. installing a dependency) or imitating (i.e. no dependency);\r\n>       this is obtained by solving the constraint ?T@{u11..unpn} == U by\r\n>       setting ?T@{z11..znpn} := U'(...?wij@{zij:=uij}...) where U has been\r\n>       written under the form U'(...uij...) highlighting all occurrences of\r\n>       each of the uij occurring in U; otherwise said the problem is reduced to\r\n>       the question of instantiating each wij, deciding whether wij@{zij} := zij\r\n>       (projection) or wij@{zij} := uij (imitation) [There may be different\r\n>       way to expose the uij in U, e.g. in the presence of overlapping, or of\r\n>       evars in U; this is left undetermined].\r\n>     \r\n>     The two other heuristics used are:\r\n>     \r\n>     - prepare_predicate_from_arsign_tycon (2): takes the external type\r\n>       constraint U and decides that each subterm of the form xi or y for a\r\n>       match on \"y:I params x1 ... xn\" is dependent; otherwise said, it\r\n>       corresponds to the degenerated form of (1) where\r\n>       - no constructor structure is exposed (i.e. each pi is trivial)\r\n>       - only uij that are Rel are replaced by an evar ?wij and this evar is\r\n>         directly instantiated by projection (hence creating a dependency),\r\n>     \r\n>     - simple use of of an evar in case no type constraint is given (3):\r\n>       this evar is not dependent on the indices nor on the term to match.\r\n>     \r\n>     Heuristic (1) is not strictly more powerful than other heuristics\r\n>     because of (at least) two weaknesses.\r\n>     \r\n>     - The first weakness is due to feature (b), i.e. to letting\r\n>       unification decide whether these evars have to create a dependency\r\n>       (projection) or not (imitation).\r\n>     \r\n>       In particular, the heuristic (2) gives priority to systematic\r\n>       abstraction over the dependencies (i.e. giving priority to\r\n>       projection over imitation) and it can then be better as the\r\n>       following example (from RelationClasses.v) shows:\r\n>     \r\n>       Fixpoint arrows (l : Tlist) (r : Type) : Type :=\r\n>         match l with\r\n>         | Tnil => r\r\n>         | A :: l' => A -> arrows l' r\r\n>         end.\r\n>     \r\n>       Fixpoint predicate_all (l : Tlist) : arrows l Prop -> Prop :=\r\n>         match l with\r\n>         | Tnil => fun f => f\r\n>         | A :: tl => fun f => forall x : A, predicate_all tl (f x)\r\n>         end.\r\n>     \r\n>       Using (1) fails. It proposes the predicate\r\n>       \"fun l' => arrows ?l[l':=l'] Prop\" so that typing the first branch\r\n>       leads to unify \"arrows ?l[l:=Tnil] Prop == Prop\", a problem about\r\n>       which evarconv unification is not able (yet!) to see what are the\r\n>       two possible solutions. Using (2) works. It instead directly\r\n>       suggests that the predicate is \"fun l => arrows l Prop\" is used, so\r\n>       that unification is not needed.\r\n>     \r\n>       Even if in practice the (2) is good (and hence could be added to\r\n>       (1)), it is not universally better. Consider e.g.\r\n>     \r\n>          y:bool,H1:P y,H2:P y,f:forall y, P y -> Q y |-\r\n>                   match y as z return Q y with\r\n>                   | true  => f y H1\r\n>                   | false => f y H2\r\n>                   end : Q y\r\n>     \r\n>       There is no way to type it with clause \"as z return Q z\" even if\r\n>       trying to generalize H1 and H2 so that they get type P z.\r\n>     \r\n>     - A second weakness is due to the interaction between small inversion\r\n>       and constructors having a type whose indices havex a less refined\r\n>       constructor structure than in the term to match, as in:\r\n>     \r\n>       Inductive I : nat -> Set :=\r\n>       | C1 : forall n : nat, listn n -> I n\r\n>       | C2 : forall n : nat, I n -> I n.\r\n>     \r\n>       Check (fun x : I 0 => match x with\r\n>                             | C1 n l => 0\r\n>                             | C2 n c => 0\r\n>                             end).\r\n>     \r\n>       where the inverted predicate is \"in I n return match n with 0 => ?T | _ => IDProp end\"\r\n>       but neither C1 nor C2 have fine enough types so that n becomes\r\n>       constructed. There is a generic solution to that kind of situation which\r\n>       is to compile the above into\r\n>     \r\n>       Check (fun x : I 0 => match x with\r\n>                             | C1 n l => match n with 0 => 0 | _ -> id end\r\n>                             | C2 n c => match n with 0 => 0 | _ -> id end\r\n>                             end).\r\n>     \r\n>       but this is not implemented yet.\r\n>     \r\n>       In the absence of this refinement, heuristic (3) can here work\r\n>       better.\r\n>     \r\n>     So, the current status of the claim is that for (1) to be strictly\r\n>     more powerful than other current heuristics, work has to be done\r\n>     \r\n>     - (A) at the unification level (by either being able to reduce problems of\r\n>       the form \"match ?x[constructor] with ... end = a-rigid-term\", or, at\r\n>       worst, by being able to use the heuristic favoring projecting for such\r\n>       a problem), so that it is better than (2),\r\n>     \r\n>     - (B) at the match compilation level, by enforcing that, in each branch,\r\n>       the corresponding constructor is refined so has to match (or\r\n>       discriminate) the constraints given by the type of the term to\r\n>       match, and hence being better than (3).\r\n>     \r\n>     Moreover, (2) and (3) are disjoint. Here is an example which (3) can\r\n>     solve but not (2) (and (1) cannot because of (B)). [To be fixed in\r\n>     next commit.]\r\n>     \r\n>     Inductive I : bool -> bool -> Type := C : I true true | D x : I x x.\r\n>     \r\n>     Check fun z P Q (y:I true z) (H1 H2:P y) (f:forall y, P y -> Q y z) =>\r\n>                   match y with\r\n>                   | C  => f y H1\r\n>                   | D _ => f y H2\r\n>                   end : Q y z.\r\n>     \r\n>     Indeed, (2) infers \"as y' in I b z return Q y z\" which does not work.\r\n>     \r\n>     Here is an example which (2) can solve but not (3) (and (1) cannot\r\n>     because of (B) again). [To be fixed in 2nd next commit].\r\n>     \r\n>     Check fun z P Q (y:I true z) (H1 H2:P y) (f:forall y z, P y -> Q y z) =>\r\n>                   match y with\r\n>                   | C  => f y true H1\r\n>                   | D b => f y b H2\r\n>                   end : Q y z.\r\n>     \r\n>     fix\r\n> \r\n> ```\r\n> :040000 040000 03779a3ddf9eb7d266110a546cf927cd2eb0f3cc ed34b20f831bebec0d4e644823e0adc308629d8f M      pretyping`\r\n> :040000 040000 42e0e2d377786976b4d168e1189b8e5f4fd8943f d7e8e0a075e14bb5f1d9c41ed4ec06d43d491f35 M      test-suite\r\n> ```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/482706115/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/482707968","html_url":"https://github.com/coq/coq/issues/9955#issuecomment-482707968","issue_url":"https://api.github.com/repos/coq/coq/issues/9955","id":482707968,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4MjcwNzk2OA==","user":{"login":"ejgallego","id":7192257,"node_id":"MDQ6VXNlcjcxOTIyNTc=","avatar_url":"https://avatars.githubusercontent.com/u/7192257?v=4","gravatar_id":"","url":"https://api.github.com/users/ejgallego","html_url":"https://github.com/ejgallego","followers_url":"https://api.github.com/users/ejgallego/followers","following_url":"https://api.github.com/users/ejgallego/following{/other_user}","gists_url":"https://api.github.com/users/ejgallego/gists{/gist_id}","starred_url":"https://api.github.com/users/ejgallego/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ejgallego/subscriptions","organizations_url":"https://api.github.com/users/ejgallego/orgs","repos_url":"https://api.github.com/users/ejgallego/repos","events_url":"https://api.github.com/users/ejgallego/events{/privacy}","received_events_url":"https://api.github.com/users/ejgallego/received_events","type":"User","site_admin":false},"created_at":"2019-04-12T20:15:18Z","updated_at":"2019-04-12T20:15:18Z","author_association":"MEMBER","body":"Some commits to look at:\r\n- b4561c5047eb2383c2b718fd1cf9da8076497511 (#9690)\r\n- 3c0e9465029d7dcddff2c9a813cfd727a3ed4444 (merge of #7819)","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/482707968/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/482709026","html_url":"https://github.com/coq/coq/issues/9955#issuecomment-482709026","issue_url":"https://api.github.com/repos/coq/coq/issues/9955","id":482709026,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4MjcwOTAyNg==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-04-12T20:18:39Z","updated_at":"2019-04-12T20:18:56Z","author_association":"MEMBER","body":"@ejgallego No, I don't think so, it was broken already at 0bcbc990dcebce2e66f10aba462c9fed2c2eda06 (merge of #262) and bisect blames one of the commits in that PR.  Thanks, though!","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/482709026/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/482733232","html_url":"https://github.com/coq/coq/issues/9955#issuecomment-482733232","issue_url":"https://api.github.com/repos/coq/coq/issues/9955","id":482733232,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4MjczMzIzMg==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-04-12T21:46:39Z","updated_at":"2019-04-12T21:46:39Z","author_association":"MEMBER","body":"After some discussion with @ejgallego, this is apparently a regression due to a change in return clause annotations.  (Coq has apparently never been able to solve unification problems of the form `bool == ?1 x` for non-Var `x`.)  Would it be possible to allow backtracking on the return annotation of match statements if unification fails with the existing annotation?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/482733232/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]