[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515713","html_url":"https://github.com/coq/coq/issues/3117#issuecomment-337515713","issue_url":"https://api.github.com/repos/coq/coq/issues/3117","id":337515713,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTcxMw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-08-27T20:16:04Z","updated_at":"2017-10-18T09:07:25Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI would like support for writing things like\n\nRecord Foo := Eval simpl in { foo := 1 + 1; bar : 1 + 1 = 2 }.\nInductive Bar := Eval simpl in\n| bar1 : 1 + 1 = 2 -> Bar\n| bar2 : let x := 1 in x = x -> Bar.\nNotation Baz := (Eval simpl in 1 + 1).\n\nand have it be equivalent to\n\nRecord Foo := { foo := 2; bar : 2 = 2 }.\nInductive Bar := Eval simpl in\n| bar1 : 2 = 2 -> Bar\n| bar2 : 1 = 1 -> Bar.\nNotation Baz := 2.\n\n\nThat is, I would like [Eval <strategy> in ...] to be usable as an only parsing notation, which gets run at type inference time.\n\nThis is useful, for example, when notations or type inference give me a complicated type signature which is simplifiable in my particular case, if not in the general case, and I don't want to have to simplify the type of the projection every time I want to rewrite with it.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515713/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515714","html_url":"https://github.com/coq/coq/issues/3117#issuecomment-337515714","issue_url":"https://api.github.com/repos/coq/coq/issues/3117","id":337515714,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTcxNA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-11T20:42:38Z","updated_at":"2017-10-18T09:07:26Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nThe record case is essentially solved in trunk now that you can have tactics in terms. You can indeed write something like:\n\nLtac ev t :=\n  let t := eval simpl in t in\n  exact t.\n\nRecord Foo := { foo := $(ev (1 + 1))$; bar : $(ev (1 + 1 = 2))$ }.\nInductive Bar :=\n| bar1 : $(ev (1 + 1 = 2))$ -> Bar\n| bar2 : $(ev (let x := 1 in x = x))$ -> Bar.\n\nIt is slightly more verbose than what you propose, but this is also a bit more fine-grained, and more general.\n\nThe notation feature is not fixable easily, because it is not defined at a semantic level, but rather as a purely syntactic artifact. I doubt that we will provide you with such a feature one day, so I assume marking this bug as solved is OK.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515714/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515715","html_url":"https://github.com/coq/coq/issues/3117#issuecomment-337515715","issue_url":"https://api.github.com/repos/coq/coq/issues/3117","id":337515715,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTcxNQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-11T21:00:37Z","updated_at":"2017-10-18T09:07:26Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nGreat!  Thanks!  Can I have notations that evaluate to such a tactic, which is then run at notation substitution time?  Something like\n\nNotation \"a s+ b\" := ($(let t := constr:(a + b) in let t' := eval simpl in t in exact t')).\n\nAnd then have\n\nCheck 1 s+ 2.\n\ngive me 3?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515715/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515718","html_url":"https://github.com/coq/coq/issues/3117#issuecomment-337515718","issue_url":"https://api.github.com/repos/coq/coq/issues/3117","id":337515718,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTcxOA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-11T21:04:50Z","updated_at":"2017-10-18T09:07:26Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nOr is that what you meant by \"because it is not defined at a semantic level, but rather as a purely syntactic artifact\"?  If so, why would substituting in the $() syntax at the appropriate place not work?  (That is, I can't think of an example that requires notations to work at a semantic level rather than at a syntactic level, though I can see how it might require substituting notations earlier in the process.)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515718/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515719","html_url":"https://github.com/coq/coq/issues/3117#issuecomment-337515719","issue_url":"https://api.github.com/repos/coq/coq/issues/3117","id":337515719,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTcxOQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-11T23:13:54Z","updated_at":"2017-10-18T09:07:26Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nI mean that the interpretation of notations is made at a much earlier stage than something being able to compute. It is a mere syntactic substitution done before interpretation. For the recall, there are three levels of terms in Coq.\n\n1. The constr_expr, which is what the user sees and writes.\n2. The glob_constr, which is an intermediary stage where things get disambiguated (absolute names, etc.).\n3. The constr, which is kernel-level terms.\n\nComputation is typically made at level 3, while notations are lost on the translation stage from 1 to 2.\n\nIn addition, there is some purple magic involved to write recursive notations like the one of lists, where computation is unlikely to have any meaning at all.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515719/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515720","html_url":"https://github.com/coq/coq/issues/3117#issuecomment-337515720","issue_url":"https://api.github.com/repos/coq/coq/issues/3117","id":337515720,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNTcyMA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-12T04:43:31Z","updated_at":"2017-10-18T09:07:26Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nLtac splus a b := let t := constr:(a + b) in let t' := eval simpl in t in exact t'.\nNotation \"a 's+' b\" := ($(splus a b)$) (at level 70).\n\nToplevel input, characters 0-53:\n> Notation \"a 's+' b\" := ($(splus a b)$) (at level 70).\n> ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nError: a is unbound in the right-hand side.\n\n\nI'd expect the notation to go through fine, and then when I do\n\nCheck 1 s+ 2.\n\nI expect it to first become \"Check $(splus 1 2)$.\" and then evaluate that.  Is this doable?  (Should I open a new issue for this?)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337515720/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]