[{"url":"https://api.github.com/repos/coq/coq/issues/comments/376580414","html_url":"https://github.com/coq/coq/issues/7078#issuecomment-376580414","issue_url":"https://api.github.com/repos/coq/coq/issues/7078","id":376580414,"node_id":"MDEyOklzc3VlQ29tbWVudDM3NjU4MDQxNA==","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2018-03-27T16:03:25Z","updated_at":"2018-03-27T16:03:25Z","author_association":"MEMBER","body":"Note that this is not related to tactics nor to the tactic unification algorithm. It is only about the type inference unification and we can already observe the same behaviors by issuing the following:\r\n```coq\r\nInductive foo (n : nat) : nat -> Type := bar (_ : foo n n) : foo n n.\r\nFail Check fix a m (v : foo ?[n] m) := match v in foo _ m' return foo ?[p] m' with @bar _ v' => a ?[q] v' end.\r\nCheck let n:=?[n] in fix a m (v : foo n m) := match v in foo _ m return foo _ m with @bar _ v' => a _ v' end.\r\nFail Check fix a m (v : foo ?[n] m) := match v in foo _ m return foo ?n m with @bar _ v' => a ?[p] v' end.\r\nCheck fix a m (v : foo _ m) := match v in foo _ m' return foo _ m with @bar _ v' => a _ v' end.\r\n```\r\nThe first one looks indeed a bit disappointing, but in some sense it is also right. To solve `?p@{m:=?q@{m:=m}; m':=?q@{m:=m}} == ?p@{m:=m; m':=?q@{m:=m}}`, the solutions are different depending on how we solve `?q`. If `?q` is supposed to be `m`, `?p` can be any term depending on `m` and `m'` and the equation always hold, but if `?q` is different from `m`, `?p` is constrained to not depend on `m` and the equation holds only by restricting `?p`. I don't know what to conclude though. This is a typical case where we would need a more general form of disjunction of solutions than what we have now. But we could also adopt a heuristics telling that in the absence of information on `?q`, the only way to solve the equation is by being more restrictive than possibly necessary on `?p` and by restricting it to not depend on `m`. Finally, we could also adopt the position that since the equation has at least a solution, we succeed and keep the constraint open. In any case, thanks for the example. I'm adding it to the list of [open issues with unification](https://github.com/coq/coq/wiki/UnificationProblems).\r\n\r\nThe second one works because `?n` cannot depend on `m` anymore. Hence, we can only be in the second situation above. We have to restrict `?p` and the equation `?p = ?p` becomes trivial.\r\n\r\nThe third one is an issue (probably) related to CEP [#23](https://github.com/coq/ceps/pull/23/files) and still to be improved.\r\n\r\nThe fourth one is a different problem since `m` is renamed into `m'` only in binding position.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/376580414/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]