[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337546765","html_url":"https://github.com/coq/coq/issues/5049#issuecomment-337546765","issue_url":"https://api.github.com/repos/coq/coq/issues/5049","id":337546765,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0Njc2NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-08-26T18:17:07Z","updated_at":"2017-10-18T10:39:47Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI expect [setoid_rewrite] to be able to infer the argument [P] in the following \ncode, because there is a unique solution, and the solution is given by \n[pattern]:\n\nRequire Import Coq.Setoids.Setoid.\nAxiom foo : forall T (P : T -> Prop), (exists a : T, forall f, P (f a)) <-> \nTrue.\nGoal forall T, (exists a : T, forall f : T -> T, f a = f a) <-> True.\nProof.\n  intros.\n  setoid_rewrite (foo _ (fun fa => fa = fa)).\n  Undo.\n  setoid_rewrite (@ foo T). (* Error: Tactic failure: setoid rewrite failed: \nNothing to rewrite. *)\n\n\nIf I [Set Debug Tactic Unification], the problem seems to be here:\nDebug: ?X35@ {__:=T} (f a) ~= f a = f a\nDebug: ?X35@ {__:=T} ~= eq (f a)\nDebug: Leaving unification with failure\n\nSimilarly, if I do [apply (@ foo T)], I get:\nError: In environment\nT : Type\nUnable to unify\n \"((exists a : T, forall f : T -> T, ?M553 (f a)) -> True) /\\\n  (True -> exists a : T, forall f : T -> T, ?M553 (f a))\" with\n \"((exists a : T, forall f : T -> T, f a = f a) -> True) /\\\n  (True -> exists a : T, forall f : T -> T, f a = f a)\".\n\nand if I do [refine (@ foo T _)], I am left with the constraints:\n\nunification constraints:\n (a : T) (f : T -> T) |- ?Goal (f a) == f a = f a\n (a : T) (f : T -> T) |- ?Goal (f a) == f a = f a\n\n\nThe full log for setoid_rewrite:\nDebug: Starting unification\nDebug:\nexists a : T, forall f : T -> T, ?X41@ {__:=T} (f a) ~= (exists a : T, forall f \n: T -> T, f a = f a) <->\n                                                       True\nDebug: ex ~= iff\nDebug:\nexists a : T, forall f : T -> T, ?X41@ {__:=T} (f a) ~= ((exists a : T, forall f \n: T -> T, f a = f a) ->\n                                                        True) /\\\n                                                       (True ->\n                                                        exists a : T, forall f \n: T -> T, f a = f a)\nDebug: ex ~= and\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a : T, forall f : T -> T, ?X43@ {__:=T} (f a) ~= iff\nDebug: exists a : T, forall f : T -> T, ?X43@ {__:=T} (f a) ~= fun A B : Prop => \n(A -> B) /\\ (B -> A)\nDebug:\n(exists a : T, forall f : T -> T, ?X43@ {__:=T} (f a)) A ~= fun B : Prop => (A \n-> B) /\\ (B -> A)\nDebug: (exists a : T, forall f : T -> T, ?X43@ {__:=T} (f a)) A B ~= (A -> B) /\\ \n(B -> A)\nDebug: exists a : T, forall f : T -> T, ?X43@ {__:=T} (f a) ~= and\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug:\nexists a : T, forall f : T -> T, ?X44@ {__:=T} (f a) ~= exists a : T, forall f : \nT -> T, f a = f a\nDebug: ex ~= ex\nDebug: T ~= T\nDebug:\nfun a : T => forall f : T -> T, ?X44@ {__:=T} (f a) ~= fun a : T => forall f : T \n-> T, f a = f a\nDebug: T ~= T\nDebug: forall f : T -> T, ?X44@ {__:=T} (f a) ~= forall f : T -> T, f a = f a\nDebug: T -> T ~= T -> T\nDebug: T ~= T\nDebug: T ~= T\nDebug: ?X44@ {__:=T} (f a) ~= f a = f a\nDebug: ?X44@ {__:=T} ~= eq (f a)\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a : T, forall f : T -> T, ?X46@ {__:=T} (f a) ~= ex\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a : T, forall f : T -> T, ?X47@ {__:=T} (f a) ~= T\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug:\nexists a : T, forall f : T -> T, ?X48@ {__:=T} (f a) ~= fun a : T => forall f : \nT -> T, f a = f a\nDebug: (exists a : T, forall f : T -> T, ?X48@ {__:=T} (f a)) a ~= forall f : T \n-> T, f a = f a\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f : T -> T, ?X49@ {__:=T; __:=a} (f a0) ~= forall f \n: T -> T, f a = f a\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f : T -> T, ?X51@ {__:=T; __:=a} (f a0) ~= all\nDebug:\nexists a0 : T, forall f : T -> T, ?X51@ {__:=T; __:=a} (f a0) ~= fun (A : Type) \n(P : A -> Prop) =>\n                                                                forall x : A, P \nx\nDebug:\n(exists a0 : T, forall f : T -> T, ?X51@ {__:=T; __:=a} (f a0)) A ~= fun P : A \n-> Prop =>\n                                                                    forall x : \nA, P x\nDebug: (exists a0 : T, forall f : T -> T, ?X51@ {__:=T; __:=a} (f a0)) A P ~= \nforall x : A, P x\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f : T -> T, ?X52@ {__:=T; __:=a} (f a0) ~= T -> T\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f : T -> T, ?X54@ {__:=T; __:=a} (f a0) ~= \nBasics.arrow\nDebug: exists a0 : T, forall f : T -> T, ?X54@ {__:=T; __:=a} (f a0) ~= fun A B \n: Type => A -> B\nDebug: (exists a0 : T, forall f : T -> T, ?X54@ {__:=T; __:=a} (f a0)) A ~= fun \nB : Type => A -> B\nDebug: (exists a0 : T, forall f : T -> T, ?X54@ {__:=T; __:=a} (f a0)) A B ~= A \n-> B\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f : T -> T, ?X55@ {__:=T; __:=a} (f a0) ~= T\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f : T -> T, ?X56@ {__:=T; __:=a} (f a0) ~= T\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f : T -> T, ?X57@ {__:=T; __:=a} (f a0) ~= fun f : \nT -> T => f a = f a\nDebug: (exists a0 : T, forall f : T -> T, ?X57@ {__:=T; __:=a} (f a0)) f ~= f a \n= f a\nDebug: ex ~= @ eq\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f0 : T -> T, ?X58@ {__:=T; __:=a; __:=f} (f0 a0) ~= \nf a = f a\nDebug: ex ~= eq\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f0 : T -> T, ?X60@ {__:=T; __:=a; __:=f} (f0 a0) ~= \n@ eq\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f0 : T -> T, ?X61@ {__:=T; __:=a; __:=f} (f0 a0) ~= \nT\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f0 : T -> T, ?X62@ {__:=T; __:=a; __:=f} (f0 a0) ~= \nf a\nDebug: ex (A:=T) ~= f\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f0 : T -> T, ?X64@ {__:=T; __:=a; __:=f} (f0 a0) ~= \nf\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f0 : T -> T, ?X65@ {__:=T; __:=a; __:=f} (f0 a0) ~= \na\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f0 : T -> T, ?X66@ {__:=T; __:=a; __:=f} (f0 a0) ~= \nf a\nDebug: ex (A:=T) ~= f\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f0 : T -> T, ?X68@ {__:=T; __:=a; __:=f} (f0 a0) ~= \nf\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a0 : T, forall f0 : T -> T, ?X69@ {__:=T; __:=a; __:=f} (f0 a0) ~= \na\nDebug: Leaving unification with failure\nDebug: Starting unification\nDebug: exists a : T, forall f : T -> T, ?X70@ {__:=T} (f a) ~= True\nDebug: Leaving unification with failure\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337546765/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]