[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337544666","html_url":"https://github.com/coq/coq/issues/4891#issuecomment-337544666","issue_url":"https://api.github.com/repos/coq/coq/issues/4891","id":337544666,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NDY2Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-07-02T20:18:31Z","updated_at":"2017-10-18T10:32:51Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nGiven an equality of elements in a sigma type, it's possible to get a meaningful equality of their second projections:\n\nLemma path_sigT {A P} (x y : @ sigT A P)                                                                                                            \n      (H : x = y)                                                                                                                                  \n: { p : projT1 x = projT1 y & eq_rect _ P (projT2 x) _ p = projT2 y }.                                                                             \nProof.                                                                                                                                             \n  exists (f_equal _ H).                                                                                                                            \n  destruct H; reflexivity.                                                                                                                         \nDefined.\n\n[inversion] (perhaps modulo a compatibility option) should do this, so that destructing the first equality generated by [inversion] allows you to destruct the second one.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337544666/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/839939265","html_url":"https://github.com/coq/coq/issues/4891#issuecomment-839939265","issue_url":"https://api.github.com/repos/coq/coq/issues/4891","id":839939265,"node_id":"MDEyOklzc3VlQ29tbWVudDgzOTkzOTI2NQ==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-05-12T16:55:29Z","updated_at":"2021-05-12T16:55:29Z","author_association":"MEMBER","body":"We now have `inversion_sigma`, though it might be nice for `inversion` to handle this natively.  More generally, it'd be nice to have a way to make this proof more compact and cleaner without axioms (cc @herbelin, is there a depdestruct tractic with small inversions coming or something?) :\r\n```coq\r\n(* -*- coding: utf-8 -*- *)\r\nRequire Import Coq.Lists.List Coq.Logic.Eqdep_dec.\r\nImport ListNotations.\r\nLocal Open Scope list_scope.\r\nSet Decidable Equality Schemes.\r\nSet Boolean Equality Schemes.\r\nInductive type := NAT | arrow (s d : type).\r\nInductive term {var : type -> Type} : type -> Type :=\r\n| Abs {s d} (f : var s -> term d) : term (arrow s d)\r\n| Var {t} (v : var t) : term t\r\n| App {s d} (f : term (arrow s d)) (x : term s) : term d\r\n| Lit (v : nat) : term NAT\r\n.\r\nInductive related {var1 var2} : list { t : type & (var1 t * var2 t)%type } -> forall {t}, @term var1 t -> @term var2 t -> Prop :=\r\n| rel_Abs {s d Γ f g}\r\n  : (forall v1 v2, related (existT _ s (v1, v2) :: Γ) (t:=d) (f v1) (g v2))\r\n    -> related Γ (Abs f) (Abs g)\r\n| rel_Var {t Γ v1 v2}\r\n  : List.In (existT _ t (v1, v2)) Γ -> related Γ (Var v1) (Var v2)\r\n| rel_App {s d Γ} {f g : term (arrow s d)} {x y}\r\n  : related Γ f g -> related Γ x y -> related Γ (App f x) (App g y)\r\n| rel_Lit {Γ v} : related Γ (Lit v) (Lit v)\r\n.\r\nInductive related3 {var1 var2 var3}\r\n  : list { t : type & (var1 t * var2 t * var3 t)%type } -> forall {t}, @term var1 t -> @term var2 t -> @term var3 t -> Prop :=\r\n| rel3_Abs {s d Γ f g h}\r\n  : (forall v1 v2 v3, related3 (existT _ s (v1, v2, v3) :: Γ) (t:=d) (f v1) (g v2) (h v3))\r\n    -> related3 Γ (Abs f) (Abs g) (Abs h)\r\n| rel3_Var {t Γ v1 v2 v3}\r\n  : List.In (existT _ t (v1, v2, v3)) Γ -> related3 Γ (Var v1) (Var v2) (Var v3)\r\n| rel3_App {s d Γ} {f g h : term (arrow s d)} {x y z}\r\n  : related3 Γ f g h -> related3 Γ x y z -> related3 Γ (App f x) (App g y) (App h z)\r\n| rel3_Lit {Γ v} : related3 Γ (Lit v) (Lit v) (Lit v)\r\n.\r\nGoal forall var1 var2 var3 Γ Γ1 Γ2 Γ3 t x y z w,\r\n    Γ1 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v1, (v1, v2, v3))) Γ\r\n    -> Γ2 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v2, (v1, v2, v3))) Γ\r\n    -> Γ3 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v3, (v1, v2, v3))) Γ\r\n    -> @related var1 _ Γ1 t x w\r\n    -> @related var2 _ Γ2 t y w\r\n    -> @related var3 _ Γ3 t z w\r\n    -> @related3 var1 var2 var3 Γ t x y z.\r\nProof.\r\n  intros var1 var2 var3 Γ Γ1 Γ2 Γ3 t x y z w H1 H2 H3 HR1 HR2 HR3.\r\n  revert Γ Γ2 Γ3 H1 H2 H3 HR2 HR3; induction HR1; intros; inversion HR2; inversion HR3.\r\n  (*   H11 : Γ4 = Γ3\r\n  H10 : s1 = s\r\n  H13 : d1 = d\r\n  H14 : Abs f1 = z\r\n  H15 : existT (fun d : type => var1 s * var2 s * var3 s -> term d) d g1 =\r\n        existT (fun d : type => var1 s * var2 s * var3 s -> term d) d g\r\n  ============================\r\n  related3 Γ0 (Abs f) (Abs f0) (Abs f1)\r\n*)\r\n  all: repeat first [ progress subst\r\n                    | progress inversion_sigma\r\n                    | progress cbn [eq_rect List.map List.In projT1 projT2] in *\r\n                    | progress intros\r\n                    | match goal with\r\n                      | [ H : pair _ _ = pair _ _ |- _ ] => inversion H; clear H\r\n                      | [ H : ex _ |- _ ] => destruct H\r\n                      | [ H : sigT _ |- _ ] => destruct H\r\n                      | [ H : prod _ _ |- _ ] => destruct H\r\n                      | [ H : and _ _ |- _ ] => destruct H\r\n                      | [ H : ?x = ?x :> type |- _ ] => pose proof (UIP_dec type_eq_dec eq_refl H); subst H\r\n                      end\r\n                    | constructor\r\n                    | solve [ eauto ]\r\n                    | rewrite in_map_iff in *\r\n                    | match goal with\r\n                      | [ H : context[_ -> related3 _ _ _ _] |- related3 _ _ _ _ ] => eapply H; clear H\r\n                      end ].\r\nQed.\r\n```\r\n\r\nBtw, here is a semi-manual-small-inversion version of this proof, without needing `UIP_dec`, where I'd like to be able to get rid of all of the `refine_*` tactics in favor of just some sort of non-axiom-based-inversion tactic:\r\n```coq\r\n(* -*- coding: utf-8 -*- *)\r\nRequire Import Coq.Lists.List Coq.Logic.Eqdep_dec.\r\nImport ListNotations.\r\nLocal Open Scope list_scope.\r\nSet Decidable Equality Schemes.\r\nSet Boolean Equality Schemes.\r\nInductive type := NAT | arrow (s d : type).\r\nInductive term {var : type -> Type} : type -> Type :=\r\n| Abs {s d} (f : var s -> term d) : term (arrow s d)\r\n| Var {t} (v : var t) : term t\r\n| App {s d} (f : term (arrow s d)) (x : term s) : term d\r\n| Lit (v : nat) : term NAT\r\n.\r\nInductive related {var1 var2} : list { t : type & (var1 t * var2 t)%type } -> forall {t}, @term var1 t -> @term var2 t -> Prop :=\r\n| rel_Abs {s d Γ f g}\r\n  : (forall v1 v2, related (existT _ s (v1, v2) :: Γ) (t:=d) (f v1) (g v2))\r\n    -> related Γ (Abs f) (Abs g)\r\n| rel_Var {t Γ v1 v2}\r\n  : List.In (existT _ t (v1, v2)) Γ -> related Γ (Var v1) (Var v2)\r\n| rel_App {s d Γ} {f g : term (arrow s d)} {x y}\r\n  : related Γ f g -> related Γ x y -> related Γ (App f x) (App g y)\r\n| rel_Lit {Γ v} : related Γ (Lit v) (Lit v)\r\n.\r\nInductive related3 {var1 var2 var3}\r\n  : list { t : type & (var1 t * var2 t * var3 t)%type } -> forall {t}, @term var1 t -> @term var2 t -> @term var3 t -> Prop :=\r\n| rel3_Abs {s d Γ f g h}\r\n  : (forall v1 v2 v3, related3 (existT _ s (v1, v2, v3) :: Γ) (t:=d) (f v1) (g v2) (h v3))\r\n    -> related3 Γ (Abs f) (Abs g) (Abs h)\r\n| rel3_Var {t Γ v1 v2 v3}\r\n  : List.In (existT _ t (v1, v2, v3)) Γ -> related3 Γ (Var v1) (Var v2) (Var v3)\r\n| rel3_App {s d Γ} {f g h : term (arrow s d)} {x y z}\r\n  : related3 Γ f g h -> related3 Γ x y z -> related3 Γ (App f x) (App g y) (App h z)\r\n| rel3_Lit {Γ v} : related3 Γ (Lit v) (Lit v) (Lit v)\r\n.\r\nFixpoint rel3_of_rel2\r\n         {var1 var2 var3 Γ Γ1 Γ2 Γ3 t x y z w}\r\n         (H1 : Γ1 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v1, (v1, v2, v3))) Γ)\r\n         (H2 : Γ2 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v2, (v1, v2, v3))) Γ)\r\n         (H3 : Γ3 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v3, (v1, v2, v3))) Γ)\r\n         (HR1 : @related var1 _ Γ1 t x w)\r\n         (HR2 : @related var2 _ Γ2 t y w)\r\n         (HR3 : @related var3 _ Γ3 t z w)\r\n         {struct w}\r\n  : @related3 var1 var2 var3 Γ t x y z.\r\nProof.\r\n  specialize (@rel3_of_rel2 var1 var2 var3).\r\n  pose w as w'.\r\n  destruct w.\r\n  { lazymatch (eval cbv [w'] in w') with\r\n    | Abs ?f => specialize (fun Γ Γ1 Γ2 Γ3 x y z v => rel3_of_rel2 Γ Γ1 Γ2 Γ3 _ x y z (f v))\r\n    end; clear w'.\r\n    Ltac refine_Abs HR :=\r\n      lazymatch type of HR with\r\n      | @related _ _ ?Γ (arrow ?s ?d) ?x (Abs ?f)\r\n        => let mov := move Γ at top; move s before Γ; move d before s; move x before d; move f before x; move HR before f in\r\n           mov; revert dependent f; intros f HR;\r\n           mov; revert dependent x; intros x HR;\r\n           mov; revert dependent d; intros d x f HR;\r\n           mov; revert dependent s; intros s x f HR;\r\n           mov; revert dependent Γ; intros Γ HR;\r\n           mov; pattern Γ, s, d, x, f\r\n      end;\r\n      let P := lazymatch goal with |- ?P _ _ _ _ _ => P end in\r\n      refine match HR in @related _ _ Γ t x y return match y in term t return term t -> Prop with\r\n                                                     | Abs f => fun x => P Γ _ _ x f\r\n                                                     | _ => fun _ => IDProp\r\n                                                     end x\r\n             with\r\n             | rel_Abs H => _\r\n             | _ => idProp\r\n             end;\r\n      lazymatch type of HR with\r\n      | @related _ _ ?Γ (arrow ?s ?d) ?x (Abs ?f)\r\n        => clear HR Γ s d x f\r\n      end;\r\n      rename H into HR; intros.\r\n    refine_Abs HR1.\r\n    refine_Abs HR2.\r\n    refine_Abs HR3.\r\n    constructor; intros.\r\n    eapply rel3_of_rel2; now try (eapply HR1 + eapply HR2 + eapply HR3); cbn [List.map]; apply (f_equal2 cons). }\r\n  { clear rel3_of_rel2.\r\n    Ltac refine_Var HR :=\r\n      lazymatch type of HR with\r\n      | @related _ _ ?Γ ?t ?x (Var ?v)\r\n        => let mov := move Γ at top; move t before Γ; move x before t; move v before x; move HR before v in\r\n           mov; revert dependent v; intros v HR;\r\n           mov; revert dependent x; intros x HR;\r\n           mov; revert dependent t; intros t x v HR;\r\n           mov; revert dependent Γ; intros Γ HR;\r\n           mov; pattern Γ, t, x, v\r\n      end;\r\n      let P := lazymatch goal with |- ?P _ _ _ _ => P end in\r\n      refine match HR in @related _ _ Γ t x y return match y in term t return term t -> Prop with\r\n                                                     | Var v => fun x => P Γ _ x v\r\n                                                     | _ => fun _ => IDProp\r\n                                                     end x\r\n             with\r\n             | rel_Var H => _\r\n             | _ => idProp\r\n             end;\r\n      lazymatch type of HR with\r\n      | @related _ _ ?Γ ?t ?x (Var ?v)\r\n        => clear HR Γ t x v\r\n      end;\r\n      rename H into HR; intros.\r\n    refine_Var HR1.\r\n    refine_Var HR2.\r\n    refine_Var HR3.\r\n    constructor; intros.\r\n    subst; rewrite !in_map_iff in *.\r\n    repeat match goal with\r\n           | [ H : ex _ |- _ ] => destruct H\r\n           | [ H : sigT _ |- _ ] => destruct H\r\n           | [ H : prod _ _ |- _ ] => destruct H\r\n           | [ H : and _ _ |- _ ] => destruct H\r\n           end.\r\n    inversion_sigma; subst; cbn [eq_rect] in *.\r\n    repeat match goal with\r\n           | [ H : pair _ _ = pair _ _ |- _ ] => inversion H; clear H\r\n           end.\r\n    subst.\r\n    assumption. }\r\n  { lazymatch (eval cbv [w'] in w') with\r\n    | App ?f ?v\r\n      => pose proof (fun Γ Γ1 Γ2 Γ3 x y z => rel3_of_rel2 Γ Γ1 Γ2 Γ3 _ x y z f) as rel3_of_rel2_1;\r\n         pose proof (fun Γ Γ1 Γ2 Γ3 x y z => rel3_of_rel2 Γ Γ1 Γ2 Γ3 _ x y z v) as rel3_of_rel2_2;\r\n         clear rel3_of_rel2\r\n    end; clear w'.\r\n    Ltac refine_App HR :=\r\n      lazymatch type of HR with\r\n      | @related _ _ ?Γ _ ?x (App (s:=?s) (d:=?d) ?f ?v)\r\n        => let mov := move Γ at top; move s before Γ; move d before s; move x before d; move f before x; move v before f;\r\n                      move HR before v in\r\n           mov; revert dependent v; intros v HR;\r\n           mov; revert dependent f; intros f HR;\r\n           mov; revert dependent x; intros x HR;\r\n           mov; revert dependent d; intros d x f HR;\r\n           mov; revert dependent s; intros s f v HR;\r\n           mov; revert dependent Γ; intros Γ HR;\r\n           mov; pattern Γ, s, d, x, f, v\r\n      end;\r\n      let P := lazymatch goal with |- ?P _ _ _ _ _ _ => P end in\r\n      refine match HR in @related _ _ Γ t x y return match y in term t return term t -> Prop with\r\n                                                     | App f v => fun x => P Γ _ _ x f v\r\n                                                     | _ => fun _ => IDProp\r\n                                                     end x\r\n             with\r\n             | rel_App H0 H1 => _\r\n             | _ => idProp\r\n             end;\r\n      lazymatch type of HR with\r\n      | @related _ _ ?Γ _ ?x (App (s:=?s) (d:=?d) ?f ?v)\r\n        => clear HR Γ s d x f v\r\n      end;\r\n      intros;\r\n      rename H0 into HR;\r\n      let HR1 := fresh HR in\r\n      rename H1 into HR1.\r\n    refine_App HR1.\r\n    refine_App HR2.\r\n    refine_App HR3.\r\n    constructor; intros; (eapply rel3_of_rel2_1 + eapply rel3_of_rel2_2); eassumption. }\r\n  { clear rel3_of_rel2.\r\n    Ltac refine_Lit HR :=\r\n      lazymatch type of HR with\r\n      | @related _ _ ?Γ _ ?x (Lit ?v)\r\n        => let mov := move Γ at top; move x before Γ; move v before x; move HR before v in\r\n           mov; revert dependent v; intros v HR;\r\n           mov; revert dependent x; intros x HR;\r\n           mov; revert dependent Γ; intros Γ HR;\r\n           mov; pattern Γ, x, v\r\n      end;\r\n      let P := lazymatch goal with |- ?P _ _ _ => P end in\r\n      refine match HR in @related _ _ Γ t x y return match y in term t return term t -> Prop with\r\n                                                     | Lit v => fun x => P Γ x v\r\n                                                     | _ => fun _ => IDProp\r\n                                                     end x\r\n             with\r\n             | rel_Lit => _\r\n             | _ => idProp\r\n             end;\r\n      lazymatch type of HR with\r\n      | @related _ _ ?Γ _ ?x (Lit ?v)\r\n        => clear HR Γ x v\r\n      end;\r\n      intros.\r\n    refine_Lit HR1.\r\n    refine_Lit HR2.\r\n    refine_Lit HR3.\r\n    constructor. }\r\nQed.\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/839939265/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]