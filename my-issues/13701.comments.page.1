[{"url":"https://api.github.com/repos/coq/coq/issues/comments/753221122","html_url":"https://github.com/coq/coq/issues/13701#issuecomment-753221122","issue_url":"https://api.github.com/repos/coq/coq/issues/13701","id":753221122,"node_id":"MDEyOklzc3VlQ29tbWVudDc1MzIyMTEyMg==","user":{"login":"jfehrle","id":1253341,"node_id":"MDQ6VXNlcjEyNTMzNDE=","avatar_url":"https://avatars.githubusercontent.com/u/1253341?v=4","gravatar_id":"","url":"https://api.github.com/users/jfehrle","html_url":"https://github.com/jfehrle","followers_url":"https://api.github.com/users/jfehrle/followers","following_url":"https://api.github.com/users/jfehrle/following{/other_user}","gists_url":"https://api.github.com/users/jfehrle/gists{/gist_id}","starred_url":"https://api.github.com/users/jfehrle/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jfehrle/subscriptions","organizations_url":"https://api.github.com/users/jfehrle/orgs","repos_url":"https://api.github.com/users/jfehrle/repos","events_url":"https://api.github.com/users/jfehrle/events{/privacy}","received_events_url":"https://api.github.com/users/jfehrle/received_events","type":"User","site_admin":false},"created_at":"2020-12-31T22:53:44Z","updated_at":"2020-12-31T22:53:44Z","author_association":"CONTRIBUTOR","body":"The doc for `rewrite_strat` isn't very detailed for such a complex tactic.\r\n\r\nMy guess is that innermost/outermost apply to terms with nested rewriting opportunities\r\nsuch as `(a + 0) + 0` rather than finding the deepest matching term across independent subterms.  The latter seems like considerably more programming effort for hmm, what benefit?  If you can find convincing examples to clarify how this construct is processed, we could add that explanation to the doc.  Getting the description of the entire tactic into good shape is a bit of a project that's probably driven by trying lots of examples and perhaps reading the code.\r\n\r\nI'm also curious how often this is used, how important it is to users and whether it overlaps significantly with other features.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/753221122/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/753227398","html_url":"https://github.com/coq/coq/issues/13701#issuecomment-753227398","issue_url":"https://api.github.com/repos/coq/coq/issues/13701","id":753227398,"node_id":"MDEyOklzc3VlQ29tbWVudDc1MzIyNzM5OA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2020-12-31T23:53:33Z","updated_at":"2020-12-31T23:53:55Z","author_association":"MEMBER","body":"> My guess is that innermost/outermost apply to terms with nested rewriting opportunities\r\n> such as `(a + 0) + 0` rather than finding the deepest matching term across independent subterms.\r\n\r\nAh, that seems like a likely explanation for where the name comes from.  Indeed the names make sense when all opportunities are strictly nested.  But the names don't generalize well to cases when the opportunities are not strictly nested; don't you think it's a bit weird that both \"innermost\" and \"outermost\" will rewrite the parenthesized zero in `((a + (0)) + ((((a + 0) + 0) + 0) + 0)`?\r\n\r\n> The latter seems like considerably more programming effort for hmm, what benefit? \r\n\r\nDoing breadth-first search can lead to significantly more efficient strategies in some cases.  For example, I think some variant of breadth-first might be more efficient for https://github.com/coq/coq/issues/13576#issuecomment-753226532\r\n\r\n> I'm also curious how often this is used, how important it is to users and whether it overlaps significantly with other features.\r\n\r\nThe sense I have is that complex `rewrite_strat` strategies are not often used, possibly in large part due to bugs in `rewrite_strat` (such as that sequences starting with `eval red_expr` pretty much always build ill-typed terms; that you need to sprinkle `; eval cbv beta` after everything to get all the rewriting that's desired; that there are other bugs lurking (I've managed to get `rewrite_strat` to build an ill-typed term apart from the `eval red_expr` bug, but haven't minimized this)) and usability issues (debugging slow calls to `rewrite_strat` that don't spend their time in typeclass search is effectively impossible; the rewriting strategies cannot be named and combined, so it's hard to reuse strategies; the precedence is very strange; the `choice` operator is binary rather than nary (perhaps it should be replaced with `+`); the underlying engine is still slow, I suspect due to pervasive use of evars and their named instances; the strategy language isn't quite expressive enough to control rewriting and term traversal in a fully-customizable way; discovering what typeclass instances need to be added to make it perform well is a bit of a pain).","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/753227398/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/753255093","html_url":"https://github.com/coq/coq/issues/13701#issuecomment-753255093","issue_url":"https://api.github.com/repos/coq/coq/issues/13701","id":753255093,"node_id":"MDEyOklzc3VlQ29tbWVudDc1MzI1NTA5Mw==","user":{"login":"jfehrle","id":1253341,"node_id":"MDQ6VXNlcjEyNTMzNDE=","avatar_url":"https://avatars.githubusercontent.com/u/1253341?v=4","gravatar_id":"","url":"https://api.github.com/users/jfehrle","html_url":"https://github.com/jfehrle","followers_url":"https://api.github.com/users/jfehrle/followers","following_url":"https://api.github.com/users/jfehrle/following{/other_user}","gists_url":"https://api.github.com/users/jfehrle/gists{/gist_id}","starred_url":"https://api.github.com/users/jfehrle/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jfehrle/subscriptions","organizations_url":"https://api.github.com/users/jfehrle/orgs","repos_url":"https://api.github.com/users/jfehrle/repos","events_url":"https://api.github.com/users/jfehrle/events{/privacy}","received_events_url":"https://api.github.com/users/jfehrle/received_events","type":"User","site_admin":false},"created_at":"2021-01-01T04:57:18Z","updated_at":"2021-01-01T04:57:18Z","author_association":"CONTRIBUTOR","body":"If their meaning is explained, \"innermost\" and \"outermost\" seem like reasonable names to me.\r\n\r\nI tend to think that Coq accumulates multiple tactics for doing similar things with very different code and different sets of limitations/bugs.  I suspect people are more likely to contribute new chunks of code rather than to perfect and extend existing similar functionality.  The latter is harder to do--you have to be careful not break the existing behavior.  It would be an interesting exercise to identify tactics that have significant overlap that could be combined and generalized.  (Really, shouldn't it be possible/easy to implement `rewrite_strat` as an Ltac function?  Perhaps with Ltac extensions?  That might have simpler syntax.  Or even have a way to use a term to define a tactic...)  Seems like a big topic, perhaps we can discuss it sometime.\r\n\r\nSomething like the follwing would make a good example to explain the behavior.  I couldn't find a theorem for `nat` commutativity--is it in the standard library somewhere?\r\n\r\n```\r\nRequire Import Coq.Classes.Morphisms Coq.Setoids.Setoid Nat.\r\nTheorem comm: forall a b : nat, a + b = b + a.\r\nAdmitted.\r\nSet Printing Parentheses.\r\nGoal forall a b c: nat, a + b + c = 0.\r\n  rewrite_strat outermost <- comm.\r\nAbort.\r\nGoal forall a b c: nat, a + b + c = 0.\r\n  rewrite_strat innermost <- comm.\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/753255093/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/753406649","html_url":"https://github.com/coq/coq/issues/13701#issuecomment-753406649","issue_url":"https://api.github.com/repos/coq/coq/issues/13701","id":753406649,"node_id":"MDEyOklzc3VlQ29tbWVudDc1MzQwNjY0OQ==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-01-02T00:01:42Z","updated_at":"2021-01-02T00:01:42Z","author_association":"MEMBER","body":"> I couldn't find a theorem for `nat` commutativity--is it in the standard library somewhere?\r\n\r\n```coq\r\nRequire Import Coq.Arith.Arith.\r\nSearch (?x + ?y = ?y + ?x).\r\n(* Nat.add_comm: forall n m : nat, n + m = m + n *)\r\n```\r\n\r\n> I tend to think that Coq accumulates multiple tactics for doing similar things with very different code and different sets of limitations/bugs. I suspect people are more likely to contribute new chunks of code rather than to perfect and extend existing similar functionality. The latter is harder to do--you have to be careful not break the existing behavior.\r\n\r\nIt's already the case that `setoid_rewrite` and `rewrite_strat` share an implementation, and there's https://github.com/coq/coq/issues/6105 about subsuming `autorewrite` (and presumably `rewrite`) into `rewrite_strat`.  I suppose there might be a bit of code duplication between `rewrite` and `replace`.  But really `rewrite_strat` is the most general version of rewriting present in Coq.\r\n\r\n> Really, shouldn't it be possible/easy to implement `rewrite_strat` as an Ltac function? Perhaps with Ltac extensions?\r\n\r\nDefinitely not easy.  Ltac does not support recursing under binders in any sane fashion, and the performance of an Ltac implementation would be horrible.  Moreover the two hard parts are doing subterm matching on lemmas whose arguments aren't filled in (which neither Ltac nor Ltac2 provide any special handling for) and building the proof term that proves the rewrite, which I expect Ltac/Ltac2 won't help at all with.  Presumably the OCaml code for `rewrite_strat` could be mostly ported to Ltac2 (modulo syntax extensions, uses of coqlib constants, reading from hint databases; controlling opacity information based on databases; and invoking typeclass resolution on many goals in parallel in a way that results in backtracking (though maybe `typeclasses eauto` is already multigoal in this way?)).  However, I expect that due to missing usability features of Ltac2, the resulting code would be a bit harder to read.  And in fact I don't expect any benefit from moving the implementation to Ltac2 at this time, though I hope Ltac2 might become expressive and nice enough some day to move things like `rewrite_strat` from OCaml to Ltac2.\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/753406649/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/753421136","html_url":"https://github.com/coq/coq/issues/13701#issuecomment-753421136","issue_url":"https://api.github.com/repos/coq/coq/issues/13701","id":753421136,"node_id":"MDEyOklzc3VlQ29tbWVudDc1MzQyMTEzNg==","user":{"login":"jfehrle","id":1253341,"node_id":"MDQ6VXNlcjEyNTMzNDE=","avatar_url":"https://avatars.githubusercontent.com/u/1253341?v=4","gravatar_id":"","url":"https://api.github.com/users/jfehrle","html_url":"https://github.com/jfehrle","followers_url":"https://api.github.com/users/jfehrle/followers","following_url":"https://api.github.com/users/jfehrle/following{/other_user}","gists_url":"https://api.github.com/users/jfehrle/gists{/gist_id}","starred_url":"https://api.github.com/users/jfehrle/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/jfehrle/subscriptions","organizations_url":"https://api.github.com/users/jfehrle/orgs","repos_url":"https://api.github.com/users/jfehrle/repos","events_url":"https://api.github.com/users/jfehrle/events{/privacy}","received_events_url":"https://api.github.com/users/jfehrle/received_events","type":"User","site_admin":false},"created_at":"2021-01-02T02:49:14Z","updated_at":"2021-01-02T02:49:14Z","author_association":"CONTRIBUTOR","body":"A momentary excess of enthusiasm about doing in Ltac*, but perhaps someday.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/753421136/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]