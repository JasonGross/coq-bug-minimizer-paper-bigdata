[{"url":"https://api.github.com/repos/coq/coq/issues/comments/967548493","html_url":"https://github.com/coq/coq/issues/15180#issuecomment-967548493","issue_url":"https://api.github.com/repos/coq/coq/issues/15180","id":967548493,"node_id":"IC_kwDOABUDh845q55N","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-11-12T21:01:33Z","updated_at":"2021-11-12T21:01:33Z","author_association":"MEMBER","body":"Here's a small example:\r\n```coq\r\nRequire Import Coq.extraction.Extraction.\r\nRequire Import Coq.extraction.ExtrHaskellBasic.\r\nModule type.\r\n  Inductive type {base_type : Type} := base (t : base_type) | arrow (s d : type).\r\n  Global Arguments type : clear implicits.\r\n  Fixpoint interp {base_type} (base_interp : base_type -> Type) (t : type base_type) : Type\r\n    := match t with\r\n       | base t => base_interp t\r\n       | arrow s d => @interp _ base_interp s -> @interp _ base_interp d\r\n       end.\r\nEnd type.\r\nNotation type := type.type.\r\nGlobal Arguments type.base {_} _.\r\nModule base.\r\n  Module type.\r\n    Inductive type {base_type : Type} := type_base (t : base_type) | prod (A B : type) | list (A : type) | option (A : type) | unit.\r\n    Global Arguments type : clear implicits.\r\n  End type.\r\n  Notation type := type.type.\r\n  Fixpoint interp {base} (base_interp : base -> Type) (ty : type base)\r\n    := match ty with\r\n       | type.type_base t => base_interp t\r\n       | type.unit => Datatypes.unit\r\n       | type.prod A B => interp base_interp A * interp base_interp B\r\n       | type.list A => Datatypes.list (interp base_interp A)\r\n       | type.option A => Datatypes.option (interp base_interp A)\r\n       end%type.\r\nEnd base.\r\nClass ExprInfoT :=\r\n  {\r\n  base : Type;\r\n  ident : type (base.type base) -> Type;\r\n  base_interp : base -> Type;\r\n  ident_interp : forall t, ident t -> type.interp (base.interp base_interp) t\r\n  }.\r\nExtraction Language Haskell.\r\nAxiom IO_unit : Set.\r\nAxiom IO_return : unit -> IO_unit.\r\nExtract Inlined Constant IO_return => \"GHC.Base.return\".\r\nExtract Inlined Constant IO_unit => \"GHC.Base.IO ()\".\r\nDefinition seq {A} {B} (x : A) (y : B) := y.\r\nDefinition main : IO_unit\r\n  := seq (@ident_interp) (IO_return tt).\r\nRedirect \"foo.hs\" Recursive Extraction main.\r\n```\r\ngenerates\r\n```haskell\r\n{-# OPTIONS_GHC -cpp -XMagicHash #-}\r\n{- For Hugs, use the option -F\"cpp -P -traditional\" -}\r\n\r\nmodule Main where\r\n\r\nimport qualified Prelude\r\n\r\n#ifdef __GLASGOW_HASKELL__\r\nimport qualified GHC.Base\r\n#else\r\n-- HUGS\r\nimport qualified IOExts\r\n#endif\r\n\r\n#ifdef __GLASGOW_HASKELL__\r\ntype Any = GHC.Base.Any\r\n#else\r\n-- HUGS\r\ntype Any = ()\r\n#endif\r\n\r\ndata Type base_type =\r\n   Base base_type\r\n | Arrow (Type base_type) (Type base_type)\r\n\r\ntype Interp base_type base_interp = Any\r\n\r\ndata Type0 base_type =\r\n   Type_base base_type\r\n | Prod (Type0 base_type) (Type0 base_type)\r\n | List (Type0 base_type)\r\n | Option (Type0 base_type)\r\n | Unit\r\n\r\ntype Interp0 base base_interp = Any\r\n\r\ntype ExprInfoT =\r\n  (Type (Type0 Any)) -> Any -> Interp (Type0 Any) (Interp0 Any Any)\r\n  -- singleton inductive, whose constructor was Build_ExprInfoT\r\n\r\ntype Base0 = Any\r\n\r\ntype Ident = Any\r\n\r\ntype Base_interp = Any\r\n\r\nident_interp :: ExprInfoT -> (Type (Type0 Base0)) -> Ident -> Interp (Type0 Base0) (Interp0 Base0 Base_interp)\r\nident_interp exprInfoT =\r\n  exprInfoT\r\n\r\nseq :: a1 -> a2 -> a2\r\nseq _ y =\r\n  y\r\n\r\nmain :: GHC.Base.IO ()\r\nmain =\r\n  seq ident_interp (GHC.Base.return ())\r\n```\r\nwhich errors with\r\n```\r\nfoo.hs:37:1: error:\r\nError:     • Uninferrable type variables k0, k1, k2 in\r\n      the type synonym right-hand side:\r\n      Type (Type0 (Any @{*}))\r\n      -> Any @{*}\r\n      -> Interp\r\n           @{*}\r\n           @{*}\r\n           @{k0}\r\n           (Type0 (Any @{*}))\r\n           (Interp0 @{k0} @{k1} @{k2} (Any @{k1}) (Any @{k2}))\r\n    • In the type declaration for ‘ExprInfoT’\r\n   |\r\n37 | type ExprInfoT =\r\n   | ^^^^^^^^^^^^^^^^...\r\n```\r\nas as per https://github.com/JasonGross/test-haskell-bug/runs/4194435468?check_suite_focus=true in Haskell 9.2.1, but succeeds in Haskell 9.0.1 as per https://github.com/JasonGross/test-haskell-bug/runs/4194435425?check_suite_focus=true","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/967548493/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/967569806","html_url":"https://github.com/coq/coq/issues/15180#issuecomment-967569806","issue_url":"https://api.github.com/repos/coq/coq/issues/15180","id":967569806,"node_id":"IC_kwDOABUDh845q_GO","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-11-12T21:14:50Z","updated_at":"2021-11-12T21:14:50Z","author_association":"MEMBER","body":"Reported as an issue in ghc at https://gitlab.haskell.org/ghc/ghc/-/issues/20675 , let's see if the upstream devs say this is an intended breakage or not","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/967569806/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/967846746","html_url":"https://github.com/coq/coq/issues/15180#issuecomment-967846746","issue_url":"https://api.github.com/repos/coq/coq/issues/15180","id":967846746,"node_id":"IC_kwDOABUDh845sCta","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-11-13T08:49:43Z","updated_at":"2021-11-13T08:51:40Z","author_association":"MEMBER","body":"Reply has been obtained:\r\n> This is expected behavior. GHC 9.2.1 now uses the GHC2021 language extension set, which includes PolyKinds. This makes the arguments to `Interp0` poly-kinded. When `Interp0` is used on the right-hand side of the `ExprInfoT` type synonym, GHC is unable to figure out what the kinds of `Interp0`'s arguments should be, and that is an error.\r\nTo fix this, some potential options are:\r\n>\r\n> 1. Use `-XNoPolyKinds` to disable this behavior.\r\n> 2. Alternatively, enable `-XHaskell98` or `-XHaskell2010`, which imply `-XNoPolyKinds`. (Prior to GHC 9.2.1, the default language set was Haskell2010.)\r\n> 3. Give explicit kind annotations to `Interp0` to prevent them from becoming poly-kinded.\r\n\r\n\r\nI take it we either want to do 1 or 2?  It'd be nice to get this in 8.15, maybe even backported into an 8.14 point release.  cc @coq/extraction-maintainers \r\n\r\n@tchajed @zeldovich do either of you have thoughts on the preferred solution here?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/967846746/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/968951456","html_url":"https://github.com/coq/coq/issues/15180#issuecomment-968951456","issue_url":"https://api.github.com/repos/coq/coq/issues/15180","id":968951456,"node_id":"IC_kwDOABUDh845wQag","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-11-15T14:14:22Z","updated_at":"2021-11-15T14:14:22Z","author_association":"MEMBER","body":"The Haskell devs replied with yet another option:\r\n```haskell\r\ntype Any = GHC.Base.Any :: Data.Kind.Type\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/968951456/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]