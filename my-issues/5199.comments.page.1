[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549109","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-337549109","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":337549109,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0OTEwOQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-11-14T17:09:50Z","updated_at":"2021-08-21T14:17:04Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nNot sure if 8.6beta2 is the right milestone for this...\r\n```coq\r\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-boot\" \"-nois\") -*- *)\r\n(* File reduced by coq-bug-finder from original input, then from 286 lines to \r\n27 lines, then from 224 lines to 53 lines, then from 218 lines to 56 lines, \r\nthen from 269 lines to 180 lines, then from 132 lines to 48 lines, then from \r\n253 lines to 65 lines, then from 79 lines to 65 lines *)\r\n(* coqc version 8.6.0 (November 2016) compiled on Nov 12 2016 14:43:52 with \r\nOCaml 4.02.3\r\n   coqtop version jgross-Leopard-WS:/home/jgross/Downloads/coq/coq-v8.6,v8.6 \r\n(7e992fa784ee6fa48af8a2e461385c094985587d) *)\r\nAxiom admit : forall {T}, T.\r\nSet Printing Implicit.\r\nInductive nat := O | S (_ : nat).\r\nAxiom f : forall (_ _ : nat), nat.\r\nRecord ZLikeOps (e : nat)\r\n  := { LargeT : Type ; SmallT : Type ; CarryAdd : forall (_ _ : LargeT), LargeT \r\n}.\r\nAxiom LargeT' : forall {e} {ops : ZLikeOps e}, Type.\r\nAxiom CarryAdd' : forall {e} {ops : ZLikeOps e} (_ _ : @ LargeT e ops), @ LargeT' \r\ne ops.\r\nRecord BarrettParameters :=\r\n  { b : nat ; k : nat ; ops : ZLikeOps (f b k) }.\r\nAxiom barrett_reduce_function_bundled : forall {params : BarrettParameters}\r\n                                               (_ : @ LargeT' _ (@ ops params)),\r\n    @ SmallT _ (@ ops params).\r\nDefinition ZZLikeOps e : ZLikeOps (f (S O) e)\r\n  := {| LargeT := nat ; SmallT := nat ; CarryAdd x y := y |}.\r\nDefinition SRep := nat.\r\nDefinition x86_25519_Barrett : BarrettParameters\r\n  := {| b := S O ; k := O ; ops := ZZLikeOps O |}.\r\nDefinition SRepAdd : forall (_ _ : SRep), SRep\r\n  := let v := (fun x y => @ barrett_reduce_function_bundled x86_25519_Barrett \r\n(@ CarryAdd' _ _ x y)) in\r\n     v.\r\nDefinition SRepAdd' : forall (_ _ : SRep), SRep\r\n  := (fun x y => @ barrett_reduce_function_bundled x86_25519_Barrett (@ CarryAdd' \r\n_ _ x y)).\r\n(* Error: In environment\r\nx : SRep\r\ny : SRep\r\nThe term \"x\" has type \"SRep\" while it is expected to have type \"LargeT ?n ?z\". \r\n*)\r\n```\r\nSince `LargeT'` is an `Axiom`, there's a unique solution, and it falls in the \r\nfragment of unification that's solved by \"delay all unification problems \r\ninvolving evars except ?e = T where T has no evars, in which case instantiate \r\n?e with T\"\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549109/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549112","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-337549112","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":337549112,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0OTExMg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-11-18T09:40:41Z","updated_at":"2017-10-18T10:47:02Z","author_association":"CONTRIBUTOR","body":"Comment author: @maximedenes\n\nI don't think we want any risky change in unification for 8.6 at this point, so tagging 8.7.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549112/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549115","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-337549115","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":337549115,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0OTExNQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-01-23T12:25:31Z","updated_at":"2019-04-19T03:50:00Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\r\n\r\nA shorter example for this issue.\r\n\r\n```coq\r\nRecord T := { dom : Type }.\r\nDefinition t : T := {| dom := nat |}.\r\nAxiom P : T -> Type.\r\nAxiom ax1 : forall (t : T), dom t -> P t.\r\nAxiom ax2 : P t -> Prop.\r\nCheck (fun x : ?[T] => ax2 (ax1 ?[t] x)). (* ok *)\r\nCheck (fun x : nat => ax2 (ax1 ?[t] x)). (* fail *)\r\n```\r\n\r\nFor the record, the two equations in \"d2\" are:\r\n\r\n1. `nat <= dom ?t`\r\n2. `P ?t <= P t`\r\n\r\nThe two equations in \"d1\" are:\r\n\r\n1. `?T <= dom ?t`\r\n2. `P ?t <= P t`\r\n\r\nThe equation 1. is tried first. In d1, it succeeds by setting \"?T := dom ?t\" and 2. is tried and succeeds.\r\n\r\nIn d2, equation 1. fails (without postponing) what makes the whole problem fails.\r\n\r\nNote that equation 1. interacts with both coercions, canonical structures and order of type-checking.\r\n\r\n* Interaction with coercions *\r\n\r\nConsider:\r\n\r\n```coq\r\nCoercion g (b:bool) : dom t := if b then 0 else 1.\r\nCheck (fun x : bool => ax2 (ax1 ?[t] x)).\r\n```\r\n\r\nThis example shows that postponing is not an option w/o any change in the coercion algorithm, because we have to remember that the coercion g applies and after postponing, it is not anymore possible to add a coercion.\r\n\r\n* Interaction with canonical structures *\r\n\r\nConsider:\r\n\r\n```coq\r\nRecord T := { dom : Type; a : dom }.\r\nDefinition t : T := {| dom := nat; a := 0 |}.\r\nCanonical Structure t' := {| dom := nat; a := 1 |}.\r\nAxiom P : T -> Type.\r\nAxiom ax1 : forall (t : T), dom t -> P t.\r\nAxiom ax2 : P t -> Prop.\r\nCheck (fun x : nat => ax2 (ax1 ?[t] x)).\r\n```\r\n\r\nThis questions about how to use canonical structures not too early.\r\n\r\n* Interaction with order of type-checking.\r\n\r\nConsider:\r\n\r\n```coq\r\nRecord T := { dom : Type }.\r\nDefinition t : T := {| dom := nat |}.\r\nAxiom P : T -> Type.\r\nAxiom ax : forall (u : T) (U:Type), (P u -> (P t -> U) -> dom u) -> U.\r\nCheck ax ?[t] nat (fun x f => f x).\r\nCheck ax ?[t] ?[T] (fun x f => f x).\r\n```\r\n\r\nIf I'm correct, this generates the same equations in the other order.\r\n\r\nMy current feeling is that we should first change the coercion mechanism, so that coercion problems can be postponed until we have exploited all other information around.\r\n\r\nAny opinions?\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549115/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549116","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-337549116","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":337549116,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0OTExNg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-01-23T17:11:17Z","updated_at":"2017-10-18T10:47:02Z","author_association":"CONTRIBUTOR","body":"Comment author: @silene\n\nI am not sure to fully understand the issue, but I would just like to point out that the coercion mechanism is already clearly incomplete (and thus requires explicit coercions in some cases) and it does not seem that your suggestion makes it any worse. Or do you anticipate that a lot of existing developments that are currently pretyped properly would no longer be?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549116/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549118","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-337549118","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":337549118,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0OTExOA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-01-23T19:40:11Z","updated_at":"2017-10-18T10:47:02Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\n(In reply to Guillaume Melquiond from comment [BZ#3](https://github.com/coq/coq/issues?q=is%3Aissue%20%22Original%20bug%20ID%3A%20BZ%233%22))\n> I am not sure to fully understand the issue, but I would just like to point\n> out that the coercion mechanism is already clearly incomplete (and thus\n> requires explicit coercions in some cases) and it does not seem that your\n> suggestion makes it any worse. Or do you anticipate that a lot of existing\n> developments that are currently pretyped properly would no longer be?\n\nI don't know what you call my suggestion.\n\nAnyway, I don't know if this answers your question, but one point is that if we start to postpone equations of the form \"nat <= dom ?t\", then, considering the way insertion of coercions is implemented today, this would bypass the possibility to insert a coercion forever (I made the experience of doing this postponing and about 10 files fail in the test-suite; at least one because of a coercion not being inserted any more).\n\nI don't know if other ideas exist around, but one solution I see to support postponing and at the same time improving the coercion mechanism, is to support special evars for coercions, and to insert such evars every time there is a subtyping not enough informative to know if a coercion would ever be needed in the future. Then, it is only after the first phase of extraction of all typing information available in the original term that coercions would be inserted if needed.\n\nThis is a bit cumbersome and this why I'm hesitating to advocate for doing a step further. Consider for instance the infamous asymmetry of \"true = 0 :> ?[T]\" in the presence of a coercion \"c\" from bool to nat. Instead of turning the subtyping problem \"bool <= ?T\" into \"?T := bool\" as it is done now, one would elaborate the typing problem into:\n\n?c1 true = ?c2 0 :> ?[T]\n\nwhere\n\n?c1 : bool <= ?T\n?c2 : nat <= ?T\n\nThen, the \"solve remaining problems\" algorithm will try e.g. collect all lower bounds of ?T, see that there are inconsistent, and try to see if they can be linearly ordered using coercions, and finally found ?T:=nat, ?c1:=c and ?c2:=id, which would produce, after inlining of id, the term \"c true = 0 :> nat\".\n\nTo take another example, like \"(n:nat) (x:Z) |- n+n = z :> ?[B]\" with \"+\" a notation for a polymorphic plus of type \"forall A (T:PlusClass A), A -> A -> A\", with instances of \"PlusClass nat\" and \"PlusClass Z\" around, as well as a coercion h from nat to Z. One would elaborate the expression into\n\"plus ?A ?T (?c1 n) (?c2 n) = ?c3 z :> ?B\" where\n\n?c1 : nat <= ?A\n?c2 : nat <= ?A\n?c3 : ?A <= ?B\n?c4 : Z <= ?B\n?T : PlusClass ?A\n\nThen, some backtracking on at the same time looking for a coercion and for an instance would produce the two solutions \n\n?A:=nat, ?B:=Z, ?c1:=id, ?c2:=id, ?c3:=h, ?c4:=id\n?A:=Z, ?B:=Z, ?c1:=h, ?c2:=h, ?c3:=id, ?c4:=id\n\nWould it be worth or would it be too much burden?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549118/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549119","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-337549119","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":337549119,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0OTExOQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-01-24T13:39:23Z","updated_at":"2017-10-18T10:47:03Z","author_association":"CONTRIBUTOR","body":"Comment author: @silene\n\n(In reply to Hugo Herbelin from comment [BZ#4](https://github.com/coq/coq/issues?q=is%3Aissue%20%22Original%20bug%20ID%3A%20BZ%234%22))\n> (In reply to Guillaume Melquiond from comment [BZ#3](https://github.com/coq/coq/issues?q=is%3Aissue%20%22Original%20bug%20ID%3A%20BZ%233%22))\n> > I am not sure to fully understand the issue, but I would just like to point\n> > out that the coercion mechanism is already clearly incomplete (and thus\n> > requires explicit coercions in some cases) and it does not seem that your\n> > suggestion makes it any worse. Or do you anticipate that a lot of existing\n> > developments that are currently pretyped properly would no longer be?\n> \n> I don't know what you call my suggestion.\n\nI was referring to the idea of overhauling the coercion mechanism before fixing the bug described in this report.\n\n> I don't know if other ideas exist around, but one solution I see to support\n> postponing and at the same time improving the coercion mechanism, is to\n> support special evars for coercions, and to insert such evars every time\n> there is a subtyping not enough informative to know if a coercion would ever\n> be needed in the future. Then, it is only after the first phase of\n> extraction of all typing information available in the original term that\n> coercions would be inserted if needed.\n\nDon't you have to put such a special evar for almost each application in the term being typed then? For instance, \"x :: y :: nil\" would get turned into\n\n@ cons ?T1 (?C1 x) (?C2 (@ cons ?T2 (?C3 y) (?C4 (@ nil ?T3))))\n\nwith the ?Cs being the special evars. By cleverly using the uniform inheritance condition, we should be able to prove that ?C2 and ?C4 are never needed. But for ?C1 and ?C3, I think I can find counter-examples if either of them is removed. So I feel that there might be a combinatorial explosion during pretyping if we try to improve the coercion mechanism.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549119/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549120","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-337549120","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":337549120,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0OTEyMA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-01-24T13:43:47Z","updated_at":"2017-10-18T10:47:03Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nAbout the combinatorial explosion, that's a fear indeed, and could be alleviated by a more systematic use of bidirectional typechecking at applications (user driven, ideally), that would allow to know earlier if a coercion can be necessary.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337549120/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/484760168","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-484760168","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":484760168,"node_id":"MDEyOklzc3VlQ29tbWVudDQ4NDc2MDE2OA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-04-19T03:56:43Z","updated_at":"2019-04-19T03:56:43Z","author_association":"MEMBER","body":"Here is another short example:\r\n```coq\r\nAxiom foo : forall b : bool, (if b then True else False) -> b = true -> True.\r\nCheck @foo _ I (@eq_refl true). (* fails *)\r\n```\r\nNote that examples like this come up easily with the `rew [P] pf in v` notation, where even if I specify `P` and `pf`, sometimes the rewrite fails to typecheck because it cannot unify the type of `v` with `P ?y`, even though if it deferred the constraint it could pick it up from the type of `H`.\r\n\r\nI think it's quite unfortunate that Coq is still so sensitive to argument order in determining whether or not type inference succeeds.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/484760168/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/681087967","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-681087967","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":681087967,"node_id":"MDEyOklzc3VlQ29tbWVudDY4MTA4Nzk2Nw==","user":{"login":"maximedenes","id":647105,"node_id":"MDQ6VXNlcjY0NzEwNQ==","avatar_url":"https://avatars.githubusercontent.com/u/647105?v=4","gravatar_id":"","url":"https://api.github.com/users/maximedenes","html_url":"https://github.com/maximedenes","followers_url":"https://api.github.com/users/maximedenes/followers","following_url":"https://api.github.com/users/maximedenes/following{/other_user}","gists_url":"https://api.github.com/users/maximedenes/gists{/gist_id}","starred_url":"https://api.github.com/users/maximedenes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/maximedenes/subscriptions","organizations_url":"https://api.github.com/users/maximedenes/orgs","repos_url":"https://api.github.com/users/maximedenes/repos","events_url":"https://api.github.com/users/maximedenes/events{/privacy}","received_events_url":"https://api.github.com/users/maximedenes/received_events","type":"User","site_admin":false},"created_at":"2020-08-26T19:48:28Z","updated_at":"2020-08-26T19:48:28Z","author_association":"MEMBER","body":"> ```coq\r\n> Record T := { dom : Type }.\r\n> Definition t : T := {| dom := nat |}.\r\n> Axiom P : T -> Type.\r\n> Axiom ax1 : forall (t : T), dom t -> P t.\r\n> Axiom ax2 : P t -> Prop.\r\n> Check (fun x : ?[T] => ax2 (ax1 ?[t] x)). (* ok *)\r\n> Check (fun x : nat => ax2 (ax1 ?[t] x)). \r\n> ```\r\n\r\nThis is easily solved by bidirectionality hints: just add `Arguments ax1 t & _.`.\r\n\r\n> ```coq\r\n> Axiom foo : forall b : bool, (if b then True else False) -> b = true -> True.\r\n> Check @foo _ I (@eq_refl true). (* fails *)\r\n> ```\r\n\r\nThis one seems to require inverting functions in general, doesn't it?\r\n\r\n@JasonGross can we consider this issue as fixed by the introduction of bidirectionality hints?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/681087967/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/681136871","html_url":"https://github.com/coq/coq/issues/5199#issuecomment-681136871","issue_url":"https://api.github.com/repos/coq/coq/issues/5199","id":681136871,"node_id":"MDEyOklzc3VlQ29tbWVudDY4MTEzNjg3MQ==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2020-08-26T21:36:37Z","updated_at":"2020-08-26T21:36:37Z","author_association":"MEMBER","body":"> This one seems to require inverting functions in general, doesn't it?\r\n\r\nWhat makes you say that?  Note that while I want `constr:(@foo _ I (@eq_refl true))` to succeed, I think `constr:(@foo _ I)` should fail with an unresolvable constraint, rather than succeeding by inverting the if statement.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/681136871/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]