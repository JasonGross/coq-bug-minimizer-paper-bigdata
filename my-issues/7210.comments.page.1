[{"url":"https://api.github.com/repos/coq/coq/issues/comments/467166214","html_url":"https://github.com/coq/coq/issues/7210#issuecomment-467166214","issue_url":"https://api.github.com/repos/coq/coq/issues/7210","id":467166214,"node_id":"MDEyOklzc3VlQ29tbWVudDQ2NzE2NjIxNA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-02-25T20:16:15Z","updated_at":"2019-02-25T20:16:15Z","author_association":"MEMBER","body":"Note that the standard workaround for the first issue here is the rather verbose:\r\n```coq\r\nGoal True.\r\n  lazymatch constr:(fun a b : nat => a + a) with\r\n  | (fun x y : ?A => ?f)\r\n    => let f' := fresh in\r\n       pose (fun (x y : A) => match f return _ with\r\n                              | f' => ltac:(let f := (eval cbv delta [f'] in f') in\r\n                                            clear f';\r\n                                            exact f)\r\n                              end)\r\n  end.\r\n```\r\n\r\nNote that the `return _` is so that Coq will not backtrack on failures causing exponential blowup, and the `clear f'` is so that we don't get an explosion in the size of the context as we recurse.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/467166214/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/470009463","html_url":"https://github.com/coq/coq/issues/7210#issuecomment-470009463","issue_url":"https://api.github.com/repos/coq/coq/issues/7210","id":470009463,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MDAwOTQ2Mw==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-03-06T08:09:15Z","updated_at":"2021-10-04T20:03:24Z","author_association":"MEMBER","body":"Note that this is a very severe issue which makes it essentially impossible to pass *any* constrs through tactics in terms because there is no guarantee that the names bound in a constr will refer to the same thing.  Moreover, this breakage is silent, and doesn't show up until you run a term through `type of`, which is quite bad.  Here is an example that shows that this problem makes any complex use of tactics in terms essentially unreliable:\r\n<details>\r\n```coq\r\nRequire Import Coq.Lists.List.\r\nLtac under_forall_Type term ctx cont :=\r\n  lazymatch term with\r\n  | forall T : Type, ?P\r\n    => let t := fresh \"t\" in\r\n       let P' := fresh in\r\n       let ctx' := fresh in\r\n       constr:(fun t : Type\r\n               => match cons t ctx return _ with\r\n                  | ctx'\r\n                    => match List.hd t ctx' return _ with\r\n                       | T\r\n                         => match P return _ with\r\n                            | P'\r\n                              => ltac:(let ctx := (eval cbv delta [ctx' T P'] in ctx') in\r\n                                       let P := (eval cbv delta [ctx' T P'] in P') in\r\n                                       clear ctx' T P';\r\n                                       let res := under_forall_Type P ctx cont in\r\n                                       exact res)\r\n                            end\r\n                       end\r\n                  end)\r\n  | ?term => cont ctx term\r\n  end.\r\n\r\nLtac under_binders term cont :=\r\n  lazymatch term with\r\n  | forall x : ?T, ?P\r\n    => let P' := fresh in\r\n       constr:(fun x : T\r\n               => match P return _ with\r\n                  | P' => ltac:(let P := (eval cbv delta [P'] in P') in\r\n                                let res := under_binders P cont in\r\n                                exact res)\r\n                  end)\r\n  | ?term => cont term\r\n  end.\r\n\r\nLtac foo cont :=\r\n  let v := under_forall_Type\r\n             (forall (A : Type) (t : nat), t = t)\r\n             (@nil Type)\r\n             ltac:(fun ctx term\r\n                   => under_binders\r\n                        term\r\n                        ltac:(fun term'\r\n                              => cont ctx term')) in\r\n  pose v.\r\n\r\nGoal True.\r\n  foo ltac:(fun ctx term' => constr:(True)). (* success *)\r\n  foo ltac:(fun ctx term' => constr:(True)). (* success *)\r\n  foo ltac:(fun ctx term' => let t := type of ctx in constr:(True)).\r\n  (* Error:\r\nIn nested Ltac calls to \"foo\", \"under_forall_Type\",\r\n\"(fun t : Type =>\r\n  match t :: ctx with\r\n  | ctx' => match hd t ctx' with\r\n            | T => match P with\r\n                   | P' => _\r\n                   end\r\n            end\r\n  end)\" (with term:=Type -> forall t : nat, t = t, ctx:=nil,\r\nP:=forall t : nat, t = t), \"under_forall_Type\", \"cont\" (bound to\r\nfun ctx term => under_binders term ltac:(fun term' => cont ctx term')),\r\n\"under_binders\", \"(fun x : T => match P with\r\n                                | P' => _\r\n                                end)\" (with x:=t, term:=\r\nforall t : nat, t = t, T:=nat, P:=x = x), \"under_binders\",\r\n\"cont\" (bound to fun term' => cont ctx term') and \"cont\" (bound to\r\nfun ctx term' => let t := type of ctx in\r\n                 True), last call failed.\r\nIllegal application:\r\nThe term \"@cons\" of type \"forall A : Type, A -> list A -> list A\"\r\ncannot be applied to the terms\r\n \"Type\" : \"Type\"\r\n \"t\" : \"nat\"\r\n \"nil\" : \"list Type\"\r\nThe 2nd term has type \"nat\" which should be coercible to\r\n\"Type\".\r\n   *)\r\n```\r\n</details>\r\ncc @ppedrot ","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/470009463/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/470111861","html_url":"https://github.com/coq/coq/issues/7210#issuecomment-470111861","issue_url":"https://api.github.com/repos/coq/coq/issues/7210","id":470111861,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MDExMTg2MQ==","user":{"login":"andres-erbsen","id":918403,"node_id":"MDQ6VXNlcjkxODQwMw==","avatar_url":"https://avatars.githubusercontent.com/u/918403?v=4","gravatar_id":"","url":"https://api.github.com/users/andres-erbsen","html_url":"https://github.com/andres-erbsen","followers_url":"https://api.github.com/users/andres-erbsen/followers","following_url":"https://api.github.com/users/andres-erbsen/following{/other_user}","gists_url":"https://api.github.com/users/andres-erbsen/gists{/gist_id}","starred_url":"https://api.github.com/users/andres-erbsen/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/andres-erbsen/subscriptions","organizations_url":"https://api.github.com/users/andres-erbsen/orgs","repos_url":"https://api.github.com/users/andres-erbsen/repos","events_url":"https://api.github.com/users/andres-erbsen/events{/privacy}","received_events_url":"https://api.github.com/users/andres-erbsen/received_events","type":"User","site_admin":false},"created_at":"2019-03-06T13:44:05Z","updated_at":"2019-03-06T19:20:36Z","author_association":"CONTRIBUTOR","body":"~~Ltac2 is not affected by this, right? is there any chance we could have ltac2 in the Linux version of coq, appropriately labeled as an experiment/preview/beta as necessary?~~","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/470111861/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/470176876","html_url":"https://github.com/coq/coq/issues/7210#issuecomment-470176876","issue_url":"https://api.github.com/repos/coq/coq/issues/7210","id":470176876,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MDE3Njg3Ng==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-03-06T16:30:46Z","updated_at":"2019-03-06T16:35:57Z","author_association":"MEMBER","body":"No, I think Ltac2 is just as affected by this as Ltac1.  Perhaps a bit less so, because it is easier to pick a different name when recursing under binders, perhaps?\r\n\r\nOne solution to this is to never ever mix reuse of binder names with tactics in terms.  That is, always use the pattern\r\n\r\n```coq\r\nmatch term with\r\n| (fun x : ?T => ?f)\r\n=> let y := fresh in\r\n   constr:(fun y : T\r\n             => ltac:(let f := constr:(match y with x => f end) in\r\n                      ...))\r\nend\r\n```\r\nrather than putting the match outside the tactic; this would mean that if we want to preserve binder names, we need to add an extra `match ` to adjust that after the fact.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/470176876/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/470250011","html_url":"https://github.com/coq/coq/issues/7210#issuecomment-470250011","issue_url":"https://api.github.com/repos/coq/coq/issues/7210","id":470250011,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MDI1MDAxMQ==","user":{"login":"andres-erbsen","id":918403,"node_id":"MDQ6VXNlcjkxODQwMw==","avatar_url":"https://avatars.githubusercontent.com/u/918403?v=4","gravatar_id":"","url":"https://api.github.com/users/andres-erbsen","html_url":"https://github.com/andres-erbsen","followers_url":"https://api.github.com/users/andres-erbsen/followers","following_url":"https://api.github.com/users/andres-erbsen/following{/other_user}","gists_url":"https://api.github.com/users/andres-erbsen/gists{/gist_id}","starred_url":"https://api.github.com/users/andres-erbsen/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/andres-erbsen/subscriptions","organizations_url":"https://api.github.com/users/andres-erbsen/orgs","repos_url":"https://api.github.com/users/andres-erbsen/repos","events_url":"https://api.github.com/users/andres-erbsen/events{/privacy}","received_events_url":"https://api.github.com/users/andres-erbsen/received_events","type":"User","site_admin":false},"created_at":"2019-03-06T19:48:59Z","updated_at":"2019-03-06T19:48:59Z","author_association":"CONTRIBUTOR","body":"Hmm, I am not sure what is going on here in that case. Could you explain what each command does, (in particular, what names the body of `f` refers to at various points) and how they are represented? I totally thought it was just ltac treating the new `fun x` => in a way that ignores the old name bound to x...","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/470250011/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/470266220","html_url":"https://github.com/coq/coq/issues/7210#issuecomment-470266220","issue_url":"https://api.github.com/repos/coq/coq/issues/7210","id":470266220,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MDI2NjIyMA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-03-06T20:35:54Z","updated_at":"2019-03-06T20:36:24Z","author_association":"MEMBER","body":"Ah, it is possible that the new example deserves a new issue, because the repeating of names is a bit subtle.  Let me go for a lite explanation of what happens, and if that is not enough, then I will explain in more depth.\r\n\r\nVery roughly the issue is that the following two `pose`s behave differently:\r\n```coq\r\nGoal forall n : nat, True.\r\n  intro n.\r\n  let v := constr:(n) in\r\n  pose (fun n : Set => v); (* fun _ : Set => n : Set -> nat *)\r\n    pose (fun n : Set => ltac:(exact v)). (* fun n : Set => n : Set -> Set *)\r\n```\r\nThat is, whenever you pass from `constr` to tactics, all existing constrs in the Ltac environment are effectively treated as open terms over the existing context.  As far as I'm aware, all of the methods for recursing under binders in Ltac2 suffer from the same issue, but perhaps @ppedrot will tell me that `Constr.in_context` (the Ltac2-version of \"recurse under binders\") is better-behaved.  (Just from the design of the system, though, I am dubious about this; my intuition boils down to the fact that `constr`s in Ltac(2) identify variables in the proof context by name rather than by pointer.)\r\n\r\nIn the particular example I have, this issue arises because the tactic:\r\n1. creates a new variable name with `fresh \"t\"` (which is the identifier `t` because there is no `t` in the context),\r\n2. recurses under a fresh binder of this name (`t`) and builds a `constr` containing `t : Type`,\r\n3. recurses under all the forall-binders in a constr `forall t : nat, ....`, *preserving names*\r\n4. tries to use the `constr` from 2 containing `t : Type`, which is now ill-typed because the most-recent binder `t` has type `nat`\r\n\r\nNote that this issue showed up in the wild in reifying rewrite rules in fiat-crypto.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/470266220/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/470267287","html_url":"https://github.com/coq/coq/issues/7210#issuecomment-470267287","issue_url":"https://api.github.com/repos/coq/coq/issues/7210","id":470267287,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MDI2NzI4Nw==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-03-06T20:39:13Z","updated_at":"2019-03-06T20:39:13Z","author_association":"MEMBER","body":"I am guessing that there is a thing that is done when dynamically casting Ltac variables to `constr` when inside a `constr` that has them evaluated in the proof context outside the `constr` before inserting them into the new `constr` underneath whatever binders are created.  I imagine the same transformation could occur on all Ltac variables which hold `constr` things (and hopefully Ltac thunks just work *crosses fingers*)?  @ppedrot , can you comment on this?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/470267287/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/470312110","html_url":"https://github.com/coq/coq/issues/7210#issuecomment-470312110","issue_url":"https://api.github.com/repos/coq/coq/issues/7210","id":470312110,"node_id":"MDEyOklzc3VlQ29tbWVudDQ3MDMxMjExMA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2019-03-06T23:00:54Z","updated_at":"2019-03-06T23:00:54Z","author_association":"MEMBER","body":"Quoting @ppedrot on gitter, in response to me asking about the two `pose`s (as well as the variants with `ident:`, `uconstr:`, and `open_constr:` in place of `constr:` (only `uconstr` behaves differently; and it makes both behave like the `ltac:(exact ...)` version))\r\n> the reason is that the evaluation of the v variable doesn't happen in the same context\r\nin the first case, you're evaluating `Var(n)` under a context `Var(n) : nat | n : Set ⊢`\r\nthe fun n is a DeBruijn rel, not a var\r\nso there is no possible capture\r\nin the second case, the ltac:(...) expression triggers a generation of a fully var-named context\r\nso that you get `Var(n0) : nat, Var(n) : Set | ⊢`\r\nin particular, no rel\r\nso capture happens\r\nregarding the additional genargs, the only one that behaves differently is uconstr, and the reason is that uconstr builds a proper closure (in a somewhat hackish way but that's not the issue)\r\ntypechecking a uconstr is like evaluating a tactic thunk\r\n\r\nAnd @ppedrot confirms \"yeah, unfortunately you're going to have the same issue with Ltac2\"","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/470312110/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]