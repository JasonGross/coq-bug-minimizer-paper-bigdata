Comment author: @JasonGross

Given an equality of elements in a sigma type, it's possible to get a meaningful equality of their second projections:

Lemma path_sigT {A P} (x y : @ sigT A P)                                                                                                            
      (H : x = y)                                                                                                                                  
: { p : projT1 x = projT1 y & eq_rect _ P (projT2 x) _ p = projT2 y }.                                                                             
Proof.                                                                                                                                             
  exists (f_equal _ H).                                                                                                                            
  destruct H; reflexivity.                                                                                                                         
Defined.

[inversion] (perhaps modulo a compatibility option) should do this, so that destructing the first equality generated by [inversion] allows you to destruct the second one.


We now have `inversion_sigma`, though it might be nice for `inversion` to handle this natively.  More generally, it'd be nice to have a way to make this proof more compact and cleaner without axioms (cc @herbelin, is there a depdestruct tractic with small inversions coming or something?) :
```coq
(* -*- coding: utf-8 -*- *)
Require Import Coq.Lists.List Coq.Logic.Eqdep_dec.
Import ListNotations.
Local Open Scope list_scope.
Set Decidable Equality Schemes.
Set Boolean Equality Schemes.
Inductive type := NAT | arrow (s d : type).
Inductive term {var : type -> Type} : type -> Type :=
| Abs {s d} (f : var s -> term d) : term (arrow s d)
| Var {t} (v : var t) : term t
| App {s d} (f : term (arrow s d)) (x : term s) : term d
| Lit (v : nat) : term NAT
.
Inductive related {var1 var2} : list { t : type & (var1 t * var2 t)%type } -> forall {t}, @term var1 t -> @term var2 t -> Prop :=
| rel_Abs {s d Γ f g}
  : (forall v1 v2, related (existT _ s (v1, v2) :: Γ) (t:=d) (f v1) (g v2))
    -> related Γ (Abs f) (Abs g)
| rel_Var {t Γ v1 v2}
  : List.In (existT _ t (v1, v2)) Γ -> related Γ (Var v1) (Var v2)
| rel_App {s d Γ} {f g : term (arrow s d)} {x y}
  : related Γ f g -> related Γ x y -> related Γ (App f x) (App g y)
| rel_Lit {Γ v} : related Γ (Lit v) (Lit v)
.
Inductive related3 {var1 var2 var3}
  : list { t : type & (var1 t * var2 t * var3 t)%type } -> forall {t}, @term var1 t -> @term var2 t -> @term var3 t -> Prop :=
| rel3_Abs {s d Γ f g h}
  : (forall v1 v2 v3, related3 (existT _ s (v1, v2, v3) :: Γ) (t:=d) (f v1) (g v2) (h v3))
    -> related3 Γ (Abs f) (Abs g) (Abs h)
| rel3_Var {t Γ v1 v2 v3}
  : List.In (existT _ t (v1, v2, v3)) Γ -> related3 Γ (Var v1) (Var v2) (Var v3)
| rel3_App {s d Γ} {f g h : term (arrow s d)} {x y z}
  : related3 Γ f g h -> related3 Γ x y z -> related3 Γ (App f x) (App g y) (App h z)
| rel3_Lit {Γ v} : related3 Γ (Lit v) (Lit v) (Lit v)
.
Goal forall var1 var2 var3 Γ Γ1 Γ2 Γ3 t x y z w,
    Γ1 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v1, (v1, v2, v3))) Γ
    -> Γ2 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v2, (v1, v2, v3))) Γ
    -> Γ3 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v3, (v1, v2, v3))) Γ
    -> @related var1 _ Γ1 t x w
    -> @related var2 _ Γ2 t y w
    -> @related var3 _ Γ3 t z w
    -> @related3 var1 var2 var3 Γ t x y z.
Proof.
  intros var1 var2 var3 Γ Γ1 Γ2 Γ3 t x y z w H1 H2 H3 HR1 HR2 HR3.
  revert Γ Γ2 Γ3 H1 H2 H3 HR2 HR3; induction HR1; intros; inversion HR2; inversion HR3.
  (*   H11 : Γ4 = Γ3
  H10 : s1 = s
  H13 : d1 = d
  H14 : Abs f1 = z
  H15 : existT (fun d : type => var1 s * var2 s * var3 s -> term d) d g1 =
        existT (fun d : type => var1 s * var2 s * var3 s -> term d) d g
  ============================
  related3 Γ0 (Abs f) (Abs f0) (Abs f1)
*)
  all: repeat first [ progress subst
                    | progress inversion_sigma
                    | progress cbn [eq_rect List.map List.In projT1 projT2] in *
                    | progress intros
                    | match goal with
                      | [ H : pair _ _ = pair _ _ |- _ ] => inversion H; clear H
                      | [ H : ex _ |- _ ] => destruct H
                      | [ H : sigT _ |- _ ] => destruct H
                      | [ H : prod _ _ |- _ ] => destruct H
                      | [ H : and _ _ |- _ ] => destruct H
                      | [ H : ?x = ?x :> type |- _ ] => pose proof (UIP_dec type_eq_dec eq_refl H); subst H
                      end
                    | constructor
                    | solve [ eauto ]
                    | rewrite in_map_iff in *
                    | match goal with
                      | [ H : context[_ -> related3 _ _ _ _] |- related3 _ _ _ _ ] => eapply H; clear H
                      end ].
Qed.
```

Btw, here is a semi-manual-small-inversion version of this proof, without needing `UIP_dec`, where I'd like to be able to get rid of all of the `refine_*` tactics in favor of just some sort of non-axiom-based-inversion tactic:
```coq
(* -*- coding: utf-8 -*- *)
Require Import Coq.Lists.List Coq.Logic.Eqdep_dec.
Import ListNotations.
Local Open Scope list_scope.
Set Decidable Equality Schemes.
Set Boolean Equality Schemes.
Inductive type := NAT | arrow (s d : type).
Inductive term {var : type -> Type} : type -> Type :=
| Abs {s d} (f : var s -> term d) : term (arrow s d)
| Var {t} (v : var t) : term t
| App {s d} (f : term (arrow s d)) (x : term s) : term d
| Lit (v : nat) : term NAT
.
Inductive related {var1 var2} : list { t : type & (var1 t * var2 t)%type } -> forall {t}, @term var1 t -> @term var2 t -> Prop :=
| rel_Abs {s d Γ f g}
  : (forall v1 v2, related (existT _ s (v1, v2) :: Γ) (t:=d) (f v1) (g v2))
    -> related Γ (Abs f) (Abs g)
| rel_Var {t Γ v1 v2}
  : List.In (existT _ t (v1, v2)) Γ -> related Γ (Var v1) (Var v2)
| rel_App {s d Γ} {f g : term (arrow s d)} {x y}
  : related Γ f g -> related Γ x y -> related Γ (App f x) (App g y)
| rel_Lit {Γ v} : related Γ (Lit v) (Lit v)
.
Inductive related3 {var1 var2 var3}
  : list { t : type & (var1 t * var2 t * var3 t)%type } -> forall {t}, @term var1 t -> @term var2 t -> @term var3 t -> Prop :=
| rel3_Abs {s d Γ f g h}
  : (forall v1 v2 v3, related3 (existT _ s (v1, v2, v3) :: Γ) (t:=d) (f v1) (g v2) (h v3))
    -> related3 Γ (Abs f) (Abs g) (Abs h)
| rel3_Var {t Γ v1 v2 v3}
  : List.In (existT _ t (v1, v2, v3)) Γ -> related3 Γ (Var v1) (Var v2) (Var v3)
| rel3_App {s d Γ} {f g h : term (arrow s d)} {x y z}
  : related3 Γ f g h -> related3 Γ x y z -> related3 Γ (App f x) (App g y) (App h z)
| rel3_Lit {Γ v} : related3 Γ (Lit v) (Lit v) (Lit v)
.
Fixpoint rel3_of_rel2
         {var1 var2 var3 Γ Γ1 Γ2 Γ3 t x y z w}
         (H1 : Γ1 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v1, (v1, v2, v3))) Γ)
         (H2 : Γ2 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v2, (v1, v2, v3))) Γ)
         (H3 : Γ3 = List.map (fun '(existT _ t (v1, v2, v3)) => existT _ t (v3, (v1, v2, v3))) Γ)
         (HR1 : @related var1 _ Γ1 t x w)
         (HR2 : @related var2 _ Γ2 t y w)
         (HR3 : @related var3 _ Γ3 t z w)
         {struct w}
  : @related3 var1 var2 var3 Γ t x y z.
Proof.
  specialize (@rel3_of_rel2 var1 var2 var3).
  pose w as w'.
  destruct w.
  { lazymatch (eval cbv [w'] in w') with
    | Abs ?f => specialize (fun Γ Γ1 Γ2 Γ3 x y z v => rel3_of_rel2 Γ Γ1 Γ2 Γ3 _ x y z (f v))
    end; clear w'.
    Ltac refine_Abs HR :=
      lazymatch type of HR with
      | @related _ _ ?Γ (arrow ?s ?d) ?x (Abs ?f)
        => let mov := move Γ at top; move s before Γ; move d before s; move x before d; move f before x; move HR before f in
           mov; revert dependent f; intros f HR;
           mov; revert dependent x; intros x HR;
           mov; revert dependent d; intros d x f HR;
           mov; revert dependent s; intros s x f HR;
           mov; revert dependent Γ; intros Γ HR;
           mov; pattern Γ, s, d, x, f
      end;
      let P := lazymatch goal with |- ?P _ _ _ _ _ => P end in
      refine match HR in @related _ _ Γ t x y return match y in term t return term t -> Prop with
                                                     | Abs f => fun x => P Γ _ _ x f
                                                     | _ => fun _ => IDProp
                                                     end x
             with
             | rel_Abs H => _
             | _ => idProp
             end;
      lazymatch type of HR with
      | @related _ _ ?Γ (arrow ?s ?d) ?x (Abs ?f)
        => clear HR Γ s d x f
      end;
      rename H into HR; intros.
    refine_Abs HR1.
    refine_Abs HR2.
    refine_Abs HR3.
    constructor; intros.
    eapply rel3_of_rel2; now try (eapply HR1 + eapply HR2 + eapply HR3); cbn [List.map]; apply (f_equal2 cons). }
  { clear rel3_of_rel2.
    Ltac refine_Var HR :=
      lazymatch type of HR with
      | @related _ _ ?Γ ?t ?x (Var ?v)
        => let mov := move Γ at top; move t before Γ; move x before t; move v before x; move HR before v in
           mov; revert dependent v; intros v HR;
           mov; revert dependent x; intros x HR;
           mov; revert dependent t; intros t x v HR;
           mov; revert dependent Γ; intros Γ HR;
           mov; pattern Γ, t, x, v
      end;
      let P := lazymatch goal with |- ?P _ _ _ _ => P end in
      refine match HR in @related _ _ Γ t x y return match y in term t return term t -> Prop with
                                                     | Var v => fun x => P Γ _ x v
                                                     | _ => fun _ => IDProp
                                                     end x
             with
             | rel_Var H => _
             | _ => idProp
             end;
      lazymatch type of HR with
      | @related _ _ ?Γ ?t ?x (Var ?v)
        => clear HR Γ t x v
      end;
      rename H into HR; intros.
    refine_Var HR1.
    refine_Var HR2.
    refine_Var HR3.
    constructor; intros.
    subst; rewrite !in_map_iff in *.
    repeat match goal with
           | [ H : ex _ |- _ ] => destruct H
           | [ H : sigT _ |- _ ] => destruct H
           | [ H : prod _ _ |- _ ] => destruct H
           | [ H : and _ _ |- _ ] => destruct H
           end.
    inversion_sigma; subst; cbn [eq_rect] in *.
    repeat match goal with
           | [ H : pair _ _ = pair _ _ |- _ ] => inversion H; clear H
           end.
    subst.
    assumption. }
  { lazymatch (eval cbv [w'] in w') with
    | App ?f ?v
      => pose proof (fun Γ Γ1 Γ2 Γ3 x y z => rel3_of_rel2 Γ Γ1 Γ2 Γ3 _ x y z f) as rel3_of_rel2_1;
         pose proof (fun Γ Γ1 Γ2 Γ3 x y z => rel3_of_rel2 Γ Γ1 Γ2 Γ3 _ x y z v) as rel3_of_rel2_2;
         clear rel3_of_rel2
    end; clear w'.
    Ltac refine_App HR :=
      lazymatch type of HR with
      | @related _ _ ?Γ _ ?x (App (s:=?s) (d:=?d) ?f ?v)
        => let mov := move Γ at top; move s before Γ; move d before s; move x before d; move f before x; move v before f;
                      move HR before v in
           mov; revert dependent v; intros v HR;
           mov; revert dependent f; intros f HR;
           mov; revert dependent x; intros x HR;
           mov; revert dependent d; intros d x f HR;
           mov; revert dependent s; intros s f v HR;
           mov; revert dependent Γ; intros Γ HR;
           mov; pattern Γ, s, d, x, f, v
      end;
      let P := lazymatch goal with |- ?P _ _ _ _ _ _ => P end in
      refine match HR in @related _ _ Γ t x y return match y in term t return term t -> Prop with
                                                     | App f v => fun x => P Γ _ _ x f v
                                                     | _ => fun _ => IDProp
                                                     end x
             with
             | rel_App H0 H1 => _
             | _ => idProp
             end;
      lazymatch type of HR with
      | @related _ _ ?Γ _ ?x (App (s:=?s) (d:=?d) ?f ?v)
        => clear HR Γ s d x f v
      end;
      intros;
      rename H0 into HR;
      let HR1 := fresh HR in
      rename H1 into HR1.
    refine_App HR1.
    refine_App HR2.
    refine_App HR3.
    constructor; intros; (eapply rel3_of_rel2_1 + eapply rel3_of_rel2_2); eassumption. }
  { clear rel3_of_rel2.
    Ltac refine_Lit HR :=
      lazymatch type of HR with
      | @related _ _ ?Γ _ ?x (Lit ?v)
        => let mov := move Γ at top; move x before Γ; move v before x; move HR before v in
           mov; revert dependent v; intros v HR;
           mov; revert dependent x; intros x HR;
           mov; revert dependent Γ; intros Γ HR;
           mov; pattern Γ, x, v
      end;
      let P := lazymatch goal with |- ?P _ _ _ => P end in
      refine match HR in @related _ _ Γ t x y return match y in term t return term t -> Prop with
                                                     | Lit v => fun x => P Γ x v
                                                     | _ => fun _ => IDProp
                                                     end x
             with
             | rel_Lit => _
             | _ => idProp
             end;
      lazymatch type of HR with
      | @related _ _ ?Γ _ ?x (Lit ?v)
        => clear HR Γ x v
      end;
      intros.
    refine_Lit HR1.
    refine_Lit HR2.
    refine_Lit HR3.
    constructor. }
Qed.
```
