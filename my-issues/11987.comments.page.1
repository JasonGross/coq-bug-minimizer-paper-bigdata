[{"url":"https://api.github.com/repos/coq/coq/issues/comments/606853283","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-606853283","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":606853283,"node_id":"MDEyOklzc3VlQ29tbWVudDYwNjg1MzI4Mw==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2020-03-31T20:21:14Z","updated_at":"2020-03-31T20:21:14Z","author_association":"MEMBER","body":"In particular, I would like to be able to declare the following things:\r\n- The identifier `s` should not appear as a type name nor a constructor name nor a constant name nor a function argument nor a local name binding anywhere in the code\r\n- No identifier nor type name nor constructor name should have a qualified name ending with the path fragment `a.b.c` (i.e., I want to say that `Definition succ` in `Module Pervasives` should be renamed without needing to rename `Definition succ` at top level)\r\n- No module should have a qualified name ending with the path fragment `a.b.c` (i.e., avoid naming modules `Pervasives`; avoid naming modules `Pervasives.String`)\r\n\r\nI started trying to implement this at https://github.com/JasonGross/coq/tree/extraction-blacklist-ident, but I don't understand how the extraction code is structured well enough to know where the right place to define these things is.\r\n\r\ncc @letouzey ","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/606853283/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/969331895","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-969331895","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":969331895,"node_id":"IC_kwDOABUDh845xtS3","user":{"login":"liyishuai","id":7020805,"node_id":"MDQ6VXNlcjcwMjA4MDU=","avatar_url":"https://avatars.githubusercontent.com/u/7020805?v=4","gravatar_id":"","url":"https://api.github.com/users/liyishuai","html_url":"https://github.com/liyishuai","followers_url":"https://api.github.com/users/liyishuai/followers","following_url":"https://api.github.com/users/liyishuai/following{/other_user}","gists_url":"https://api.github.com/users/liyishuai/gists{/gist_id}","starred_url":"https://api.github.com/users/liyishuai/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/liyishuai/subscriptions","organizations_url":"https://api.github.com/users/liyishuai/orgs","repos_url":"https://api.github.com/users/liyishuai/repos","events_url":"https://api.github.com/users/liyishuai/events{/privacy}","received_events_url":"https://api.github.com/users/liyishuai/received_events","type":"User","site_admin":false},"created_at":"2021-11-15T21:20:17Z","updated_at":"2021-11-15T21:20:17Z","author_association":"CONTRIBUTOR","body":"I suffered this issue in https://github.com/coq/coq/pull/8252#discussion_r219342270.\r\nThe following code fails on 31b5f7a6:\r\n```coq\r\nFrom Coq Require Import\r\n     ExtrOcamlBasic\r\n     BinInt.\r\n\r\nExtract Inductive nat =>\r\n\"Z.t\" [ \"Z.zero\" \"Z.succ\" ]\r\n      \"(fun fO fS n -> if Z.sign n <= 0 then fO () else fS (Z.pred n))\".\r\n\r\nExtraction TestCompile O.\r\nExtraction TestCompile Z.zero.\r\n\r\nExample test := (O, Z.zero).\r\nFail Extraction TestCompile test.\r\n```\r\n```\r\nError: Unbound type constructor Z.t\r\nThe command has indeed failed with message:\r\nCompilation of file /var/folders/d5/f_vqb7sj4cn26rl4cyfxd6f00000gn/T/testextractiondd0449.ml failed with exit code 2\r\n```\r\n```ocaml\r\ntype positive =\r\n| XI of positive\r\n| XO of positive\r\n| XH\r\n\r\ntype z =\r\n| Z0\r\n| Zpos of positive\r\n| Zneg of positive\r\n\r\nmodule Z =\r\n struct\r\n  (** val zero : z **)\r\n\r\n  let zero =\r\n    Z0\r\n end\r\n\r\n(** val test : Z.t * z **)\r\n\r\nlet test =\r\n  (Z.zero, Z.zero)\r\n```\r\nAs a result, I had to use a compatibility layer to avoid the name conflict: https://github.com/coq/coq/blob/31b5f7a64729e1d93fe1d70067ef6ab070639234/theories/extraction/ExtrOcamlNatBigInt.v#L29-L32","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/969331895/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/991885631","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-991885631","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":991885631,"node_id":"IC_kwDOABUDh847Hvk_","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2021-12-12T12:04:47Z","updated_at":"2021-12-12T12:04:47Z","author_association":"MEMBER","body":"@JasonGross :\r\n\r\n>  No identifier nor type name nor constructor name should have a qualified name ending with the path fragment `a.b.c` (i.e., I want to say that `Definition succ` in `Module Pervasives` should be renamed without needing to rename `Definition succ` at top level)\r\n> \r\n>  No module should have a qualified name ending with the path fragment `a.b.c` (i.e., avoid naming modules `Pervasives`; avoid naming modules `Pervasives.String`)\r\n\r\nWhen you're talking about `a.b.c`, are you saying that the blacklist should also accept module names, or qualified names?\r\n\r\nIn the [#10936](https://github.com/coq/coq/issues/10936#issue-511424960) example, do you intend `Inductive int` to be extracted to `int0 = int`?\r\n\r\nIn the example [above](https://github.com/coq/coq/issues/11987#issuecomment-969331895), do you intend to have `Z` in the blacklist and the extraction of Coq module `Z` to go a module named `Z0`?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/991885631/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/991891612","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-991891612","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":991891612,"node_id":"IC_kwDOABUDh847HxCc","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-12-12T12:42:12Z","updated_at":"2021-12-12T12:42:12Z","author_association":"MEMBER","body":"> When you're talking about a.b.c, are you saying that the blacklist should also accept module names, or qualified names?\r\n\r\nI'm saying there should be a separate blacklist for each OCaml namespace (type, module, constant, constructor, etc) (though I suppose it's not that bad if all the blacklists are combined), and also that these blacklists should accept qualified names, and that a given declaration should be renamed only if it's possible to refer to the extracted version by some qualified name whose suffix is the given qualified name.\r\n\r\n\r\n> In the [#10936](https://github.com/coq/coq/issues/10936#issue-511424960) example, do you intend `Inductive int` to be extracted to `int0 = int`?\r\n\r\nYes\r\n\r\n> In the example [above](https://github.com/coq/coq/issues/11987#issuecomment-969331895), do you intend to have `Z` in the blacklist and the extraction of Coq module `Z` to go a module named `Z0`?\r\n\r\nYes, assuming we put `Z` in the module blacklist (which may or may not be the same as the constant blacklist)","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/991891612/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/991898500","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-991898500","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":991898500,"node_id":"IC_kwDOABUDh847HyuE","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2021-12-12T13:27:58Z","updated_at":"2021-12-12T13:27:58Z","author_association":"MEMBER","body":"Actually, it is less and less clear to me that we can make something out of qualified names in the blacklist because OCaml resolution of qualified names is different than in Coq and a more recent module name (say `Z`) would hide the whole of a former module of same name, including the fields of the former module which are not defined in the more recent module. In particular, in the above example, I don't really see an alternative to put the module `Z` itself in the blacklist.\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/991898500/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/991898758","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-991898758","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":991898758,"node_id":"IC_kwDOABUDh847HyyG","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2021-12-12T13:29:24Z","updated_at":"2021-12-12T13:29:24Z","author_association":"MEMBER","body":"Regarding your branch, there are two commits which add OCaml/Haskell keywords. I'd say that it is worth to already make a PR out of them. What do you think?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/991898758/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/991964764","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-991964764","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":991964764,"node_id":"IC_kwDOABUDh847IC5c","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-12-12T20:26:59Z","updated_at":"2021-12-12T20:31:15Z","author_association":"MEMBER","body":"> Actually, it is less and less clear to me that we can make something out of qualified names in the blacklist because OCaml resolution of qualified names is different than in Coq and a more recent module name (say `Z`) would hide the whole of a former module of same name, including the fields of the former module which are not defined in the more recent module. In particular, in the above example, I don't really see an alternative to put the module `Z` itself in the blacklist.\r\n\r\n<strike>I think you're reversing the purpose of the blacklist.  If `Z` in OCaml were an inner module, say, `Stdlib.Z`, then we don't need to rename a top-level `module Z` to avoid interfering with extracted `Stdlib.Z`, right?  We'd only need to rename a `module Z` inside a `module Stdlib`.</strike>  But I think maybe I see what you're saying: if I want to access `String.make`, then not only do I need to avoid having a `val make` in my own `module String`, but I need to avoid having a `module String` altogether?  If that is the case, then I think you're right, and we should just allow blacklisting modules, but not qualified names.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/991964764/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/991965809","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-991965809","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":991965809,"node_id":"IC_kwDOABUDh847IDJx","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-12-12T20:34:24Z","updated_at":"2021-12-12T20:34:24Z","author_association":"MEMBER","body":"> Regarding your branch, there are two commits which add OCaml/Haskell keywords. I'd say that it is worth to already make a PR out of them. What do you think?\r\n\r\nThat sounds reasonable.  I don't currently have the motivation to create/shepard this PR, but I might try to make such a PR soon (along with one solving https://github.com/coq/coq/issues/15180, which should be solvable in a relatively straightforward way).  Feel free to take over the commits and make a PR yourself with them in the meantime though.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/991965809/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/992940410","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-992940410","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":992940410,"node_id":"IC_kwDOABUDh847LxF6","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2021-12-13T21:48:18Z","updated_at":"2021-12-13T21:48:18Z","author_association":"MEMBER","body":"> we should just allow blacklisting modules, but not qualified names.\r\n\r\nI would say that we need both.\r\n\r\nFor the `test` example above, we would need an `Extraction Module Blacklist Z` but for the example of #10936 we would need an `Extraction Identifier Blacklist int`, which your branch solves. So, I would say that we could start from your branch and add an `Extraction Module Blacklist ...`. What do you think?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/992940410/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/992961455","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-992961455","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":992961455,"node_id":"IC_kwDOABUDh847L2Ov","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2021-12-13T22:18:12Z","updated_at":"2021-12-13T22:18:12Z","author_association":"MEMBER","body":"> I would say that we need both.\r\n\r\nI meant blacklisting unqualified modules and unqualified identifiers, but not qualified modules nor qualified identifiers.\r\n\r\n> For the `test` example above, we would need an `Extraction Module Blacklist Z` but for the example of #10936 we would need an `Extraction Identifier Blacklist int`, which your branch solves. So, I would say that we could start from your branch and add an `Extraction Module Blacklist ...`. What do you think?\r\n\r\nYes, that sounds good.  I think I gave up because I did not understand the extraction infrastructure well enough.\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/992961455/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/992972374","html_url":"https://github.com/coq/coq/issues/11987#issuecomment-992972374","issue_url":"https://api.github.com/repos/coq/coq/issues/11987","id":992972374,"node_id":"IC_kwDOABUDh847L45W","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2021-12-13T22:31:39Z","updated_at":"2021-12-13T22:31:39Z","author_association":"MEMBER","body":"> I meant blacklisting unqualified modules and unqualified identifiers, but not qualified modules nor qualified identifiers.\r\n\r\nYes, that's what I meant too.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/992972374/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]