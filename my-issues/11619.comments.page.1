[{"url":"https://api.github.com/repos/coq/coq/issues/comments/587157962","html_url":"https://github.com/coq/coq/issues/11619#issuecomment-587157962","issue_url":"https://api.github.com/repos/coq/coq/issues/11619","id":587157962,"node_id":"MDEyOklzc3VlQ29tbWVudDU4NzE1Nzk2Mg==","user":{"login":"mikeshulman","id":646600,"node_id":"MDQ6VXNlcjY0NjYwMA==","avatar_url":"https://avatars.githubusercontent.com/u/646600?v=4","gravatar_id":"","url":"https://api.github.com/users/mikeshulman","html_url":"https://github.com/mikeshulman","followers_url":"https://api.github.com/users/mikeshulman/followers","following_url":"https://api.github.com/users/mikeshulman/following{/other_user}","gists_url":"https://api.github.com/users/mikeshulman/gists{/gist_id}","starred_url":"https://api.github.com/users/mikeshulman/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/mikeshulman/subscriptions","organizations_url":"https://api.github.com/users/mikeshulman/orgs","repos_url":"https://api.github.com/users/mikeshulman/repos","events_url":"https://api.github.com/users/mikeshulman/events{/privacy}","received_events_url":"https://api.github.com/users/mikeshulman/received_events","type":"User","site_admin":false},"created_at":"2020-02-17T21:02:07Z","updated_at":"2020-02-17T21:02:07Z","author_association":"NONE","body":"FWIW, the HoTT library currently depends on this behavior (weird though it may be).  Here's a simplified snippet that illustrates how:\r\n\r\n```coq\r\nCumulative Inductive paths {A : Type} (a : A) : A -> Type :=\r\n  idpath : paths a a.\r\n\r\nNotation \"x = y\" := (paths x y) : type_scope.\r\n\r\nInductive trunc_index : Type :=\r\n| minus_two : trunc_index\r\n| trunc_S : trunc_index -> trunc_index.\r\n\r\nFixpoint IsTrunc_internal (n : trunc_index) (A : Type) : Type :=\r\n  match n with\r\n    | minus_two => nat\r\n    | trunc_S n' => forall (x y : A), IsTrunc_internal n' (x = y)\r\n  end.\r\n\r\nDefinition IsTrunc (n : trunc_index) (A : Type) : Type :=\r\n  IsTrunc_internal n A.\r\n\r\nArguments IsTrunc : simpl never.\r\nNotation IsHProp := (IsTrunc (trunc_S minus_two)).\r\nNotation Contr := (IsTrunc minus_two).\r\n\r\nDefinition test : IsHProp nat.\r\nProof.\r\n  cbn.\r\n  (* Goal: IsHProp nat *)\r\n  simpl.\r\n  (* Goal: IsHProp nat *)\r\n  intros x y.\r\n  (* Goal: IsTrunc_internal minus_two (x = y) *)\r\n```\r\n\r\nWe don't want `IsTrunc (trunc_S n) A` to be unfolded by `simpl` or `cbn` into `forall x y:A, IsTrunc n (x=y)` (or `IsTrunc_internal n (x=y)`), since we prefer to reason and think about about the (n+1)-truncatedness of A.  But we nevertheless want to be able to _use_ the fact that (n+1)-truncatedness of A means n-truncatedness of its path-spaces, notably by proving a goal of the form `IsTrunc (trunc_S n) A` with `intros x y`.  Since `intros` uses `hnf` to expose a `forall`, this is only possible if `hnf` is willing at least sometimes to ignore `simpl never`.\r\n\r\nI never realized until just this moment that the extra indirection of `IsTrunc` vs. `IsTrunc_internal` is what makes this work, i.e. that if we just defined `IsTrunc` as a fixpoint and an `Existing Class` then it would fail.  I don't know if that indirection was put into the HoTT library expressly for this purpose, or for some other purpose and just happens to have this effect, although I from the lack of any comments in the source code about it I would guess the latter (perhaps it predates the existence of `Existing Class`?).\r\n\r\nSo if the behavior of `hnf` changes (perhaps to become more consistent), it would be nice to retain _some_ way to specify that `intros` should work on something that's definitionally a function-type even if it is marked as `simpl never`.\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/587157962/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]