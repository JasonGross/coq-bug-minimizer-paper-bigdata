Hi @JasonGross, why do you want it to be bound to a kernel name `MPdot(MPfile ["B"; "A"], "C")`. Is it for compatibility reasons with internal parts of Coq dealing with kernel names? In particular , why not to have it as the alias `A.B.C` (in the nametab) of a unique-by-construction absolute (i.e. `MPFile`-like) name (say `F.A.B.C` if the module declaration is in file `F.v`)?

If an alias is enough, a possible way to implement them would be to register the alias to `Declaremods.start_module`/`Lib.start_mod` (in addition to the absolute name !lib_state.path_prefix.Nametab.obj_dir) and to do so that each new object put in the module comes with an alias of same prefix (to be done at the `load`/`open` time of each individual named declaration of the module).

Namespaces were actually discussed at the call today. @ppedrot said he has ideas on how to implement them. There is also the [cep](https://github.com/coq/ceps/pull/25#issuecomment-723988445). On my side, it is not clear whether modules are not enough to simulate namespaces but I'm also ok to have a secondary notion of container distinct from modules. In any case, @ppedrot and @gares, what can we do to help you in this direction (and in particular, what can I do with #14492)?
The motivation here is a bit different from that of namespaces, even if the features overlap.  For the bug minimizer, I want a way to combine two files into a single file in a way that guarantees that everything behaves exactly the same as if I had two separate files where the second one `Require`d the first one.  This includes quirks like Coq refusing to shadow absolute names.  Does this shadowing behavior apply to aliases as well, or only to kernel names?
Inlining files will also have trouble with require time effects. Suppose file A has `Global Set Primitive Projections`, file B has `Global Set Universe Polymorphism`, and file C requires A and B. You can't inline both A and B because one will affect the other.

Rather than hacking the Coq name system maybe the minimizer could work on multiple files?
Indeed, global side effects of Require cause issues with the minimizer, and I may eventually have the minimizer handle multiple files to deal with this.  But handling multiple files is an enormous increase in complexity.  At a minimum, I'd have to handle the following:
- having two copies of the dependent file, one for producing the .vo associated with the coqc that should succeed, and another for the coqc that should fail
- somehow convincing coqc to load my version of the file rather than the one from the original development, ideally without breaking the contract that the minimizer doesn't change .v files in your development.  Note that the original development still needs to be bound for the other Requires to work.  I suppose I could copy the entire development tree to a new location, and operate on that in place, but this is still moderately more complex (and fails pretty badly if the minimizer is also trying to inline things from user-contrib, which it generally is).

If it's not too complicated to add an attribute that allows setting the unshadowable absolute name, I'd very much appreciate that.
Note also that copying the whole development tree including .vo files may be expensive space-wise, and AFAIK there's no easy way to discover what OCaml compiler outputs I have to copy and where I have to put them to get OCaml plugins to work (let alone copying other dependencies like elpi files), which suggests that in fact I'd end up having to copy everything in the search path of coqc.
Yet another complication: I'd also need to somehow instruct the minimizer on what arguments to pass to coqc to compile any given file in the search path of coqc.
I don't think we want to implement this. Shall we close?
