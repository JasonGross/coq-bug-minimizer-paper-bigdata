[{"url":"https://api.github.com/repos/coq/coq/issues/comments/381997326","html_url":"https://github.com/coq/coq/issues/7273#issuecomment-381997326","issue_url":"https://api.github.com/repos/coq/coq/issues/7273","id":381997326,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MTk5NzMyNg==","user":{"login":"ppedrot","id":1202327,"node_id":"MDQ6VXNlcjEyMDIzMjc=","avatar_url":"https://avatars.githubusercontent.com/u/1202327?v=4","gravatar_id":"","url":"https://api.github.com/users/ppedrot","html_url":"https://github.com/ppedrot","followers_url":"https://api.github.com/users/ppedrot/followers","following_url":"https://api.github.com/users/ppedrot/following{/other_user}","gists_url":"https://api.github.com/users/ppedrot/gists{/gist_id}","starred_url":"https://api.github.com/users/ppedrot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ppedrot/subscriptions","organizations_url":"https://api.github.com/users/ppedrot/orgs","repos_url":"https://api.github.com/users/ppedrot/repos","events_url":"https://api.github.com/users/ppedrot/events{/privacy}","received_events_url":"https://api.github.com/users/ppedrot/received_events","type":"User","site_admin":false},"created_at":"2018-04-17T13:43:48Z","updated_at":"2018-04-17T13:43:48Z","author_association":"MEMBER","body":"Where can I find the `Crypto.Util.Option` module (or alternatively, can you inline it in the example)?","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/381997326/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/382327944","html_url":"https://github.com/coq/coq/issues/7273#issuecomment-382327944","issue_url":"https://api.github.com/repos/coq/coq/issues/7273","id":382327944,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MjMyNzk0NA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-04-18T09:39:43Z","updated_at":"2018-04-18T09:39:43Z","author_association":"MEMBER","body":"Urg, that didn't get inlined?  There's probably a bug in my bug minimizer somewhere...  Anyway, it's at https://github.com/mit-plv/fiat-crypto/blob/master/src/Util/Option.v and I'll plan to make a new version of the file with this inlined within the next day.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/382327944/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/382568942","html_url":"https://github.com/coq/coq/issues/7273#issuecomment-382568942","issue_url":"https://api.github.com/repos/coq/coq/issues/7273","id":382568942,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MjU2ODk0Mg==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-04-19T00:16:39Z","updated_at":"2018-04-19T00:16:39Z","author_association":"MEMBER","body":"Updated version with everything inlined: \r\n[bug_slow_vm_PHOAS_08.zip](https://github.com/coq/coq/files/1926164/bug_slow_vm_PHOAS_08.zip)\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/382568942/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/382616904","html_url":"https://github.com/coq/coq/issues/7273#issuecomment-382616904","issue_url":"https://api.github.com/repos/coq/coq/issues/7273","id":382616904,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MjYxNjkwNA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-04-19T05:42:51Z","updated_at":"2018-04-19T05:42:51Z","author_association":"MEMBER","body":"Here's an even smaller example of this issue:  [bug_slow_vm2_04.zip](https://github.com/coq/coq/files/1926758/bug_slow_vm2_04.zip)\r\nNote that the version that calls `Red2` without pre-reducting `FromFlat` is 10x slower than any of the other versions.\r\nAnd here's the inline version, since this one is relatively short:\r\n```coq\r\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-R\" \".\" \"Top\" \"-top\" \"bug_slow_vm2_01\") -*- *)\r\n(* File reduced by coq-bug-finder from original input, then from 4431 lines to 3382 lines, then from 3059 lines to 2535 lines, then from 2589 lines to 2515 lines, then from 2606 lines to 2524 lines, then from 2682 lines to 2570 lines, then from 2715 lines to 2585 lines, then from 2720 lines to 2585 lines, then from 2644 lines to 2585 lines, then from 2675 lines to 2585 lines, then from 2687 lines to 2585 lines, then from 3027 lines to 2585 lines, then from 2715 lines to 2585 lines, then from 2685 lines to 2585 lines, then from 2763 lines to 2585 lines, then from 2647 lines to 2585 lines, then from 2692 lines to 2595 lines, then from 2781 lines to 2612 lines, then from 2700 lines to 2688 lines, then from 4973 lines to 2642 lines, then from 2758 lines to 2642 lines, then from 2728 lines to 2642 lines, then from 2806 lines to 2642 lines, then from 2690 lines to 2642 lines, then from 2717 lines to 2642 lines, then from 2701 lines to 2642 lines, then from 2667 lines to 2642 lines, then from 3356 lines to 464 lines, then from 375 lines to 362 lines, then from 378 lines to 362 lines *)\r\n(* coqc version 8.7.1 (December 2017) compiled on Dec 22 2017 15:56:58 with OCaml 4.02.3\r\n   coqtop version 8.7.1 (December 2017) *)\r\nRequire Coq.FSets.FMapPositive.\r\n\r\nGlobal Set Asymmetric Patterns.\r\nReserved Notation \"A <- X ; B\" (at level 70, X at next level, right associativity, format \"'[v' A  <-  X ; '/' B ']'\").\r\nDefinition bind {A B} (v : option A) (f : A -> option B) : option B\r\n  := match v with\r\n     | Some v => f v\r\n     | None => None\r\n     end.\r\nDelimit Scope option_scope with option.\r\nNotation \"A <- X ; B\" := (bind X (fun A => B%option)) : option_scope.\r\nReserved Infix \"@\" (left associativity, at level 11).\r\nReserved Infix \"@@\" (left associativity, at level 11).\r\nReserved Notation \"'λ' x .. y , t\" (at level 200, x binder, y binder, right associativity, format \"'λ'  x .. y , '//' t\").\r\nImport Coq.ZArith.ZArith.\r\nImport Coq.FSets.FMapPositive.\r\nModule type.\r\n  Variant primitive := unit | Z | nat.\r\n  Inductive type := type_primitive (_:primitive) | prod (A B : type) | arrow (s d : type).\r\n  Module Export Coercions.\r\n    Global Coercion type_primitive : primitive >-> type.\r\n  End Coercions.\r\n\r\n  Fixpoint interp (t : type)\r\n    := match t with\r\n       | unit => Datatypes.unit\r\n       | prod A B => interp A * interp B\r\n       | arrow A B => interp A -> interp B\r\n       | nat => Datatypes.nat\r\n       | type_primitive Z => BinInt.Z\r\n       end%type.\r\n\r\n  Fixpoint try_transport (P : type -> Type) (t1 t2 : type) : P t1 -> option (P t2)\r\n    := match t1, t2 return P t1 -> option (P t2) with\r\n       | unit, unit\r\n       | Z, Z\r\n       | nat, nat\r\n         => @Some _\r\n       | prod A B, prod A' B'\r\n         => fun v\r\n            => (v <- try_transport (fun A => P (prod A B)) A A' v;\r\n                  try_transport (fun B => P (prod A' B)) B B' v)%option\r\n       | arrow s d, arrow s' d'\r\n         => fun v\r\n            => (v <- try_transport (fun s => P (arrow s d)) s s' v;\r\n                  try_transport (fun d => P (arrow s' d)) d d' v)%option\r\n       | unit, _\r\n       | Z, _\r\n       | nat, _\r\n       | prod _ _, _\r\n       | arrow _ _, _\r\n         => fun _ => None\r\n       end.\r\n\r\n  Module Export Notations.\r\n    Export Coercions.\r\n    Bind Scope ctype_scope with type.\r\n    Notation \"()\" := unit : ctype_scope.\r\n    Notation \"A * B\" := (prod A B) : ctype_scope.\r\n    Notation \"A -> B\" := (arrow A B) : ctype_scope.\r\n    Notation type := type.\r\n  End Notations.\r\nEnd type.\r\nExport type.Notations.\r\nModule Export expr.\r\n  Inductive expr {ident : type -> type -> Type} {var : type -> Type} : type -> Type :=\r\n  | Var {t} (v : var t) : expr t\r\n  | TT : expr type.unit\r\n  | AppIdent {s d} (idc : ident s d) (args : expr s) : expr d\r\n  | App {s d} (f : expr (s -> d)) (x : expr s) : expr d\r\n  | Pair {A B} (a : expr A) (b : expr B) : expr (A * B)\r\n  | Abs {s d} (f : var s -> expr d) : expr (s -> d).\r\n\r\n  Definition Expr {ident : type -> type -> Type} t := forall var, @expr ident var t.\r\n  Bind Scope expr_scope with expr.\r\n  Delimit Scope expr_scope with expr.\r\n\r\n  Infix \"@\" := App : expr_scope.\r\n  Infix \"@@\" := AppIdent : expr_scope.\r\n  Notation \"( x , y , .. , z )\" := (Pair .. (Pair x%expr y%expr) .. z%expr) : expr_scope.\r\n  Notation \"'λ'  x .. y , t\" := (Abs (fun x => .. (Abs (fun y => t%expr)) ..)) : expr_scope.\r\nEnd expr.\r\nModule ident.\r\n  Import type.\r\n  Inductive ident : type -> type -> Set :=\r\n  | primitive {t : type.primitive} (v : interp t) : ident () t\r\n  | Let_In {tx tC} : ident (tx * (tx -> tC)) tC\r\n  | Nat_succ : ident nat nat\r\n  | fst {A B} : ident (A * B) A\r\n  | snd {A B} : ident (A * B) B\r\n  | nat_rect {P} : ident ((unit -> P) * (nat * P -> P) * nat) P\r\n  | pred : ident nat nat\r\n  .\r\nEnd ident.\r\nNotation ident := ident.ident.\r\nNotation expr := (@expr ident).\r\nSection invert.\r\n  Context {var : type -> Type}.\r\n  Local Notation if_prod f\r\n    := (fun t => match t return Type with\r\n                 | type.prod A B => f A B\r\n                 | _ => True\r\n                 end).\r\n\r\n  Definition invert_Pair {A B} (e : @expr var (type.prod A B)) : option (@expr var A * @expr var B)\r\n    := match e in expr.expr t return option (if_prod (fun A B => expr A * expr B)%type t) with\r\n       | Pair A B a b\r\n         => Some (a, b)\r\n       | _ => None\r\n       end.\r\nEnd invert.\r\nModule Export primitive.\r\n  Definition default {t : type.primitive} : type.interp t\r\n    := match t with\r\n       | type.unit => tt\r\n       | type.Z => (-1)%Z\r\n       | type.nat => 0%nat\r\n       end.\r\nEnd primitive.\r\nSection with_var.\r\n  Context {var : type -> Type}.\r\n  Fixpoint default {t : type} : @expr var t\r\n    := match t with\r\n       | type.type_primitive x\r\n         => AppIdent (ident.primitive primitive.default) TT\r\n       | type.prod A B\r\n         => (@default A, @default B)\r\n       | type.arrow s d => Abs (fun _ => @default d)\r\n       end.\r\nEnd with_var.\r\nModule Flat.\r\n  Inductive expr : type -> Set :=\r\n  | Var (t : type) (n : positive) : expr t\r\n  | TT : expr type.unit\r\n  | AppIdent {s d} (idc : ident s d) (arg : expr s) : expr d\r\n  | App {s d} (f : expr (s -> d)) (x : expr s) : expr d\r\n  | Pair {A B} (a : expr A) (b : expr B) : expr (A * B)\r\n  | Abs (s : type) (n : positive) {d} (f : expr d) : expr (s -> d).\r\nEnd Flat.\r\n\r\nDefinition ERROR {T} (v : T) : T.\r\nexact v.\r\nQed.\r\n\r\nFixpoint to_flat' {t} (e : @expr (fun _ => PositiveMap.key) t)\r\n         (cur_idx : PositiveMap.key)\r\n  : Flat.expr t\r\n  := match e in expr.expr t return Flat.expr t with\r\n     | Var t v => Flat.Var t v\r\n     | TT => Flat.TT\r\n     | AppIdent s d idc args\r\n       => Flat.AppIdent idc (@to_flat' _ args cur_idx)\r\n     | App s d f x => Flat.App\r\n                        (@to_flat' _ f cur_idx)\r\n                        (@to_flat' _ x cur_idx)\r\n     | Pair A B a b => Flat.Pair\r\n                         (@to_flat' _ a cur_idx)\r\n                         (@to_flat' _ b cur_idx)\r\n     | Abs s d f\r\n       => Flat.Abs s cur_idx\r\n                   (@to_flat'\r\n                      d (f cur_idx)\r\n                      (Pos.succ cur_idx))\r\n     end.\r\n\r\nFixpoint from_flat {t} (e : Flat.expr t)\r\n  : forall var, PositiveMap.t { t : type & var t } -> @expr var t\r\n  := match e in Flat.expr t return forall var, PositiveMap.t { t : type & var t } -> expr t with\r\n     | Flat.Var t v\r\n       => fun var ctx\r\n          => match (tv <- PositiveMap.find v ctx;\r\n                      type.try_transport var _ _ (projT2 tv))%option with\r\n             | Some v => Var v\r\n             | None => ERROR default\r\n             end\r\n     | Flat.TT => fun _ _ => TT\r\n     | Flat.AppIdent s d idc args\r\n       => let args' := @from_flat _ args in\r\n          fun var ctx => AppIdent idc (args' var ctx)\r\n     | Flat.App s d f x\r\n       => let f' := @from_flat _ f in\r\n          let x' := @from_flat _ x in\r\n          fun var ctx => App (f' var ctx) (x' var ctx)\r\n     | Flat.Pair A B a b\r\n       => let a' := @from_flat _ a in\r\n          let b' := @from_flat _ b in\r\n          fun var ctx => Pair (a' var ctx) (b' var ctx)\r\n     | Flat.Abs s cur_idx d f\r\n       => let f' := @from_flat d f in\r\n          fun var ctx\r\n          => Abs (fun v => f' var (PositiveMap.add cur_idx (existT _ s v) ctx))\r\n     end.\r\n\r\nDefinition to_flat {t} (e : expr t) : Flat.expr t\r\n  := to_flat' e 1%positive.\r\nDefinition ToFlat {t} (E : Expr t) : Flat.expr t\r\n  := to_flat (E _).\r\nDefinition FromFlat {t} (e : Flat.expr t) : Expr t\r\n  := let e' := @from_flat t e in\r\n     fun var => e' var (PositiveMap.empty _).\r\nOpen Scope Z_scope.\r\n\r\nFixpoint value var (t : type)\r\n  := match t with\r\n     | type.prod A B as t => @expr var t + value var A * value var B\r\n     | type.arrow s d => value var s -> value var d\r\n     | type.type_primitive _ as t\r\n       => @expr var t + type.interp t\r\n     end%type.\r\nFixpoint reify {var t} : value var t -> @expr var t\r\n  := match t with\r\n     | type.prod A B\r\n       => fun v\r\n          => match v with\r\n             | inl e => e\r\n             | inr (a, b) => Pair (@reify var A a) (@reify var B b)\r\n             end\r\n     | type.arrow s d\r\n       => fun f => Abs (fun v => @reify var _ (f (@reflect var _ (Var v))))\r\n     | type.type_primitive _ as t\r\n       => fun v\r\n          => match v with\r\n             | inl e => e\r\n             | inr v => ident.primitive v @@ TT\r\n             end%expr\r\n     end\r\nwith reflect {var t} : @expr var t -> value var t\r\n     := match t with\r\n        | type.prod A B\r\n          => fun v\r\n             => match invert_Pair v with\r\n                | Some (a, b) => inr (@reflect var A a, @reflect var B b)\r\n                | None => inl v\r\n                end\r\n        | type.arrow s d\r\n          => fun f v\r\n             => @reflect var _ (App f (@reify var _ v))\r\n        | type.type_primitive _ as t\r\n          => fun v\r\n             => inl v\r\n        end.\r\n\r\nDefinition red'_ident {var s d} (idc : ident s d) : value var s -> value var d\r\n  := match idc in ident s d return value var s -> value var d with\r\n     | ident.fst A B as idc\r\n       => fun v\r\n          => match v with\r\n             | inr (a, b) => a\r\n             | inl _ => reflect (AppIdent idc (reify v))\r\n             end\r\n     | ident.snd A B as idc\r\n       => fun v\r\n          => match v with\r\n             | inr (a, b) => b\r\n             | inl _ => reflect (AppIdent idc (reify v))\r\n             end\r\n     | ident.primitive t v => fun _ => inr v\r\n     | ident.Nat_succ as idc\r\n       => fun v => match v with\r\n                   | inr v => inr (S v)\r\n                   | inl _ => reflect (AppIdent idc (reify v))\r\n                   end\r\n     | idc\r\n       => fun v => reflect (AppIdent idc (reify v))\r\n     end.\r\n\r\nDefinition red'_ident2 {var s d} (idc : ident s d) : value var s -> value var d\r\n  := match idc in ident s d return value var s -> value var d with\r\n     | ident.fst A B as idc\r\n       => fun v\r\n          => match v with\r\n             | inr (a, b) => a\r\n             | inl _ => reflect (AppIdent idc (reify v))\r\n             end\r\n     | ident.snd A B as idc\r\n       => fun v\r\n          => match v with\r\n             | inr (a, b) => b\r\n             | inl _ => reflect (AppIdent idc (reify v))\r\n             end\r\n     | ident.primitive t v => fun _ => inr v\r\n     | ident.Nat_succ as idc\r\n       => fun v => match v with\r\n                   | inr v => inr (S v)\r\n                   | inl _ => reflect (AppIdent idc (reify v))\r\n                   end\r\n     | ident.nat_rect P as idc\r\n       => fun v\r\n          => match v with\r\n             | inr (inr (N, C), inr n)\r\n               => nat_rect\r\n                    (fun _ => value var P)\r\n                    (N (inr tt))\r\n                    (fun n' v => C (inr (inr n', v)))\r\n                    n\r\n             | _ => reflect (AppIdent idc (reify v))\r\n             end\r\n     | idc\r\n       => fun v => reflect (AppIdent idc (reify v))\r\n     end.\r\n\r\nFixpoint red' {var}\r\n         (red'_ident : forall {s d}, ident s d -> value var s -> value var d)\r\n         {t} (e : @expr (value var) t) : value var t\r\n  := match e in expr.expr t return value var t with\r\n     | Var t v => v\r\n     | TT => inr tt\r\n     | App s d f x\r\n       => @red' var (@red'_ident) _ f (@red' var (@red'_ident) _ x)\r\n     | AppIdent _ _ idc args\r\n       => red'_ident idc (@red' var (@red'_ident) _ args)\r\n     | Pair A B a b => inr (@red' var (@red'_ident) A a, @red' var (@red'_ident) B b)\r\n     | Abs s d f => fun v => @red' var (@red'_ident) d (f v)\r\n     end.\r\n\r\nDefinition Red {t} (e : Expr t) : Expr t\r\n  := fun var => reify (red' (@red'_ident _) (e _)).\r\nDefinition Red2 {t} (e : Expr t) : Expr t\r\n  := fun var => reify (red' (@red'_ident2 _) (e _)).\r\n\r\nDefinition prek''\r\n  := fun var : type -> Type =>\r\n       (λ (_ : var type.unit),\r\n        ident.nat_rect\r\n          @@ ((λ _ x1,\r\n               (Var x1)\r\n                 @ (λ x2,\r\n                    ident.snd @@ Var x2 @ (ident.primitive (t:=type.Z) 0 @@ TT))),\r\n              (λ x0 x1,\r\n               (ident.snd @@ Var x0)\r\n                 @ (λ x2,\r\n                    (Var x1)\r\n                      @ (λ x3,\r\n                         ident.nat_rect\r\n                           @@ ((λ _ x5,\r\n                                Var x5 @ (ident.primitive (t:=type.Z) 0 @@ TT)),\r\n                               (λ x4 x5,\r\n                                (ident.snd @@ Var x4)\r\n                                  @ (λ _,\r\n                                     Var x2 @ ((ident.fst @@ Var x4),\r\n                                               (λ x7, Var x5 @ Var x7)))),\r\n                               ident.fst @@ Var x3)\r\n                           @ (λ x4, ident.snd @@ Var x3 @ Var x4)))),\r\n              ident.primitive (t:=type.nat) 10%nat @@ TT)\r\n          @ (λ x0,\r\n             Var x0 @ ((ident.primitive (t:=type.nat) 10%nat @@ TT),\r\n                       (λ x1, Var x1))))%expr.\r\nDefinition k'' := Eval cbv in ToFlat prek''.\r\nDefinition ToFlatFFromFlat_Slow2 (_ : unit) := ToFlat (Red2 (FromFlat k'')).\r\nDefinition ToFlatFFromFlat_Fast2 (_ : unit) := ToFlat (Red (FromFlat k'')).\r\nTime Definition k''' := Eval vm_compute in FromFlat k''. (* 0.007 s *)\r\nDefinition ToFlatFFromFlat_Slow2' (_ : unit) := ToFlat (Red2 k''').\r\nDefinition ToFlatFFromFlat_Fast2' (_ : unit) := ToFlat (Red k''').\r\nTime Definition x0 := Eval vm_compute in ToFlatFFromFlat_Slow2. (* 0.061 s *)\r\nTime Definition x1 := Eval vm_compute in ToFlatFFromFlat_Fast2. (* 0.006 s *)\r\nTime Definition x0' := Eval vm_compute in ToFlatFFromFlat_Slow2'. (* 0.006 s *)\r\nTime Definition x1' := Eval vm_compute in ToFlatFFromFlat_Fast2'. (* 0.006 s *)\r\n```\r\n\r\nThe term we are looking at here is a reified and cps'd version of\r\n```coq\r\nnat_rect\r\n  (fun _ => nat -> Z)\r\n  (fun _ => 0)\r\n  (fun xs rec (v:nat)\r\n   => nat_rect (fun _ => Z) 0 (fun ys _ => rec ys) v)\r\n  k\r\n  k\r\n```\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/382616904/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/383056515","html_url":"https://github.com/coq/coq/issues/7273#issuecomment-383056515","issue_url":"https://api.github.com/repos/coq/coq/issues/7273","id":383056515,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MzA1NjUxNQ==","user":{"login":"ppedrot","id":1202327,"node_id":"MDQ6VXNlcjEyMDIzMjc=","avatar_url":"https://avatars.githubusercontent.com/u/1202327?v=4","gravatar_id":"","url":"https://api.github.com/users/ppedrot","html_url":"https://github.com/ppedrot","followers_url":"https://api.github.com/users/ppedrot/followers","following_url":"https://api.github.com/users/ppedrot/following{/other_user}","gists_url":"https://api.github.com/users/ppedrot/gists{/gist_id}","starred_url":"https://api.github.com/users/ppedrot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ppedrot/subscriptions","organizations_url":"https://api.github.com/users/ppedrot/orgs","repos_url":"https://api.github.com/users/ppedrot/repos","events_url":"https://api.github.com/users/ppedrot/events{/privacy}","received_events_url":"https://api.github.com/users/ppedrot/received_events","type":"User","site_admin":false},"created_at":"2018-04-20T10:33:59Z","updated_at":"2018-04-20T10:33:59Z","author_association":"MEMBER","body":"As a general remark, It is not unexpected that on functional terms first VM-reducing the argument before the function can be faster. The reason is that contrarily to mere weak cbv reduction, the VM also performs strong reduction and for that it needs to reify the resulting values, which may lead to exponential behaviour as the reifying function doesn't take advantage of sharing.\r\n\r\nIn your particular case, I think that it might be further worsened by a suboptimal implementation of function reification. In the VM functions can be n-ary (the `GRAB` code takes an integer argument), but the `Vnorm.nf_fun` function doesn't seem to take that into account as it simply abstracts over one variable at at time. Might be worth to trick that.\r\n\r\nAlso summoning @maximedenes and @bgregoir, they probably know more.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/383056515/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/383644313","html_url":"https://github.com/coq/coq/issues/7273#issuecomment-383644313","issue_url":"https://api.github.com/repos/coq/coq/issues/7273","id":383644313,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MzY0NDMxMw==","user":{"login":"ppedrot","id":1202327,"node_id":"MDQ6VXNlcjEyMDIzMjc=","avatar_url":"https://avatars.githubusercontent.com/u/1202327?v=4","gravatar_id":"","url":"https://api.github.com/users/ppedrot","html_url":"https://github.com/ppedrot","followers_url":"https://api.github.com/users/ppedrot/followers","following_url":"https://api.github.com/users/ppedrot/following{/other_user}","gists_url":"https://api.github.com/users/ppedrot/gists{/gist_id}","starred_url":"https://api.github.com/users/ppedrot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ppedrot/subscriptions","organizations_url":"https://api.github.com/users/ppedrot/orgs","repos_url":"https://api.github.com/users/ppedrot/repos","events_url":"https://api.github.com/users/ppedrot/events{/privacy}","received_events_url":"https://api.github.com/users/ppedrot/received_events","type":"User","site_admin":false},"created_at":"2018-04-23T16:48:28Z","updated_at":"2018-04-23T16:48:28Z","author_association":"MEMBER","body":"Forget everything I have said above, I think this is just call-by-value semantics. Your example boils down to the following observation: `f (fun () -> e)` can be way slower than `let x = e in f (fun () -> x)`, assuming they have the same semantics (which is the case because Coq is pure).\r\n\r\nIn your case, the `Expr` type represents higher-order computations, so that they are thunked and never computed upfront. Calling cbv simply allows for partial reduction and thus computation sharing inside that thunk. The main contender for the slowness you experience here seems to be the `value` function, which I found perfing `native_compute`, and that seems to repeatedly compute its environment argument.\r\n\r\nI'd personally dismiss this bug as INVALID.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/383644313/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/383665788","html_url":"https://github.com/coq/coq/issues/7273#issuecomment-383665788","issue_url":"https://api.github.com/repos/coq/coq/issues/7273","id":383665788,"node_id":"MDEyOklzc3VlQ29tbWVudDM4MzY2NTc4OA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-04-23T17:55:50Z","updated_at":"2018-04-23T17:55:50Z","author_association":"MEMBER","body":"If you dismiss this as invalid, could you grant https://github.com/coq/coq/issues/7159 ?  I don't see any other way to work around this without the ability to demand that a function be fully computed early.\r\n\r\nI'm also confused by your comment about `value`.  It takes a `var` argument which should remain thunked, a type code argument which should be small, and produces a `Type`.  If most of the time is spent computing `value` (rather than computing things of type `value`), that seems wrong.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/383665788/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/398845934","html_url":"https://github.com/coq/coq/issues/7273#issuecomment-398845934","issue_url":"https://api.github.com/repos/coq/coq/issues/7273","id":398845934,"node_id":"MDEyOklzc3VlQ29tbWVudDM5ODg0NTkzNA==","user":{"login":"ppedrot","id":1202327,"node_id":"MDQ6VXNlcjEyMDIzMjc=","avatar_url":"https://avatars.githubusercontent.com/u/1202327?v=4","gravatar_id":"","url":"https://api.github.com/users/ppedrot","html_url":"https://github.com/ppedrot","followers_url":"https://api.github.com/users/ppedrot/followers","following_url":"https://api.github.com/users/ppedrot/following{/other_user}","gists_url":"https://api.github.com/users/ppedrot/gists{/gist_id}","starred_url":"https://api.github.com/users/ppedrot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ppedrot/subscriptions","organizations_url":"https://api.github.com/users/ppedrot/orgs","repos_url":"https://api.github.com/users/ppedrot/repos","events_url":"https://api.github.com/users/ppedrot/events{/privacy}","received_events_url":"https://api.github.com/users/ppedrot/received_events","type":"User","site_admin":false},"created_at":"2018-06-20T18:13:09Z","updated_at":"2018-06-20T18:13:09Z","author_association":"MEMBER","body":"I think I'll close this issue, there is the other report for the wish.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/398845934/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]