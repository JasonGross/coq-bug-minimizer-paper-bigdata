[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337529273","html_url":"https://github.com/coq/coq/issues/3922#issuecomment-337529273","issue_url":"https://api.github.com/repos/coq/coq/issues/3922","id":337529273,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyOTI3Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-01-16T11:27:38Z","updated_at":"2017-10-18T09:46:28Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nMatthieu has already debugged the problem, so this is primarily for the test-suite.\n\n(* File reduced by coq-bug-finder from original input, then from 8338 lines to 7688 lines, then from 6940 lines to 91 lines, then from 106 lines to 86 lines *)\n(* coqc version trunk (January 2015) compiled on Jan 16 2015 4:25:15 with OCaml 4.01.0\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (62ce6ac2a237917d9f75f78439898787a27829ad) *)\n\nSet Universe Polymorphism.\nNotation Type0 := Set.\n\nDefinition Type1 := Eval hnf in let gt := (Set : Type@ {i}) in Type@ {i}.\n\nNotation compose := (fun g f x => g (f x)).\n\nNotation \"g 'o' f\" := (compose g f) (at level 40, left associativity) : function_scope.\nOpen Scope function_scope.\n\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x)\n  := forall x:A, f x = g x.\n\nNotation \"f == g\" := (pointwise_paths f g) (at level 70, no associativity) : type_scope.\n\nClass Contr_internal (A : Type) := BuildContr {\n  center : A ;\n  contr : (forall y : A, center = y)\n}.\n\nInductive trunc_index : Type :=\n| minus_two : trunc_index\n| trunc_S : trunc_index -> trunc_index.\n\nNotation \"n .+1\" := (trunc_S n) (at level 2, left associativity, format \"n .+1\") : trunc_scope.\nLocal Open Scope trunc_scope.\nNotation \"-2\" := minus_two (at level 0) : trunc_scope.\nNotation \"-1\" := (-2.+1) (at level 0) : trunc_scope.\n\nFixpoint IsTrunc_internal (n : trunc_index) (A : Type) : Type :=\n  match n with\n    | -2 => Contr_internal A\n    | n'.+1 => forall (x y : A), IsTrunc_internal n' (x = y)\n  end.\n\nClass IsTrunc (n : trunc_index) (A : Type) : Type :=\n  Trunc_is_trunc : IsTrunc_internal n A.\n\nNotation Contr := (IsTrunc -2).\nNotation IsHProp := (IsTrunc -1).\n\nMonomorphic Axiom dummy_funext_type : Type0.\nMonomorphic Class Funext := { dummy_funext_value : dummy_funext_type }.\n\nInductive Unit : Type1 :=\n    tt : Unit.\n\nRecord TruncType (n : trunc_index) := BuildTruncType {\n  trunctype_type : Type ;\n  istrunc_trunctype_type : IsTrunc n trunctype_type\n}.\n\nArguments BuildTruncType _ _ {_}.\n\nCoercion trunctype_type : TruncType >-> Sortclass.\n\nNotation \"n -Type\" := (TruncType n) (at level 1) : type_scope.\nNotation hProp := (-1)-Type.\n\nNotation BuildhProp := (BuildTruncType -1).\n\nPrivate Inductive Trunc (n : trunc_index) (A :Type) : Type :=\n  tr : A -> Trunc n A.\nArguments tr {n A} a.\n\nGlobal Instance istrunc_truncation (n : trunc_index) (A : Type@ {i})\n: IsTrunc@ {j} n (Trunc@ {i} n A).\nAdmitted.\n\nDefinition Trunc_ind {n A}\n  (P : Trunc n A -> Type) {Pt : forall aa, IsTrunc n (P aa)}\n  : (forall a, P (tr a)) -> (forall aa, P aa)\n:= (fun f aa => match aa with tr a => fun _ => f a end Pt).\nDefinition merely (A : Type@ {i}) : hProp@ {i} := BuildhProp (Trunc -1 A).\nDefinition cconst_factors_contr `{Funext}  {X Y : Type} (f : X -> Y)\n           (P : Type) `{Pc : X -> Contr P}\n           (g : X -> P) (h : P -> Y) (p : h o g == f)\n: Unit.\nProof.\n  assert (merely X -> IsHProp P) by admit.\n  refine (let g' := Trunc_ind (fun _ => P) g : merely X -> P in _);\n    [ assumption.. | ].\n  pose (g' := Trunc_ind (fun _ => P) g : merely X -> P). (* Toplevel input, characters 15-69:\nError:\nUnable to satisfy the following constraints:\nIn environment:\nH : Funext\nX : Type\nY : Type\nf : X -> Y\nP : Type\nPc : X -> Contr P\ng : X -> P\nh : P -> Y\np : (fun x : X => h (g x)) == f\nX0 : merely X -> IsHProp P\ng' := Trunc_ind (fun _ : Trunc (-1) X => P) g : merely X -> P\n\n?Pt : \"forall aa : Trunc (-1) X, IsHProp ((fun _ : Trunc (-1) X => P) aa)\"\n *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337529273/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]