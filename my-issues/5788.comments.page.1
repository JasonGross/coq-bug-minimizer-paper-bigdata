[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337559471","html_url":"https://github.com/coq/coq/issues/5788#issuecomment-337559471","issue_url":"https://api.github.com/repos/coq/coq/issues/5788","id":337559471,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU1OTQ3MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-10-16T01:47:48Z","updated_at":"2021-08-21T14:19:45Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n```coq\r\nDefinition foo x :=\r\n  (fun (p1 : nat) (p2 : p1 = 2)\r\n   => exist (fun a => a = 2) p1 p2) (proj1_sig x) (proj2_sig x).\r\n(* Error: In environment\r\nx : {x : nat | ?P x}\r\nUnable to unify \"?P (proj1_sig x)\" with \"proj1_sig x = 2\".\r\n *)\r\n```\r\nIs this in the pattern fragment?  It's true that ?P appears in <args>....\r\n\r\nAlso, I can get the rather confusing error message \"Unable to unify \"?P\" with \r\n\"?T\".\"\r\n```coq\r\nSet Printing All.\r\nDefinition foo :=\r\n  let T := _ in\r\n  let P := _ in\r\n  fun (x : sig P) =>\r\n    (fun (p1 : nat) (p2 : p1 = 2)\r\n     => exist (fun a => a = 2) p1 p2) (let 'exist _ a p := x in a) (match x as \r\ne return T (let 'exist _ a p := e in a) with exist _ a p => p end).\r\n(* Error:\r\nIn environment\r\nT := ?T : forall _ : nat, Type\r\nP := ?P : forall _ : nat, Prop\r\nx : @ sig nat P\r\na : nat\r\np : P a\r\nUnable to unify \"?P\" with \"?T\".\r\n *)\r\n```\r\n\r\nMoreover, I can get:\r\nUnable to unify \"?x@ {v:=match x return nat with\r\n                        | exist _ a _ => a\r\n                        end}\" with\r\n \"match x return nat with\r\n  | exist _ a _ => a\r\n  end\".\r\n\r\nby writing:\r\n```coq\r\nSet Printing All.\r\nSet Printing Existential Instances.\r\nDefinition foo :=\r\n  let T := fun v => @ eq _ _ _ in\r\n  let P := T in\r\n  fun (x : sig P) =>\r\n    (fun (p1 : nat) (p2 : p1 = 2)\r\n     => exist (fun a => a = 2) p1 p2) (let 'exist _ a p := x in a) (match x as \r\ne return T (let 'exist _ a p := e in a) with exist _ a p => p end).\r\n(* Error:\r\nIn environment\r\nT := fun v : nat => @ eq nat ?x@ {v:=v} (S (S O)) : forall _ : nat, Prop\r\nx : @ sig nat T\r\nUnable to unify \"?x@ {v:=match x return nat with\r\n                        | exist _ a _ => a\r\n                        end}\" with\r\n \"match x return nat with\r\n  | exist _ a _ => a\r\n  end\".\r\n*)\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337559471/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337559472","html_url":"https://github.com/coq/coq/issues/5788#issuecomment-337559472","issue_url":"https://api.github.com/repos/coq/coq/issues/5788","id":337559472,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU1OTQ3Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-10-16T01:55:25Z","updated_at":"2021-08-21T14:20:18Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nEven better:\r\n```\r\nSet Printing All.\r\nSet Printing Existential Instances.\r\nDefinition foo :=\r\n  let T := let f := _ in fun v => @ eq _ (f v) _ in\r\n  let P := T in\r\n  fun (x : sig P) =>\r\n    (fun (p1 : nat) (p2 : p1 = 2)\r\n     => exist (fun a => a = 2) p1 p2) (let 'exist _ a p := x in a) (match x as \r\ne return T (let 'exist _ a p := e in a) with exist _ a p => p end).\r\n(* Error:\r\nIn environment\r\nT :=\r\nlet f : forall _ : nat, nat := ?n in fun v : nat => @ eq nat (f v) (S (S O)) :\r\nforall _ : nat, Prop\r\nx : @ sig nat T\r\nUnable to unify \"?n match x return nat with\r\n                    | exist _ a _ => a\r\n                    end\" with\r\n \"match x return nat with\r\n  | exist _ a _ => a\r\n  end\".\r\n *)\r\n```\r\nSurely, it must be a bug that Coq cannot find the solution `?n := id` here, \r\nright?\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337559472/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337559473","html_url":"https://github.com/coq/coq/issues/5788#issuecomment-337559473","issue_url":"https://api.github.com/repos/coq/coq/issues/5788","id":337559473,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU1OTQ3Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-10-17T13:39:08Z","updated_at":"2017-10-18T11:23:10Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\n(In reply to Jason Gross from comment [BZ#0](https://github.com/coq/coq/issues?q=is%3Aissue%20%22Original%20bug%20ID%3A%20BZ%230%22))\n> Definition foo x :=\n>   (fun (p1 : nat) (p2 : p1 = 2)\n>    => exist (fun a => a = 2) p1 p2) (proj1_sig x) (proj2_sig x).\n> (* Error: In environment\n> x : {x : nat | ?P x}\n> Unable to unify \"?P (proj1_sig x)\" with \"proj1_sig x = 2\".\n>  *)\n> \n> Is this in the pattern fragment?  It's true that ?P appears in <args>....\n\nLet me give an answer in several parts:\n\n1. This is not the pattern fragment. The pattern fragment is the higher-order fragment made of equations of the form \"?P x1 ... xn == u\" with the xi distinct variables and ?P expected to be instantiated by a closed term. Indeed, there is in this case a canonical solution ?P := λx1..xn.u up to βη-conversion.\n\n2. But it is correct that your examples have only one solution: \"?P := fun y => y=2\" (and \"?n := fun y => y\" in the second case). The pattern fragment could indeed be extended to equations of the form \"?P E1[x1] ... En[xn] == u\" with the xi distinct and the Ei evaluation contexts (so that each E[xi] is \"neutral\"). Indeed, if an xi occurs in u, the only hope that the equation is solvable is that each occurrence of xi in u occurs as part of the same configuration Ei[xi], so that it would be enough to look for matching expressions of the form Ei[xi] in u (with the cost of possible reductions needed to match an Ei[xi] with a another Ei[xi] in u).\n\nMore generally, there exist several extensions of the original pattern unification algorithm which produce canonical solutions when they exist (see e.g. the recent work by Tomer Libal and Dale Miller on \n\"Functions-as-Constructors Higher-Order Unification\"). Maybe your case actually enters one of these well-studied extensions.\n\n3. Current heuristics used for general problems of the form \"?P t1 ... tn == u\" (in which case there is a priori no canonical solution).\n\n3a. If t is a constructor, a matching is attempted in some cases [1], as in:\n\nCheck fun x (a : S x = 0) => exist (fun y => ?[P]) (S x) a.\n(* ?P@ {y} := y=0 *)\n\nNote that this is not canonical since e.g. \"?P@ {y} := match y with S x => S x | 0 => 42 end\" would also be a solution. If the case is considered it is because this is a configuration which is common in the inference of the return clause of a \"match\".\n\n3b. Note that the following variant does not work though [2]:\n\nCheck fun x (a : S x = 0) => exist ?[P] (S x) a.\n(* fails to solve ?P y == y=0 *)\n\n3c. In the context of tactics, such as rewrite or induction, a more powerful heuristic is used to resolve the general problems of the form \"?P t1 ... tn == u\" [3], but it is currently deactivated for type inference due to the incompatibilities it produces sometimes.\n\n\n[1] This is done by Evarsolve.solve_simple_eqn which uses heuristics to solve problems of the form ?P@ {x1:=u1;...;xn:=un} == u\n\n[2] Problems of the form \"?P t == u\" may fruitfully deserve being resolved using first-order heuristics (assume e.g. that u is \"?Q t\", so they are postponed. The canonical transformation of \"?P y == y=0\" into \"?P'@ {y} == y=0\" together with \"?P := fun y => ?P'@ {y:=y}\" could be not done when it is clear that a f.o. unification does not give anything, but this remains to be attempted, in this function Evarconv.consider_remaining_unif_problems which is devoted to apply heuristics when no other canonical information can be obtained from the rest of the whole sets of unification problems that a typing problem generates. \n\n[3] This is Evarconv.second_order_matching which Matthieu is using more intensively in the new evarconv-based rewrite and induction that he is going to provide as part of the unif-all branch.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337559473/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337559475","html_url":"https://github.com/coq/coq/issues/5788#issuecomment-337559475","issue_url":"https://api.github.com/repos/coq/coq/issues/5788","id":337559475,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU1OTQ3NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-10-17T14:28:15Z","updated_at":"2017-10-18T11:23:10Z","author_association":"CONTRIBUTOR","body":"Comment author: @herbelin\n\nNote: The recent example reported in BZ#5767 is partly related.\n\nIt is a situation with two unification problems:\n\n⊢ ?m == fun x : nat => True -> x = x\nn:nat ⊢ ?m' (n+1) == True -> n+1 = n+1\nn:nat ⊢ tele ?m == tele ?m'@ {n}\n\nThe first one is easy to solve, but the way type inference is coded, it is the second problem which is treated first. But the current heuristics discards the dependency in (n+1), sees only the dependency in n, and decide too early to instantiate ?m'@ {n} := True -> n+1 = n+1.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337559475/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]