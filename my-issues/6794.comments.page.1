[{"url":"https://api.github.com/repos/coq/coq/issues/comments/371124424","html_url":"https://github.com/coq/coq/issues/6794#issuecomment-371124424","issue_url":"https://api.github.com/repos/coq/coq/issues/6794","id":371124424,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MTEyNDQyNA==","user":{"login":"maximedenes","id":647105,"node_id":"MDQ6VXNlcjY0NzEwNQ==","avatar_url":"https://avatars.githubusercontent.com/u/647105?v=4","gravatar_id":"","url":"https://api.github.com/users/maximedenes","html_url":"https://github.com/maximedenes","followers_url":"https://api.github.com/users/maximedenes/followers","following_url":"https://api.github.com/users/maximedenes/following{/other_user}","gists_url":"https://api.github.com/users/maximedenes/gists{/gist_id}","starred_url":"https://api.github.com/users/maximedenes/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/maximedenes/subscriptions","organizations_url":"https://api.github.com/users/maximedenes/orgs","repos_url":"https://api.github.com/users/maximedenes/repos","events_url":"https://api.github.com/users/maximedenes/events{/privacy}","received_events_url":"https://api.github.com/users/maximedenes/received_events","type":"User","site_admin":false},"created_at":"2018-03-07T12:33:20Z","updated_at":"2018-03-07T12:33:20Z","author_association":"MEMBER","body":"IMHO we should use type classes for that.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/371124424/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/371158884","html_url":"https://github.com/coq/coq/issues/6794#issuecomment-371158884","issue_url":"https://api.github.com/repos/coq/coq/issues/6794","id":371158884,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MTE1ODg4NA==","user":{"login":"herbelin","id":460771,"node_id":"MDQ6VXNlcjQ2MDc3MQ==","avatar_url":"https://avatars.githubusercontent.com/u/460771?v=4","gravatar_id":"","url":"https://api.github.com/users/herbelin","html_url":"https://github.com/herbelin","followers_url":"https://api.github.com/users/herbelin/followers","following_url":"https://api.github.com/users/herbelin/following{/other_user}","gists_url":"https://api.github.com/users/herbelin/gists{/gist_id}","starred_url":"https://api.github.com/users/herbelin/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/herbelin/subscriptions","organizations_url":"https://api.github.com/users/herbelin/orgs","repos_url":"https://api.github.com/users/herbelin/repos","events_url":"https://api.github.com/users/herbelin/events{/privacy}","received_events_url":"https://api.github.com/users/herbelin/received_events","type":"User","site_admin":false},"created_at":"2018-03-07T14:39:46Z","updated_at":"2018-03-07T14:39:46Z","author_association":"MEMBER","body":"Can you give more details about how to implement this with type classes?\r\n\r\nIn particular, I keep falling again and again on the idea that schemes should come in a name space defined from the names of the block of inductive types and I wonder whether this would be compatible with a type class approach or whether it would be orthogonal approaches.\r\n\r\nIn any case, I'm convinced that the user API for schemes can and should be refined.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/371158884/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/371208721","html_url":"https://github.com/coq/coq/issues/6794#issuecomment-371208721","issue_url":"https://api.github.com/repos/coq/coq/issues/6794","id":371208721,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MTIwODcyMQ==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-03-07T17:05:20Z","updated_at":"2018-03-07T17:05:20Z","author_association":"MEMBER","body":"Here is one way to implement it with typeclasses:\r\n\r\nIn one of the early `Init` files, define classes\r\n```coq\r\nClass Decidable (P : Prop) := dec : {P} + {~P}.\r\nArguments dec _%type_scope {_}.\r\nNotation DecidableRel R := (forall x y, Decidable (R x y)).\r\n\r\nClass Beq (A : Type) := beq : A -> A -> bool.\r\nArguments beq {_ _} _ _.\r\nInfix \"=?\" := beq : bool_scope.\r\nClass Beq_lb A {_ : Beq A} := lb : forall x y : A, x = y -> beq x y = true.\r\nArguments lb {A _ _} [x y] _.\r\nClass Beq_bl A {_ : Beq A} := bl : forall x y : A, beq x y = true -> x = y.\r\nArguments bl {A _ _} [x y] _.\r\n\r\nGlobal Instance dec_of_beq A {BEQ : Beq A} {_ : @Beq_lb A BEQ} {_ : @Beq_bl A BEQ}\r\n : DecidableRel (@eq A)\r\n  := fun x y\r\n    => (if beq x y as b return beq x y = b -> _ with\r\n        then fun H => left (bl H)\r\n        else fun H => right (fun H' => (ltac:(discriminate) : beq x y = true -> beq x y = false -> False)\r\n                               H (lb H')))\r\n        eq_refl.\r\n```\r\n\r\nGiven these, scheme creation should register its lemmas as instances of these classes (and the hypotheses of parameterized schemes should take arguments of these typeclasses), and rather than looking in an internal scheme table for existing schemes, it should perform typeclass resolution to infer the necessary schemes.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/371208721/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/371210584","html_url":"https://github.com/coq/coq/issues/6794#issuecomment-371210584","issue_url":"https://api.github.com/repos/coq/coq/issues/6794","id":371210584,"node_id":"MDEyOklzc3VlQ29tbWVudDM3MTIxMDU4NA==","user":{"login":"JasonGross","id":396076,"node_id":"MDQ6VXNlcjM5NjA3Ng==","avatar_url":"https://avatars.githubusercontent.com/u/396076?v=4","gravatar_id":"","url":"https://api.github.com/users/JasonGross","html_url":"https://github.com/JasonGross","followers_url":"https://api.github.com/users/JasonGross/followers","following_url":"https://api.github.com/users/JasonGross/following{/other_user}","gists_url":"https://api.github.com/users/JasonGross/gists{/gist_id}","starred_url":"https://api.github.com/users/JasonGross/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/JasonGross/subscriptions","organizations_url":"https://api.github.com/users/JasonGross/orgs","repos_url":"https://api.github.com/users/JasonGross/repos","events_url":"https://api.github.com/users/JasonGross/events{/privacy}","received_events_url":"https://api.github.com/users/JasonGross/received_events","type":"User","site_admin":false},"created_at":"2018-03-07T17:11:05Z","updated_at":"2018-03-07T17:11:05Z","author_association":"MEMBER","body":"> I keep falling again and again on the idea that schemes should come in a name space defined from the names of the block of inductive types and I wonder whether this would be compatible with a type class approach or whether it would be orthogonal approaches\r\n\r\nThese seem both compatible and orthogonal.  In particular, both the TC approach and the \"special namespace\" approach provide `Scheme` a way to locate schemes (and it seems fine for it to try one of the ways and then fallback to the other way, before falling back to creating them from scratch), and this approach defines a way of \"registering\" the schemes without committing to any policy about the names of the underlying identifiers, while the \"special namespace\" approach specifies a policy for naming the underlying identifiers (which happens to have scheme registration as a side effect).\r\n\r\nSaid another way, it seems like either could be implemented without the other, or they could both be implemented and work simultaneously.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/371210584/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]