[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337532039","html_url":"https://github.com/coq/coq/issues/4089#issuecomment-337532039","issue_url":"https://api.github.com/repos/coq/coq/issues/4089","id":337532039,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMjAzOQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-02-24T03:48:01Z","updated_at":"2017-10-18T09:54:26Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-indices-matter\") -*- *)\n(* File reduced by coq-bug-finder from original input, then from 6522 lines to 318 lines, then from 1139 lines to 361 lines *)\n(* coqc version 8.5beta1 (February 2015) compiled on Feb 23 2015 18:32:3 with OCaml 4.01.0\n   coqtop version cagnode15:/afs/csail.mit.edu/u/j/jgross/coq-8.5,v8.5 (ebfc19d792492417b129063fb511aa423e9d9e08) *)\nOpen Scope type_scope.\n\nGlobal Set Universe Polymorphism.\nModule Export Datatypes.\n\nSet Implicit Arguments.\n\nRecord prod (A B : Type) := pair { fst : A ; snd : B }.\n\nNotation \"x * y\" := (prod x y) : type_scope.\nNotation \"( x , y , .. , z )\" := (pair .. (pair x y) .. z) : core_scope.\n\nEnd Datatypes.\nModule Export Specif.\n\nSet Implicit Arguments.\n\nRecord sig {A} (P : A -> Type) := exist { proj1_sig : A ; proj2_sig : P proj1_sig }.\n\nNotation sigT := sig (only parsing).\nNotation existT := exist (only parsing).\n\nNotation \"{ x : A  & P }\" := (sigT (fun x:A => P)) : type_scope.\n\nNotation projT1 := proj1_sig (only parsing).\nNotation projT2 := proj2_sig (only parsing).\n\nEnd Specif.\n\nLtac rapply p :=\n  refine (p _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _ _ _ _ _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _ _ _ _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _ _ _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _ _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _ _) ||\n  refine (p _ _ _ _ _) ||\n  refine (p _ _ _ _) ||\n  refine (p _ _ _) ||\n  refine (p _ _) ||\n  refine (p _) ||\n  refine p.\n\nLocal Unset Elimination Schemes.\n\nDefinition relation (A : Type) := A -> A -> Type.\n\nClass Symmetric {A} (R : relation A) :=\n  symmetry : forall x y, R x y -> R y x.\n\nClass Transitive {A} (R : relation A) :=\n  transitivity : forall x y z, R x y -> R y z -> R x z.\n\nTactic Notation \"etransitivity\" open_constr(y) :=\n  let R := match goal with |- ?R ?x ?z => constr:(R) end in\n  let x := match goal with |- ?R ?x ?z => constr:(x) end in\n  let z := match goal with |- ?R ?x ?z => constr:(z) end in\n  let pre_proof_term_head := constr:(@ transitivity _ R _) in\n  let proof_term_head := (eval cbn in pre_proof_term_head) in\n  refine (proof_term_head x y z _ _); [ change (R x y) | change (R y z) ].\n\nLtac transitivity x := etransitivity x.\n\nDefinition Type1 := Eval hnf in let gt := (Set : Type@ {i}) in Type@ {i}.\n\nNotation idmap := (fun x => x).\nDelimit Scope function_scope with function.\nDelimit Scope path_scope with path.\nDelimit Scope fibration_scope with fibration.\nOpen Scope fibration_scope.\nOpen Scope function_scope.\n\nNotation \"( x ; y )\" := (existT _ x y) : fibration_scope.\n\nNotation pr1 := projT1.\nNotation pr2 := projT2.\n\nNotation \"x .1\" := (pr1 x) (at level 3, format \"x '.1'\") : fibration_scope.\nNotation \"x .2\" := (pr2 x) (at level 3, format \"x '.2'\") : fibration_scope.\n\nNotation compose := (fun g f x => g (f x)).\n\nNotation \"g 'o' f\" := (compose g%function f%function) (at level 40, left associativity) : function_scope.\n\nInductive paths {A : Type} (a : A) : A -> Type :=\n  idpath : paths a a.\n\nArguments idpath {A a} , [A] a.\n\nScheme paths_ind := Induction for paths Sort Type.\n\nDefinition paths_rect := paths_ind.\n\nNotation \"x = y :> A\" := (@ paths A x y) : type_scope.\nNotation \"x = y\" := (x = y :>_) : type_scope.\n\nLocal Open Scope path_scope.\n\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x\n  := match p with idpath => idpath end.\n\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z :=\n  match p, q with idpath, idpath => idpath end.\n\nArguments concat {A x y z} p q : simpl nomatch.\n\nNotation \"1\" := idpath : path_scope.\n\nNotation \"p @  q\" := (concat p%path q%path) (at level 20) : path_scope.\n\nNotation \"p ^\" := (inverse p%path) (at level 3, format \"p '^'\") : path_scope.\n\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y :=\n  match p with idpath => u end.\n\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y\n  := match p with idpath => idpath end.\n\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x)\n  := forall x:A, f x = g x.\n\nNotation \"f == g\" := (pointwise_paths f g) (at level 70, no associativity) : type_scope.\n\nDefinition apD10 {A} {B:A->Type} {f g : forall x, B x} (h:f=g)\n  : f == g\n  := fun x => match h with idpath => 1 end.\n\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) :=\n  forall x : A, r (s x) = x.\n\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv {\n  equiv_inv : B -> A ;\n  eisretr : Sect equiv_inv f;\n  eissect : Sect f equiv_inv;\n  eisadj : forall x : A, eisretr (f x) = ap f (eissect x)\n}.\n\nArguments eisretr {A B}%type_scope f%function_scope {_} _.\nArguments eissect {A B}%type_scope f%function_scope {_} _.\nArguments eisadj {A B}%type_scope f%function_scope {_} _.\n\nRecord Equiv A B := BuildEquiv {\n  equiv_fun : A -> B ;\n  equiv_isequiv : IsEquiv equiv_fun\n}.\n\nCoercion equiv_fun : Equiv >-> Funclass.\n\nGlobal Existing Instance equiv_isequiv.\n\nBind Scope equiv_scope with Equiv.\n\nNotation \"A <~> B\" := (Equiv A B) (at level 85) : type_scope.\n\nNotation \"f ^-1\" := (@ equiv_inv _ _ f _) (at level 3, format \"f '^-1'\") : function_scope.\n\nInductive Unit : Type1 :=\n    tt : Unit.\n\nLtac done :=\n  trivial; intros; solve\n    [ repeat first\n      [ solve [trivial]\n      | solve [symmetry; trivial]\n      | reflexivity\n\n      | contradiction\n      | split ]\n    | match goal with\n      H : ~ _ |- _ => solve [destruct H; trivial]\n      end ].\nTactic Notation \"by\" tactic(tac) :=\n  tac; done.\n\nDefinition concat_p1 {A : Type} {x y : A} (p : x = y) :\n  p @  1 = p\n  :=\n  match p with idpath => 1 end.\n\nDefinition concat_1p {A : Type} {x y : A} (p : x = y) :\n  1 @  p = p\n  :=\n  match p with idpath => 1 end.\n\nDefinition ap_pp {A B : Type} (f : A -> B) {x y z : A} (p : x = y) (q : y = z) :\n  ap f (p @  q) = (ap f p) @  (ap f q)\n  :=\n  match q with\n    idpath =>\n    match p with idpath => 1 end\n  end.\n\nDefinition ap_compose {A B C : Type} (f : A -> B) (g : B -> C) {x y : A} (p : x = y) :\n  ap (g o f) p = ap g (ap f p)\n  :=\n  match p with idpath => 1 end.\n\nDefinition concat_A1p {A : Type} {f : A -> A} (p : forall x, f x = x) {x y : A} (q : x = y) :\n  (ap f q) @  (p y) = (p x) @  q\n  :=\n  match q with\n    | idpath => concat_1p _ @  ((concat_p1 _) ^)\n  end.\n\nDefinition concat2 {A} {x y z : A} {p p' : x = y} {q q' : y = z} (h : p = p') (h' : q = q')\n  : p @  q = p' @  q'\n:= match h, h' with idpath, idpath => 1 end.\n\nNotation \"p @ @  q\" := (concat2 p q)%path (at level 20) : path_scope.\n\nDefinition whiskerL {A : Type} {x y z : A} (p : x = y)\n  {q r : y = z} (h : q = r) : p @  q = p @  r\n:= 1 @ @  h.\n\nDefinition ap02 {A B : Type} (f:A->B) {x y:A} {p q:x=y} (r:p=q) : ap f p = ap f q\n  := match r with idpath => 1 end.\nModule Export Equivalences.\n\nGeneralizable Variables A B C f g.\n\nGlobal Instance isequiv_idmap (A : Type) : IsEquiv idmap | 0 :=\n  BuildIsEquiv A A idmap idmap (fun _ => 1) (fun _ => 1) (fun _ => 1).\n\nDefinition equiv_idmap (A : Type) : A <~> A := BuildEquiv A A idmap _.\n\nArguments equiv_idmap {A} , A.\n\nNotation \"1\" := equiv_idmap : equiv_scope.\n\nGlobal Instance isequiv_compose `{IsEquiv A B f} `{IsEquiv B C g}\n  : IsEquiv (compose g f) | 1000\n  := BuildIsEquiv A C (compose g f)\n    (compose f^-1 g^-1)\n    (fun c => ap g (eisretr f (g^-1 c)) @  eisretr g c)\n    (fun a => ap (f^-1) (eissect g (f a)) @  eissect f a)\n    (fun a =>\n      (whiskerL _ (eisadj g (f a))) @ \n      (ap_pp g _ _)^ @ \n      ap02 g\n      ( (concat_A1p (eisretr f) (eissect g (f a)))^ @ \n        (ap_compose f^-1 f _ @ @  eisadj f a) @ \n        (ap_pp f _ _)^\n      ) @ \n      (ap_compose f g _)^\n    ).\n\nDefinition equiv_compose {A B C : Type} (g : B -> C) (f : A -> B)\n  `{IsEquiv B C g} `{IsEquiv A B f}\n  : A <~> C\n  := BuildEquiv A C (compose g f) _.\n\nGlobal Instance transitive_equiv : Transitive Equiv | 0 :=\n  fun _ _ _ f g => equiv_compose g f.\n\nTheorem equiv_inverse {A B : Type} : (A <~> B) -> (B <~> A).\nadmit.\nDefined.\n\nGlobal Instance symmetric_equiv : Symmetric Equiv | 0 := @ equiv_inverse.\n\nEnd Equivalences.\n\nDefinition path_prod_uncurried {A B : Type} (z z' : A * B)\n  (pq : (fst z = fst z') * (snd z = snd z'))\n  : (z = z').\nadmit.\nDefined.\n\nGlobal Instance isequiv_path_prod {A B : Type} {z z' : A * B}\n: IsEquiv (path_prod_uncurried z z') | 0.\nadmit.\nDefined.\n\nDefinition equiv_path_prod {A B : Type} (z z' : A * B)\n  : (fst z = fst z') * (snd z = snd z')  <~>  (z = z')\n  := BuildEquiv _ _ (path_prod_uncurried z z') _.\n\nGeneralizable Variables X A B C f g n.\n\nDefinition functor_sigma `{P : A -> Type} `{Q : B -> Type}\n           (f : A -> B) (g : forall a, P a -> Q (f a))\n: sigT P -> sigT Q\n  := fun u => (f u.1 ; g u.1 u.2).\n\nGlobal Instance isequiv_functor_sigma `{P : A -> Type} `{Q : B -> Type}\n         `{IsEquiv A B f} `{forall a, @ IsEquiv (P a) (Q (f a)) (g a)}\n: IsEquiv (functor_sigma f g) | 1000.\nadmit.\nDefined.\n\nDefinition equiv_functor_sigma `{P : A -> Type} `{Q : B -> Type}\n           (f : A -> B) `{IsEquiv A B f}\n           (g : forall a, P a -> Q (f a))\n           `{forall a, @ IsEquiv (P a) (Q (f a)) (g a)}\n: sigT P <~> sigT Q\n  := BuildEquiv _ _ (functor_sigma f g) _.\n\nDefinition equiv_functor_sigma' `{P : A -> Type} `{Q : B -> Type}\n           (f : A <~> B)\n           (g : forall a, P a <~> Q (f a))\n: sigT P <~> sigT Q\n  := equiv_functor_sigma f g.\n\nDefinition equiv_functor_sigma_id `{P : A -> Type} `{Q : A -> Type}\n           (g : forall a, P a <~> Q a)\n: sigT P <~> sigT Q\n  := equiv_functor_sigma' 1 g.\n\nDefinition Bip : Type := { C : Type &  C * C }.\n\nDefinition BipMor (X Y : Bip) : Type :=\n  match X, Y with (C;(c0,c1)), (D;(d0,d1)) =>\n    { f : C -> D & (f c0 = d0) * (f c1 = d1) }\n  end.\n\nDefinition bipmor2map {X Y : Bip} : BipMor X Y -> X.1 -> Y.1 :=\n  match X, Y with (C;(c0,c1)), (D;(d0,d1)) => fun i =>\n    match i with (f;_) => f end\n  end.\n\nDefinition bipidmor {X : Bip} : BipMor X X :=\n  match X with (C;(c0,c1)) => (idmap; (1, 1)) end.\n\nDefinition bipcompmor {X Y Z : Bip} : BipMor X Y -> BipMor Y Z -> BipMor X Z :=\n  match X, Y, Z with (C;(c0,c1)), (D;(d0,d1)), (E;(e0,e1)) => fun i j =>\n    match i, j with (f;(f0,f1)), (g;(g0,g1)) =>\n      (g o f; (ap g f0 @  g0, ap g f1 @  g1))\n    end\n  end.\n\nDefinition isbipequiv {X Y : Bip} (i : BipMor X Y) : Type :=\n  { l : BipMor Y X & bipcompmor i l = bipidmor } *\n  { r : BipMor Y X & bipcompmor r i = bipidmor }.\n\nLemma bipequivEQequiv : forall {X Y : Bip} (i : BipMor X Y),\n  isbipequiv i <~> IsEquiv (bipmor2map i).\nProof.\nassert (equivcompmor : forall {X Y : Bip} (i : BipMor X Y) j,\n(bipcompmor i j = bipidmor) <~> Unit).\n  intros; set (U := X); set (V := Y); destruct X as [C [c0 c1]], Y as [D [d0 d1]].\n  transitivity { n : (bipcompmor i j).1 = (@ bipidmor U).1 &\n  (bipcompmor i j).2 = transport (fun h => (h c0 = c0) * (h c1 = c1)) n^ (@ bipidmor U).2}.\n    admit.\n  destruct i as [f [f0 f1]]; destruct j as [g [g0 g1]].\n\n  transitivity { n : g o f = idmap & (ap g f0 @  g0 = apD10 n c0 @  1) *\n  (ap g f1 @  g1 = apD10 n c1 @  1)}.\n    apply equiv_functor_sigma_id; intro n.\n    assert (Ggen : forall (h0 h1 : C -> C) (p : h0 = h1) u0 u1 v0 v1,\n    ((u0, u1) = transport (fun h => (h c0 = c0) * (h c1 = c1)) p^ (v0, v1)) <~>\n    (u0 = apD10 p c0 @  v0) * (u1 = apD10 p c1 @  v1)).\n      induction p; intros; simpl; rewrite !concat_1p; apply symmetry.\n      by apply (equiv_path_prod (u0,u1) (v0,v1)).\n    rapply Ggen.\n    pose (@ paths C).\n    Check (@ paths C).\n    Undo.\n    Check (@ paths C). (* Toplevel input, characters 0-17:\nError: Illegal application:\nThe term \"@ paths\" of type \"forall A : Type, A -> A -> Type\"\ncannot be applied to the term\n \"C\" : \"Type\"\nThis term has type \"Type@ {Top.892}\" which should be coercible to\n \"Type@ {Top.882}\".\n*)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337532039/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337532041","html_url":"https://github.com/coq/coq/issues/4089#issuecomment-337532041","issue_url":"https://api.github.com/repos/coq/coq/issues/4089","id":337532041,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzMjA0MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-02-24T10:44:14Z","updated_at":"2017-10-18T09:54:27Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nIndeed that was strange, it was due to a wrong handling of the environment in Check.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337532041/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]