[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337539345","html_url":"https://github.com/coq/coq/issues/4525#issuecomment-337539345","issue_url":"https://api.github.com/repos/coq/coq/issues/4525","id":337539345,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUzOTM0NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-01-24T06:19:22Z","updated_at":"2017-10-18T14:50:41Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n```coq\r\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-nois\" \"-indices-matter\") -*- *)\r\n(* File reduced by coq-bug-finder from original input, then from 953 lines to \r\n170 lines, then from 184 lines to 170 lines, then from 705 lines to 214 lines, \r\nthen from 228 lines to 214 lines *)\r\n(* coqc version 8.5 (January 2016) compiled on Jan 23 2016 16:15:22 with OCaml \r\n4.01.0\r\n   coqtop version 8.5 (January 2016) *)\r\nInductive False := .\r\nAxiom proof_admitted : False.\r\nTactic Notation \"admit\" := case proof_admitted.\r\nRequire Coq.Init.Datatypes.\r\nImport Coq.Init.Notations.\r\nGlobal Set Universe Polymorphism.\r\nNotation \"A -> B\" := (forall (_ : A), B) : type_scope.\r\nModule Export Datatypes.\r\n  Set Implicit Arguments.\r\n  Inductive sum (A B : Type) : Type := inl (a : A) | inr (b : B).\r\n  Notation nat := Coq.Init.Datatypes.nat.\r\n  Notation S := Coq.Init.Datatypes.S.\r\n  Notation \"x + y\" := (sum x y) : type_scope.\r\n  Arguments inl {A B} _ , [A] B _.\r\n  Arguments inr {A B} _ , A [B] _.\r\n  Record prod (A B : Type) := pair { fst : A ; snd : B }.\r\n  Notation \"x * y\" := (prod x y) : type_scope.\r\n  Delimit Scope nat_scope with nat.\r\n  Open Scope nat_scope.\r\nEnd Datatypes.\r\nModule Export Specif.\r\n  Set Implicit Arguments.\r\n  Record sig {A} (P : A -> Type) := exist { proj1_sig : A ; proj2_sig : P \r\nproj1_sig }.\r\n  Notation sigT := sig (only parsing).\r\n  Notation \"{ x : A  & P }\" := (sigT (fun x:A => P)) : type_scope.\r\n  Notation projT1 := proj1_sig (only parsing).\r\nEnd Specif.\r\nDefinition Type1@{i} := Eval hnf in let gt := (Set : Type@{i}) in Type@{i}.\r\nDefinition Type2@{i j} := Eval hnf in let gt := (Type1@{j} : Type@{i}) in \r\nType@{i}.\r\nDefinition Type2le@{i j} := Eval hnf in let gt := (Set : Type@{i}) in\r\n                                        let ge := ((fun x => x) : Type1@{j} -> \r\nType@{i}) in Type@{i}.\r\nDelimit Scope function_scope with function.\r\nDelimit Scope path_scope with path.\r\nDelimit Scope fibration_scope with fibration.\r\nOpen Scope path_scope.\r\nOpen Scope fibration_scope.\r\nOpen Scope function_scope.\r\nNotation pr1 := projT1.\r\nNotation \"x .1\" := (pr1 x) (at level 3, format \"x '.1'\") : fibration_scope.\r\nNotation compose := (fun g f x => g (f x)).\r\nNotation \"g 'o' f\" := (compose g%function f%function) (at level 40, left \r\nassociativity) : function_scope.\r\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\r\nArguments idpath {A a} , [A] a.\r\nNotation \"x = y :> A\" := (@paths A x y) : type_scope.\r\nNotation \"x = y\" := (x = y :>_) : type_scope.\r\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x\r\n  := match p with idpath => idpath end.\r\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z :=\r\n  match p, q with idpath, idpath => idpath end.\r\nNotation \"p @ q\" := (concat p%path q%path) (at level 20) : path_scope.\r\nNotation \"p ^\" := (inverse p%path) (at level 3, format \"p '^'\") : path_scope.\r\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y\r\n  := match p with idpath => idpath end.\r\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) :=\r\n  forall x : A, r (s x) = x.\r\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv {\r\n                                               equiv_inv : B -> A ;\r\n                                               eisretr : Sect equiv_inv f;\r\n                                               eissect : Sect f equiv_inv;\r\n                                               eisadj : forall x : A, eisretr \r\n(f x) = ap f (eissect x)\r\n                                             }.\r\nRecord Equiv A B := BuildEquiv {\r\n                        equiv_fun : A -> B ;\r\n                        equiv_isequiv : IsEquiv equiv_fun\r\n                      }.\r\nNotation \"A <~> B\" := (Equiv A B) (at level 85) : type_scope.\r\nInductive Unit : Type1 := tt : Unit.\r\nSection Adjointify.\r\n  Context {A B : Type} (f : A -> B) (g : B -> A).\r\n  Context (isretr : Sect g f) (issect : Sect f g).\r\n  Let issect' := fun x =>\r\n                   ap g (ap f (issect x)^)  @  ap g (isretr (f x))  @  issect x.\r\n  Let is_adjoint' (a : A) : isretr (f a) = ap f (issect' a).\r\n    admit.\r\n  Defined.\r\n  Definition isequiv_adjointify : IsEquiv f\r\n    := BuildIsEquiv A B f g isretr issect' is_adjoint'.\r\n  Definition equiv_adjointify : A <~> B\r\n    := BuildEquiv A B f isequiv_adjointify.\r\nEnd Adjointify.\r\nSection FunctorSum.\r\n  Context {A A' B B' : Type} (f : A -> A') (g : B -> B').\r\n  Definition functor_sum : A + B -> A' + B'\r\n    := fun z => match z with inl z' => inl (f z') | inr z' => inr (g z') end.\r\nEnd FunctorSum.\r\nDefinition ExtensionAlong {A B : Type} (f : A -> B)\r\n           (P : B -> Type) (d : forall x:A, P (f x))\r\n  := { s : forall y:B, P y & forall x:A, s (f x) = d x }.\r\nFixpoint ExtendableAlong@{i j k l}\r\n         (n : nat) {A : Type@{i}} {B : Type@{j}}\r\n         (f : A -> B) (C : B -> Type@{k}) : Type@{l}\r\n  := match n with\r\n     | 0 => Unit@{l}\r\n     | S n => (forall (g : forall a, C (f a)),\r\n                  ExtensionAlong@{i j k l l} f C g) *\r\n              forall (h k : forall b, C b),\r\n                ExtendableAlong n f (fun b => h b = k b)\r\n     end.\r\nDefinition ooExtendableAlong@{i j k l}\r\n           {A : Type@{i}} {B : Type@{j}}\r\n           (f : A -> B) (C : B -> Type@{k}) : Type@{l}\r\n  := forall n, ExtendableAlong@{i j k l} n f C.\r\nModule Type ReflectiveSubuniverses.\r\n  Parameter ReflectiveSubuniverse@{u a} : Type2@{u a}.\r\n  Parameter O_reflector@{u a i} : forall (O : ReflectiveSubuniverse@{u a}),\r\n      Type2le@{i a} -> Type2le@{i a}.\r\n  Parameter In@{u a i} : forall (O : ReflectiveSubuniverse@{u a}),\r\n      Type2le@{i a} -> Type2le@{i a}.\r\n  Parameter O_inO@{u a i} : forall (O : ReflectiveSubuniverse@{u a}) (T : \r\nType@{i}),\r\n      In@{u a i} O (O_reflector@{u a i} O T).\r\n  Parameter to@{u a i} : forall (O : ReflectiveSubuniverse@{u a}) (T : \r\nType@{i}),\r\n      T -> O_reflector@{u a i} O T.\r\n  Parameter extendable_to_O@{u a i j k}\r\n    : forall (O : ReflectiveSubuniverse@{u a}) {P : Type2le@{i a}} {Q : \r\nType2le@{j a}} {Q_inO : In@{u a j} O Q},\r\n      ooExtendableAlong@{i i j k} (to O P) (fun _ => Q).\r\nEnd ReflectiveSubuniverses.\r\nModule ReflectiveSubuniverses_Theory (Os : ReflectiveSubuniverses).\r\n  Export Os.\r\n  Existing Class In.\r\n  Coercion O_reflector : ReflectiveSubuniverse >-> Funclass.\r\n  Global Existing Instance O_inO.\r\n  Section ORecursion.\r\n    Context {O : ReflectiveSubuniverse}.\r\n    Definition O_rec {P Q : Type} {Q_inO : In O Q}\r\n               (f : P -> Q)\r\n      : O P -> Q\r\n      := (fst (extendable_to_O O 1%nat) f).1.\r\n  End ORecursion.\r\n  Section Reflective_Subuniverse.\r\n    Universes Ou Oa.\r\n    Context (O : ReflectiveSubuniverse@{Ou Oa}).\r\n    Definition equiv_O_sum {A B} :\r\n      O (A + B) <~> O (O A + O B).\r\n    Proof.\r\n      simple refine (equiv_adjointify _ _ _ _).\r\n      - apply O_rec; intros x.\r\n        exact (to O _ (functor_sum (to O A) (to O B) x)).\r\n      - apply O_rec; intros [x|x].\r\n        + Timeout 1 exact (O_rec (to O _ o inl) x). (* Stack overflow *)\r\n```\r\n\r\n\r\nPassing -debug gives:\r\n```\r\nsh: 1: dot: not found\r\nmaster:0] STM: 62: proof : synch (cause: non opaque)\r\nFile \"./foo.v\", line 143, characters 10-51:\r\nStack overflow.\r\nframe @ file \"toplevel/coqtop.ml\", line 620, characters 6-22\r\nframe @ file \"toplevel/vernac.ml\", line 352, characters 2-13\r\nframe @ file \"toplevel/vernac.ml\", line 320, characters 14-48\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"lib/flags.ml\", line 139, characters 19-41\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"lib/flags.ml\", line 11, characters 15-18\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"toplevel/vernac.ml\", line 253, characters 6-43\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"toplevel/vernac.ml\", line 233, characters 6-16\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 2473, characters 8-30\r\nframe @ file \"stm/stm.ml\", line 1973, characters 2-35\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 1963, characters 4-48\r\nframe @ file \"stm/stm.ml\", line 1930, characters 4-91\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"lib/flags.ml\", line 139, characters 19-41\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"lib/flags.ml\", line 11, characters 15-18\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"toplevel/vernac.ml\", line 253, characters 6-43\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"toplevel/vernac.ml\", line 233, characters 6-16\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 2473, characters 8-30\r\nframe @ file \"stm/stm.ml\", line 1973, characters 2-35\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 1963, characters 4-48\r\nframe @ file \"stm/stm.ml\", line 1930, characters 4-91\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"lib/flags.ml\", line 11, characters 15-18\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"toplevel/vernac.ml\", line 253, characters 6-43\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"toplevel/vernac.ml\", line 233, characters 6-16\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 2473, characters 8-30\r\nframe @ file \"stm/stm.ml\", line 1973, characters 2-35\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 1963, characters 4-48\r\nframe @ file \"stm/stm.ml\", line 1930, characters 4-91\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"toplevel/vernac.ml\", line 253, characters 6-43\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"toplevel/vernac.ml\", line 233, characters 6-16\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 2473, characters 8-30\r\nframe @ file \"stm/stm.ml\", line 1973, characters 2-35\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 1963, characters 4-48\r\nframe @ file \"stm/stm.ml\", line 1930, characters 4-91\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"toplevel/vernac.ml\", line 233, characters 6-16\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 2473, characters 8-30\r\nframe @ file \"stm/stm.ml\", line 1973, characters 2-35\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 1963, characters 4-48\r\nframe @ file \"stm/stm.ml\", line 1930, characters 4-91\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 2473, characters 8-30\r\nframe @ file \"stm/stm.ml\", line 1973, characters 2-35\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 1963, characters 4-48\r\nframe @ file \"stm/stm.ml\", line 1930, characters 4-91\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"stm/stm.ml\", line 1930, characters 4-91\r\nraise @ file \"lib/exninfo.ml\", line 63, characters 8-15\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\n... (many pages of this) ...\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"array.ml\", line 72, characters 31-48\r\nframe @ file \"pretyping/evarsolve.ml\", line 214, characters 13-36\r\nraise @ unknown\r\nraise @ unknown\r\n```\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337539345/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337617548","html_url":"https://github.com/coq/coq/issues/4525#issuecomment-337617548","issue_url":"https://api.github.com/repos/coq/coq/issues/4525","id":337617548,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzYxNzU0OA==","user":{"login":"ejgallego","id":7192257,"node_id":"MDQ6VXNlcjcxOTIyNTc=","avatar_url":"https://avatars.githubusercontent.com/u/7192257?v=4","gravatar_id":"","url":"https://api.github.com/users/ejgallego","html_url":"https://github.com/ejgallego","followers_url":"https://api.github.com/users/ejgallego/followers","following_url":"https://api.github.com/users/ejgallego/following{/other_user}","gists_url":"https://api.github.com/users/ejgallego/gists{/gist_id}","starred_url":"https://api.github.com/users/ejgallego/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ejgallego/subscriptions","organizations_url":"https://api.github.com/users/ejgallego/orgs","repos_url":"https://api.github.com/users/ejgallego/repos","events_url":"https://api.github.com/users/ejgallego/events{/privacy}","received_events_url":"https://api.github.com/users/ejgallego/received_events","type":"User","site_admin":false},"created_at":"2017-10-18T14:50:54Z","updated_at":"2017-10-18T14:50:54Z","author_association":"MEMBER","body":"Example doesn't work anymore in `master`.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337617548/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/388589592","html_url":"https://github.com/coq/coq/issues/4525#issuecomment-388589592","issue_url":"https://api.github.com/repos/coq/coq/issues/4525","id":388589592,"node_id":"MDEyOklzc3VlQ29tbWVudDM4ODU4OTU5Mg==","user":{"login":"SkySkimmer","id":2461932,"node_id":"MDQ6VXNlcjI0NjE5MzI=","avatar_url":"https://avatars.githubusercontent.com/u/2461932?v=4","gravatar_id":"","url":"https://api.github.com/users/SkySkimmer","html_url":"https://github.com/SkySkimmer","followers_url":"https://api.github.com/users/SkySkimmer/followers","following_url":"https://api.github.com/users/SkySkimmer/following{/other_user}","gists_url":"https://api.github.com/users/SkySkimmer/gists{/gist_id}","starred_url":"https://api.github.com/users/SkySkimmer/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/SkySkimmer/subscriptions","organizations_url":"https://api.github.com/users/SkySkimmer/orgs","repos_url":"https://api.github.com/users/SkySkimmer/repos","events_url":"https://api.github.com/users/SkySkimmer/events{/privacy}","received_events_url":"https://api.github.com/users/SkySkimmer/received_events","type":"User","site_admin":false},"created_at":"2018-05-12T23:10:53Z","updated_at":"2018-05-12T23:10:53Z","author_association":"CONTRIBUTOR","body":"Fixed version:\r\n```coq\r\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-indices-matter\") -*- *)\r\n(* File reduced by coq-bug-finder from original input, then from 953 lines to\r\n170 lines, then from 184 lines to 170 lines, then from 705 lines to 214 lines,\r\nthen from 228 lines to 214 lines *)\r\n(* coqc version 8.5 (January 2016) compiled on Jan 23 2016 16:15:22 with OCaml\r\n4.01.0\r\n   coqtop version 8.5 (January 2016) *)\r\nInductive False := .\r\nAxiom proof_admitted : False.\r\n\r\nLtac admit := case proof_admitted.\r\nRequire Coq.Init.Datatypes.\r\nImport Coq.Init.Notations.\r\nGlobal Set Universe Polymorphism.\r\nNotation \"A -> B\" := (forall (_ : A), B) : type_scope.\r\nModule Export Datatypes.\r\n  Set Implicit Arguments.\r\n  Inductive sum (A B : Type) : Type := inl (a : A) | inr (b : B).\r\n  Notation nat := Coq.Init.Datatypes.nat.\r\n  Notation S := Coq.Init.Datatypes.S.\r\n  Notation \"x + y\" := (sum x y) : type_scope.\r\n  Arguments inl {A B} _ , [A] B _.\r\n  Arguments inr {A B} _ , A [B] _.\r\n  Record prod (A B : Type) := pair { fst : A ; snd : B }.\r\n  Notation \"x * y\" := (prod x y) : type_scope.\r\n  Delimit Scope nat_scope with nat.\r\n  Open Scope nat_scope.\r\nEnd Datatypes.\r\nModule Export Specif.\r\n  Set Implicit Arguments.\r\n  Record sig {A} (P : A -> Type) := exist { proj1_sig : A ; proj2_sig : P\r\nproj1_sig }.\r\n  Notation sigT := sig (only parsing).\r\n  Notation \"{ x : A  & P }\" := (sigT (fun x:A => P)) : type_scope.\r\n  Notation projT1 := proj1_sig (only parsing).\r\nEnd Specif.\r\nDefinition Type1@{i} := Eval hnf in let gt := (Set : Type@{i}) in Type@{i}.\r\nDefinition Type2@{i j} := Eval hnf in let gt := (Type1@{j} : Type@{i}) in\r\nType@{i}.\r\nDefinition Type2le@{i j} := Eval hnf in let gt := (Set : Type@{i}) in\r\n                                        let ge := ((fun x => x) : Type1@{j} ->\r\nType@{i}) in Type@{i}.\r\nDelimit Scope function_scope with function.\r\nDelimit Scope path_scope with path.\r\nDelimit Scope fibration_scope with fibration.\r\nOpen Scope path_scope.\r\nOpen Scope fibration_scope.\r\nOpen Scope function_scope.\r\nNotation pr1 := projT1.\r\nNotation \"x .1\" := (pr1 x) (at level 3, format \"x '.1'\") : fibration_scope.\r\nNotation compose := (fun g f x => g (f x)).\r\nNotation \"g 'o' f\" := (compose g%function f%function) (at level 40, left\r\nassociativity) : function_scope.\r\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\r\nArguments idpath {A a} , [A] a.\r\nNotation \"x = y :> A\" := (@paths A x y) : type_scope.\r\nNotation \"x = y\" := (x = y :>_) : type_scope.\r\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x\r\n  := match p with idpath => idpath end.\r\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z :=\r\n  match p, q with idpath, idpath => idpath end.\r\nNotation \"p @ q\" := (concat p%path q%path) (at level 20) : path_scope.\r\nNotation \"p ^\" := (inverse p%path) (at level 3, format \"p '^'\") : path_scope.\r\nDefinition ap {A B:Type} (f:A -> B) {x y:A} (p:x = y) : f x = f y\r\n  := match p with idpath => idpath end.\r\nDefinition Sect {A B : Type} (s : A -> B) (r : B -> A) :=\r\n  forall x : A, r (s x) = x.\r\nClass IsEquiv {A B : Type} (f : A -> B) := BuildIsEquiv {\r\n                                               equiv_inv : B -> A ;\r\n                                               eisretr : Sect equiv_inv f;\r\n                                               eissect : Sect f equiv_inv;\r\n                                               eisadj : forall x : A, eisretr\r\n(f x) = ap f (eissect x)\r\n                                             }.\r\nRecord Equiv A B := BuildEquiv {\r\n                        equiv_fun : A -> B ;\r\n                        equiv_isequiv : IsEquiv equiv_fun\r\n                      }.\r\nNotation \"A <~> B\" := (Equiv A B) (at level 85) : type_scope.\r\nInductive Unit : Type1 := tt : Unit.\r\nSection Adjointify.\r\n  Context {A B : Type} (f : A -> B) (g : B -> A).\r\n  Context (isretr : Sect g f) (issect : Sect f g).\r\n  Let issect' := fun x =>\r\n                   ap g (ap f (issect x)^)  @  ap g (isretr (f x))  @  issect x.\r\n  Let is_adjoint' (a : A) : isretr (f a) = ap f (issect' a).\r\n    admit.\r\n  Admitted.\r\n  Definition isequiv_adjointify : IsEquiv f\r\n    := BuildIsEquiv A B f g isretr issect' is_adjoint'.\r\n  Definition equiv_adjointify : A <~> B\r\n    := BuildEquiv A B f isequiv_adjointify.\r\nEnd Adjointify.\r\nSection FunctorSum.\r\n  Context {A A' B B' : Type} (f : A -> A') (g : B -> B').\r\n  Definition functor_sum : A + B -> A' + B'\r\n    := fun z => match z with inl z' => inl (f z') | inr z' => inr (g z') end.\r\nEnd FunctorSum.\r\nDefinition ExtensionAlong {A B : Type} (f : A -> B)\r\n           (P : B -> Type) (d : forall x:A, P (f x))\r\n  := { s : forall y:B, P y & forall x:A, s (f x) = d x }.\r\nFixpoint ExtendableAlong@{i j k l}\r\n         (n : nat) {A : Type@{i}} {B : Type@{j}}\r\n         (f : A -> B) (C : B -> Type@{k}) : Type@{l}\r\n  := match n with\r\n     | 0 => Unit@{l}\r\n     | S n => (forall (g : forall a, C (f a)),\r\n                  ExtensionAlong@{i j k l l} f C g) *\r\n              forall (h k : forall b, C b),\r\n                ExtendableAlong n f (fun b => h b = k b)\r\n     end.\r\nDefinition ooExtendableAlong@{i j k l}\r\n           {A : Type@{i}} {B : Type@{j}}\r\n           (f : A -> B) (C : B -> Type@{k}) : Type@{l}\r\n  := forall n, ExtendableAlong@{i j k l} n f C.\r\nModule Type ReflectiveSubuniverses.\r\n  Parameter ReflectiveSubuniverse@{u a} : Type2@{u a}.\r\n  Parameter O_reflector@{u a i} : forall (O : ReflectiveSubuniverse@{u a}),\r\n      Type2le@{i a} -> Type2le@{i a}.\r\n  Parameter In@{u a i} : forall (O : ReflectiveSubuniverse@{u a}),\r\n      Type2le@{i a} -> Type2le@{i a}.\r\n  Parameter O_inO@{u a i} : forall (O : ReflectiveSubuniverse@{u a}) (T :\r\nType@{i}),\r\n      In@{u a i} O (O_reflector@{u a i} O T).\r\n  Parameter to@{u a i} : forall (O : ReflectiveSubuniverse@{u a}) (T :\r\nType@{i}),\r\n      T -> O_reflector@{u a i} O T.\r\n  Parameter extendable_to_O@{u a i j k}\r\n    : forall (O : ReflectiveSubuniverse@{u a}) {P : Type2le@{i a}} {Q :\r\nType2le@{j a}} {Q_inO : In@{u a j} O Q},\r\n      ooExtendableAlong@{i i j k} (to O P) (fun _ => Q).\r\nEnd ReflectiveSubuniverses.\r\nModule ReflectiveSubuniverses_Theory (Os : ReflectiveSubuniverses).\r\n  Export Os.\r\n  Existing Class In.\r\n  Coercion O_reflector : ReflectiveSubuniverse >-> Funclass.\r\n  Global Existing Instance O_inO.\r\n  Section ORecursion.\r\n    Context {O : ReflectiveSubuniverse}.\r\n    Definition O_rec {P Q : Type} {Q_inO : In O Q}\r\n               (f : P -> Q)\r\n      : O P -> Q\r\n      := (fst (extendable_to_O O 1%nat) f).1.\r\n  End ORecursion.\r\n  Section Reflective_Subuniverse.\r\n    Universes Ou Oa.\r\n    Context (O : ReflectiveSubuniverse@{Ou Oa}).\r\n    Definition equiv_O_sum {A B} :\r\n      O (A + B)%type <~> O (O A + O B)%type.\r\n    Proof.\r\n      simple refine (equiv_adjointify _ _ _ _).\r\n      - apply O_rec; intros x.\r\n        exact (to O _ (functor_sum (to O A) (to O B) x)).\r\n      - apply O_rec; intros [x|x].\r\n        + Timeout 1 exact (O_rec (to O _ o inl) x). (* Stack overflow *)\r\n\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/388589592/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/813047073","html_url":"https://github.com/coq/coq/issues/4525#issuecomment-813047073","issue_url":"https://api.github.com/repos/coq/coq/issues/4525","id":813047073,"node_id":"MDEyOklzc3VlQ29tbWVudDgxMzA0NzA3Mw==","user":{"login":"ejgallego","id":7192257,"node_id":"MDQ6VXNlcjcxOTIyNTc=","avatar_url":"https://avatars.githubusercontent.com/u/7192257?v=4","gravatar_id":"","url":"https://api.github.com/users/ejgallego","html_url":"https://github.com/ejgallego","followers_url":"https://api.github.com/users/ejgallego/followers","following_url":"https://api.github.com/users/ejgallego/following{/other_user}","gists_url":"https://api.github.com/users/ejgallego/gists{/gist_id}","starred_url":"https://api.github.com/users/ejgallego/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ejgallego/subscriptions","organizations_url":"https://api.github.com/users/ejgallego/orgs","repos_url":"https://api.github.com/users/ejgallego/repos","events_url":"https://api.github.com/users/ejgallego/events{/privacy}","received_events_url":"https://api.github.com/users/ejgallego/received_events","type":"User","site_admin":false},"created_at":"2021-04-04T14:58:28Z","updated_at":"2021-04-04T14:58:28Z","author_association":"MEMBER","body":"Example got broken again.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/813047073/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]