[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516845","html_url":"https://github.com/coq/coq/issues/3182#issuecomment-337516845","issue_url":"https://api.github.com/repos/coq/coq/issues/3182","id":337516845,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjg0NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-10T21:52:23Z","updated_at":"2017-10-18T09:10:45Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI would like this\n\nGoal { f : nat -> nat | f O = O }.\n  esplit.\n  reflexivity.\n\nto heuristically infer that [f] should be [fun _ => 1].  I think this should be a straightforward heuristic to program.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516845/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516846","html_url":"https://github.com/coq/coq/issues/3182#issuecomment-337516846","issue_url":"https://api.github.com/repos/coq/coq/issues/3182","id":337516846,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjg0Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-10T21:56:42Z","updated_at":"2017-10-18T09:10:45Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nTo be explicit, the algorithm should be to unify the evar with (fun .... => <new evar here>), and then unify the new evar with the other term.\n\nSo for unifying [?1 O] and [O], it would first unify [?1] with [(fun x => ?2)] where ?2 inherits the environment of ?1, together with binders for all of the variables passed to ?1; and then try to unify [?2] with [O].\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516846/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516847","html_url":"https://github.com/coq/coq/issues/3182#issuecomment-337516847","issue_url":"https://api.github.com/repos/coq/coq/issues/3182","id":337516847,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjg0Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-12T20:11:01Z","updated_at":"2017-10-18T09:10:46Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\nThe unification algorithm of Coq, well the two unification algorithm of Coq, could be clearly smarter.\nBut higher order unification does not admit most general unifiers.  What should Coq infer in your case? (fun x => x) or (fun _ => 0)? \n\nI can tell you what other systems like Matita or HOL light do, but it is just an arbitrary choice.  An the one of Coq, failing, is a possible one (not my favorite but certainly reasonable).\n\nCheers\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516847/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516849","html_url":"https://github.com/coq/coq/issues/3182#issuecomment-337516849","issue_url":"https://api.github.com/repos/coq/coq/issues/3182","id":337516849,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjg0OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-12T20:24:48Z","updated_at":"2017-10-18T09:10:46Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nI was thinking that it should be [fun _ => 0].  Alternatively, perhaps it should try one, and if that fails, backtrack and try the other one.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516849/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516850","html_url":"https://github.com/coq/coq/issues/3182#issuecomment-337516850","issue_url":"https://api.github.com/repos/coq/coq/issues/3182","id":337516850,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjg1MA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-12-12T21:46:00Z","updated_at":"2017-10-18T09:10:46Z","author_association":"CONTRIBUTOR","body":"Comment author: @gares\n\nThere are infinitely many unifiers in the general case.\nGoogle for \"higher order unification Huet\" and you'll find the whole story.  \n\nOne could enumerate all \"reasonable\" unifiers in a lazy stream, and backtrack if the wrong choice was made.  This is what Isabelle does.  But Isabelle has no delta and iota rules, i.e. no real computation to be taken into account when comparing terms.\n\nIn Coq testing all combinations of possible unifiers would be impractical.\nComparing *closed* term is already complex, and no good-enough solution is known.  According to recent bug activity you have hit that problem yourself, when Qed/Defined hangs, it is usually a term comparison taking too long.\nIf you add to that complexity some extra backtracking... well, ^C\n\nCiao\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516850/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516853","html_url":"https://github.com/coq/coq/issues/3182#issuecomment-337516853","issue_url":"https://api.github.com/repos/coq/coq/issues/3182","id":337516853,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjg1Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-03-25T15:59:20Z","updated_at":"2017-10-18T09:10:46Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nHere is a systematic algorithm that would take care of many cases that give me trouble with setoid_rewriting:\n\nTactic Notation \"not\" tactic(tac) :=\n  first [ tac; fail 1\n        | idtac ].\n\nLtac unify_head_evar x y :=\n  match y with\n    | ?g ?y'\n      => is_evar g; (not has_evar x);\n         match eval pattern y' in x with\n           | ?f ?x' => unify_head_evar f g\n         end\n    | _\n      => has_evar x; (not has_evar y);\n         first [ unify_head_evar y x\n               | fail 1 ]\n    | _ => unify x y\n  end.\n\nGoal { f : nat -> nat | f O = 1 }.\n  esplit.\n  lazymatch goal with |- ?x = ?y => unify_head_evar x y end.\n  (* fun n => S n *)\n\n\nNote that this unification algorithm should _only_ trigger with open terms/evars (and only when there is an evar in one of the head positions); so I expect it to add little to no overhead to Qed/Defined, where there should be no evars left.  Furthermore, I don't care about it handling cases where [pattern] fails (at least not yet), that is, I only care about \"obvious\" cases.  For example, the current case I'm hitting is that if [x] is a variable/hypothesis, then it should be possible for [reflexivity] to solve [?n x = x].\n\nBut it seems that this is already possible in trunk, and simply not in 8.4. \n\nAlternatively, I would like a way to declare unification hints, so that I can say \"for this next type-class resolution, try this whenever standard unification fails\".\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516853/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516856","html_url":"https://github.com/coq/coq/issues/3182#issuecomment-337516856","issue_url":"https://api.github.com/repos/coq/coq/issues/3182","id":337516856,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjg1Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-04-01T13:04:12Z","updated_at":"2017-10-18T09:10:46Z","author_association":"CONTRIBUTOR","body":"Comment author: @pirbo\n\nTrunk unification algorithms will try to go further in pattern unification/eta expansion indeed but v8.4 will never, Sorry.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516856/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]