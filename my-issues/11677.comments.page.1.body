You can do that in Ltac2 using the `Control` module, and export a wrapper to Ltac1 if you want.
@ppedrot Any chance you could supply a code snippet that someone could use without learning all about Ltac2?
@ppedrot I don't think this is possible in Ltac2.  Either that, or there's a bug in `Control.case`.  Here's what I have:
```coq
Require Import Ltac2.Init.
Require Ltac2.Control.
Require Ltac2.Ltac1.

Ltac2 drop_first_success (tac : unit -> 'a) :=
  match Control.case tac with
  | Val v
    => let (first_success, next) := v in
       fun (v : unit) => next (Tactic_failure None)
  | Err err => Control.zero err
  end.

Ltac drop_first_success tac :=
  let f := ltac2:(tac1 |- drop_first_success (fun () => Ltac1.run tac1) ()) in
  f tac.

Ltac drop_n_success n tac :=
  lazymatch n with
  | O => tac
  | S ?n => drop_n_success n ltac:(drop_first_success tac)
  end.

Ltac only_nth_success n tac :=
  once (drop_n_success n tac).

Set Default Proof Mode "Classic".

Goal True \/ False.
  drop_first_success ltac:(idtac "a"; constructor).
(* Error: Uncaught Ltac2 exception: Tactic_failure (None) *)
```
Is the issue that Ltac2 exceptions have level infinity or something?
I think there was some bug, in master I get success with goal `False` (ie @JasonGross's code works)
It succeeds since 89a5abb0b8b453bdda8c9ebf33734c42c3a826db
