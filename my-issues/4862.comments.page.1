[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337544300","html_url":"https://github.com/coq/coq/issues/4862#issuecomment-337544300","issue_url":"https://api.github.com/repos/coq/coq/issues/4862","id":337544300,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NDMwMA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-06-27T20:12:10Z","updated_at":"2017-10-18T10:31:40Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-indices-matter\" \"-nois\" \"-R\" \".\" \"Top\" \"-top\" \"bug_failed_defined_05\") -*- *)\n(* File reduced by coq-bug-finder from original input, then from 1168 lines to 33 lines, then from 138 lines to 34 lines, then from 220 lines to 35 lines, then from 93 lines to 37 lines, then from 118 lines to 41 lines, then from 293 lines to 52 lines, then from 350 lines to 86 lines, then from 126 lines to 85 lines, then from 296 lines to 119 lines, then from 135 lines to 119 lines, then from 583 lines to 221 lines, then from 1441 lines to 390 lines, then from 1253 lines to 539 lines, then from 553 lines to 539 lines, then from 553 lines to 539 lines, then from 529 lines to 511 lines, then from 471 lines to 169 lines, then from 353 lines to 173 lines, then from 236 lines to 179 lines, then from 296 lines to 193 lines, then from 207 lines to 194 lines, then from 146 lines to 101 lines, then from 115 lines to 101 lines *)\n(* coqc version 8.5pl1 (June 2016) compiled on Jun 13 2016 21:7:27 with OCaml 4.02.3                                                                                                                              \n   coqtop version 8.5pl1 (June 2016) *)\n\nModule Export Notations.\nReserved Notation \"x -> y\" (at level 99, right associativity, y at level 200).\nReserved Notation \"~ x\" (at level 75, right associativity).\nReserved Notation \"x = y  :>  T\"\n(at level 70, y at next level, no associativity).\nReserved Notation \"x = y\" (at level 70, no associativity).\nOpen Scope type_scope.\nDeclare ML Module \"coretactics\".\nDeclare ML Module \"extratactics\".\nEnd Notations.\nGlobal Set Universe Polymorphism.\nNotation \"A -> B\" := (forall (_ : A), B) : type_scope.\nInductive False : Type :=.\nAxiom proof_admitted : False.\nTactic Notation \"admit\" := abstract case proof_admitted.\nGlobal Unset Universe Minimization ToSet.\nDefinition relation (A : Type) := A -> A -> Type.\nClass Symmetric {A} (R : relation A) := symmetry : forall x y, R x y -> R y x.\nClass Transitive {A} (R : relation A) := transitivity : forall x y z, R x y -> R y z -> R x z.\nLtac symmetry :=\n  let R := match goal with |- ?R ?x ?y => constr:(R) end in\n  let x := match goal with |- ?R ?x ?y => constr:(x) end in\n  let y := match goal with |- ?R ?x ?y => constr:(y) end in\n  let pre_proof_term_head := constr:(@ symmetry _ R _) in\n  let proof_term_head := (eval cbn in pre_proof_term_head) in\n  refine (proof_term_head y x _); change (R y x).\nTactic Notation \"etransitivity\" open_constr(y) :=\n  let R := match goal with |- ?R ?x ?z => constr:(R) end in\n  let x := match goal with |- ?R ?x ?z => constr:(x) end in\n  let z := match goal with |- ?R ?x ?z => constr:(z) end in\n  let pre_proof_term_head := constr:(@ transitivity _ R _) in\n  let proof_term_head := (eval cbn in pre_proof_term_head) in\n  refine (proof_term_head x y z _ _); [ change (R x y) | change (R y z) ].\nTactic Notation \"etransitivity\" := etransitivity _.\nNotation Type0 := Set.\nDelimit Scope path_scope with path.\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation \"x = y :> A\" := (@ paths A x y) : type_scope.\nNotation \"x = y\" := (x = y :>_) : type_scope.\nLocal Open Scope path_scope.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\nGlobal Instance symmetric_paths {A} : Symmetric (@ paths A) | 0 := @ inverse A.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z :=\n  match p, q with idpath, idpath => idpath end.\nGlobal Instance transitive_paths {A} : Transitive (@ paths A) | 0 := @ concat A.\nNotation \"1\" := idpath : path_scope.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y :=\n  match p with idpath => u end.\nClass IsHProp A := Build_IsHProp : forall x y : A, x = y.\nInductive Empty : Type0 := .\nDefinition not (A:Type) : Type := A -> Empty.\nNotation \"~ x\" := (not x) : type_scope.\nModule Export Trunc.\nGeneralizable Variables A B m n f.\nGlobal Instance trunc_succ `{IsHProp A} : forall x y : A, IsHProp (x = y) | 1000.\nAdmitted.\nTheorem path_ishprop `{H : IsHProp A} : forall x y : A, x = y.\nProof.\n  apply H.\nDefined.\nTheorem hprop_allpath (A : Type) : (forall (x y : A), x = y) -> IsHProp A.\nAdmitted.\nEnd Trunc.\nGeneralizable Variables A B f g e n.\nGlobal Instance trunc_forall `{P : A -> Type} `{forall a, IsHProp (P a)} : IsHProp (forall a, P a) | 100.\nAdmitted.\nGlobal Instance trunc_arrow {A B : Type} `{IsHProp B} : IsHProp (A -> B) | 100 := trunc_forall.\nGlobal Instance hprop_Empty : IsHProp Empty.\nProof.\n  intros [].\nDefined.\n  Definition Book_3_14                                                                                                                                                                                            \n  : forall A (P : ~~A -> Type),                                                                                                                                                                                   \n    (forall a, P (fun na => na a))                                                                                                                                                                                \n    -> (forall x y (z : P x) (w : P y), transport P (path_ishprop x y) z = w)                                                                                                                                     \n    -> forall x, P x.                                                                                                                                                                                             \n  Proof.                                                                                                                                                                                                          \n    intros A P base p nna.                                                                                                                                                                                        \n    assert (forall x, IsHProp (P x)).                                                                                                                                                                             \n    -                                                                                                                                                                                                             \n intro x.                                                                                                                                                                                                         \n      apply hprop_allpath.                                                                                                                                                                                        \n      intros x' y'.                                                                                                                                                                                               \n      etransitivity; [ symmetry; apply (p x x y' x') | ].                                                                                                                                                         \n      set (path := path_ishprop x x).                                                                                                                                                                             \n      assert (H' : idpath = path) by apply path_ishprop.                                                                                                                                                          \n      destruct H'.                                                                                                                                                                                                \n      reflexivity.                                                                                                                                                                                                \n    -                                                                                                                                                                                                             \nadmit.                                                                                                                                                                                                            \n  Defined. (* success *)                                                                                                                                                                                          \n                                                                                                                                                                                                                  \n  Definition Book_3_14'                                                                                                                                                                                           \n  : forall A (P : ~~A -> Type),                                                                                                                                                                                   \n    (forall a, P (fun na => na a))                                                                                                                                                                                \n    -> (forall x y (z : P x) (w : P y), transport P (path_ishprop x y) z = w)                                                                                                                                     \n    -> forall x, P x.                                                                                                                                                                                             \n  Proof.                                                                                                                                                                                                          \n    intros A P base p nna.                                                                                                                                                                                        \n    assert (forall x, IsHProp (P x)).                                                                                                                                                                             \n    -                                                                                                                                                                                                             \n intro x.                                                                                                                                                                                                         \n      apply hprop_allpath.                                                                                                                                                                                        \n      intros x' y'.                                                                                                                                                                                               \n      etransitivity; [ symmetry; apply (p x x y' x') | ].                                                                                                                                                         \n      (* instead of [set], we inline [path_isphprop] here *)                                                                                                                                                      \n      assert (H' : idpath = path_ishprop x x) by apply path_ishprop.                                                                                                                                              \n      destruct H'.                                                                                                                                                                                                \n      reflexivity.                                                                                                                                                                                                \n    -                                                                                                                                                                                                             \nadmit.\n  Defined. (* Error:                                                                                                                                                                                              \nIn environment                                                                                                                                                                                                    \nA : Type                                                                                                                                                                                                          \nP : ~ ~ A -> Type                                                                                                                                                                                                 \nbase : forall a : A, P (fun na : ~ A => na a)                                                                                                                                                                     \np : forall (x y : ~ ~ A) (z : P x) (w : P y), transport P (path_ishprop x y) z = w                                                                                                                                \nnna : ~ ~ A                                                                                                                                                                                                       \nx : ~ ~ A                                                                                                                                                                                                         \nx' : P x                                                                                                                                                                                                          \ny' : P x                                                                                                                                                                                                          \nThe term                                                                                                                                                                                                          \n \"(fun H' : 1 = path_ishprop x x =>                                                                                                                                                                               \n   let p0 := path_ishprop x x in match H' in (_ = y) return (transport P y y' = y') with                                                                                                                          \n                                 | 1 => 1                                                    \n                                 end) (path_ishprop 1 (path_ishprop x x))\" has type                                                                                                                               \n \"@ transport@ {bug_failed_defined_05.114 bug_failed_defined_05.109} (~ ~ A) P x x                                                                                                                                  \n    (@ path_ishprop@ {bug_failed_defined_05.114} (~ ~ A)                                                                                                                                                            \n       (@ trunc_arrow@ {bug_failed_defined_05.107 bug_failed_defined_05.138 bug_failed_defined_05.114}                                                                                                              \n          (~ A) Empty hprop_Empty@ {bug_failed_defined_05.138}) x x) y' = y'\"                                                                                                                                      \nwhile it is expected to have type                                                                                                                                                                                 \n \"@ transport@ {bug_failed_defined_05.114 bug_failed_defined_05.109} (~ ~ A) P x x                                                                                                                                  \n    (@ path_ishprop@ {bug_failed_defined_05.114} (~ ~ A)                                                                                                                                                            \n       (@ trunc_arrow@ {bug_failed_defined_05.107 bug_failed_defined_05.120 bug_failed_defined_05.114}                                                                                                              \n          (~ A) Empty hprop_Empty@ {bug_failed_defined_05.120}) x x) y' = y'\".                                                                                                                                     \n *)\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337544300/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337544302","html_url":"https://github.com/coq/coq/issues/4862#issuecomment-337544302","issue_url":"https://api.github.com/repos/coq/coq/issues/4862","id":337544302,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0NDMwMg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2017-06-02T15:25:29Z","updated_at":"2017-10-18T10:31:40Z","author_association":"CONTRIBUTOR","body":"Comment author: @ejgallego\n\nSeems to work in 8.7.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337544302/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]