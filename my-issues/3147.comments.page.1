[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516227","html_url":"https://github.com/coq/coq/issues/3147#issuecomment-337516227","issue_url":"https://api.github.com/repos/coq/coq/issues/3147","id":337516227,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUxNjIyNw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2013-11-01T18:31:27Z","updated_at":"2022-04-11T22:02:10Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\nI would like to be able to do\r\n```coq\r\nParameter f : nat -> nat -> nat -> nat -> nat.\r\nParameter x : nat -> nat.\r\n\r\nGoal True.\r\n  lazymatch constr:(fun x => f 0 (x 1) 2 (x 3)) with\r\n    | (fun x => (@ ?F x) (@ ?k x)) => pose F; pose k\r\n  end.\r\n```\r\n\r\nAnd have [(fun x => f 0 (x 1) 2)] and [(fun x => x 3)] be [pose]d.  I am fine if the syntax requires extra parentheses (like what I used), or if the first argument which is not a bound index/parameter, and all arguments after it, get treated as literal arguments.  Here is some tactic code which (I believe) achieves the effect desired in the above code, though it clutters up the proof tree:\r\n```coq\r\n  let G := constr:(fun x => f 0 (x 1) 2 (x 3)) in\r\n  let H := fresh in\r\n  let FT := fresh in\r\n  let kT := fresh in\r\n  let F := fresh in\r\n  let k := fresh in\r\n  evar (FT : Type); evar (F : FT); subst FT;\r\n  evar (kT : Type); evar (k : kT); subst kT; \r\n  assert (H : forall x, G x = G x);\r\n  [ let x := fresh in\r\n    intro x;\r\n    cbv beta;\r\n    let Fx := match goal with |- ?Fx ?kx = _ => constr:(Fx) end in\r\n    let kx := match goal with |- ?Fx ?kx = _ => constr:(kx) end in\r\n    let Fx' := fresh in\r\n    let kx' := fresh in\r\n    pose Fx as Fx';\r\n    pose kx as kx';\r\n    pattern x in Fx';\r\n    pattern x in kx';\r\n    match goal with\r\n      | [ H := ?f x |- _ ] => constr_eq H Fx';\r\n                              let F' := (eval unfold F in F) in\r\n                              unify f F'\r\n    end; \r\n    match goal with\r\n      | [ H := ?f x |- _ ] => constr_eq H kx';\r\n                              let k' := (eval unfold k in k) in\r\n                              unify f k'\r\n    end;\r\n    reflexivity\r\n  | clear H ];\r\n  pose F; pose k; subst F k.\r\n```\r\n\r\nAs you can see, this is a lot of work just to strip off the last argument to a function expression, and as I use this pattern many times, it would be nice to be able to do it simply.\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337516227/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]