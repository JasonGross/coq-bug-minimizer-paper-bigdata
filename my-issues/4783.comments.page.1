[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337543085","html_url":"https://github.com/coq/coq/issues/4783#issuecomment-337543085","issue_url":"https://api.github.com/repos/coq/coq/issues/4783","id":337543085,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzU0MzA4NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-06-06T13:30:26Z","updated_at":"2017-10-18T10:27:47Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nSince, as I understand it, rewrite and tc resolution does not care about the term implementing a hint, only about the type of the hint itself, [autorewrite] and tc resolution should reason up to hint types modulo syntactic equality of types respecting universes (either identical universes, or polymorphic universes with identical constraints).\n\nConsider the following code.  The time it takes to have [autorewrite] succeed (with a single rewrite) is proportional to the number of times I instantiate the [PositiveSetExtensions] module, and I don't think this should be the case.\n\nRequire Import Coq.Setoids.Setoid Coq.Classes.Morphisms.\nRequire Import Coq.MSets.MSetPositive Coq.MSets.MSetInterface Coq.MSets.MSetProperties.\nRequire Import Coq.MSets.MSetFacts Coq.MSets.MSetDecide.\n\nSet Implicit Arguments.\n\nLocal Coercion is_true : bool >-> Sortclass.\n\nInstance pointwise_Proper {A B} R (f : A -> B) `{H : forall x, Proper R (f x)}\n  : Proper (pointwise_relation A R) f\n  := H.\n\nGlobal Instance or_iff_impl_morphism : Proper (iff ==> iff ==> impl) or.\nAdmitted.\n\nModule MSetExtensionsOn (E: DecidableType) (Import M: WSetsOn E).\n  Module Export BasicProperties := WPropertiesOn E M.\n  Module Export BasicFacts := WFactsOn E M.\n  Module Export BasicDec := WDecideOn E M.\n\n  Global Instance Equal_Equivalence : Equivalence Equal.\n  Admitted.\n  Axiom union_subset_1b : forall s s', subset s (union s s').\n  Axiom union_subset_2b : forall s s', subset s' (union s s').\n  Create HintDb setsb discriminated.\n  Hint Rewrite union_subset_1b union_subset_2b : setsb.\nEnd MSetExtensionsOn.\n\nModule MSetExtensions (M: Sets) := MSetExtensionsOn M.E M.\n\nLtac t := intros; progress autorewrite with setsb; exact (eq_refl : is_true true).\n\nTypeclasses eauto := debug.\n\nModule Import PositiveSetExtensions := MSetExtensions PositiveSet.\n\n(* Unset Typeclasses Debug. *)\nGoal forall s s', PositiveSet.subset s (PositiveSet.union s s').\nProof. Time t. (* 0.56 s, 3996 lines of tc output *) Abort.\n\nModule PositiveSetExtensions0 := MSetExtensions PositiveSet.\n\n(*Unset Typeclasses Debug.*)\nGoal forall s s', PositiveSet.subset s (PositiveSet.union s s').\nProof. Time t. (* 0.98 s, 6972 lines of tc output *) Abort.\n\nModule PositiveSetExtensions1 := MSetExtensions PositiveSet.\n\n(*Unset Typeclasses Debug.*)\nGoal forall s s', PositiveSet.subset s (PositiveSet.union s s').\nProof. Time t. (* 1.5 s, 9948 lines of tc output *) Abort.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337543085/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]