[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337523681","html_url":"https://github.com/coq/coq/issues/3588#issuecomment-337523681","issue_url":"https://api.github.com/repos/coq/coq/issues/3588","id":337523681,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMzY4MQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-09-06T22:21:59Z","updated_at":"2017-10-18T09:30:16Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\n(* File reduced by coq-bug-finder from original input, then from 6764 lines to 263 lines, then from 263 lines to 115 lines, then from 90 lines to 71 lines *)\n(* coqc version trunk (September 2014) compiled on Sep 6 2014 6:15:6 with OCaml 4.01.0\n   coqtop version cagnode17:/afs/csail.mit.edu/u/j/jgross/coq-trunk,trunk (3ea6d6888105edd5139ae0a4d8f8ecdb586aff6c) *)\n\nGeneralizable All Variables.\nDefinition compose {A B C : Type} (g : B -> C) (f : A -> B) := fun x => g (f x).\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a.\nArguments idpath {A a} , [A] a.\nNotation \"x = y :> A\" := (@ paths A x y) : type_scope.\nNotation \"x = y\" := (x = y :>_) : type_scope.\nDelimit Scope path_scope with path.\nLocal Open Scope path_scope.\nDefinition concat {A : Type} {x y z : A} (p : x = y) (q : y = z) : x = z := match p, q with idpath, idpath => idpath end.\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\nNotation \"1\" := idpath : path_scope.\nNotation \"p @  q\" := (concat p q) (at level 20) : path_scope.\nNotation \"p ^\" := (inverse p) (at level 3, format \"p '^'\") : path_scope.\nDefinition transport {A : Type} (P : A -> Type) {x y : A} (p : x = y) (u : P x) : P y := match p with idpath => u end.\nNotation \"p # x\" := (transport _ p x) (right associativity, at level 65, only parsing) : path_scope.\nClass IsEquiv {A B : Type} (f : A -> B) := { equiv_inv : B -> A }.\nAxiom isequiv_compose : forall `{IsEquiv A B f} `{IsEquiv B C g}, IsEquiv (compose g f).\nModule NonPrim.\n  Record sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\n  Notation \"{ x : A & B }\" := (sigT (A := A) (fun x : A => B)) : type_scope.\n  Arguments projT1 {_ _} _.\n  Arguments projT2 {_ _} _.\n  Arguments existT {_} _ _ _.\n  Notation \"( x ; y )\" := (existT _ x y) : fibration_scope.\n  Open Scope fibration_scope.\n  Notation pr1 := projT1.\n  Notation pr2 := projT2.\n  Notation \"x .1\" := (pr1 x) (at level 3, format \"x '.1'\") : fibration_scope.\n  Notation \"x .2\" := (pr2 x) (at level 3, format \"x '.2'\") : fibration_scope.\n  Axiom path_sigma_uncurried : forall {A : Type} (P : A -> Type) (u v : sigT P)\n                                      (pq : {p : u.1 = v.1 &  p # u.2 = v.2}),\n                                 u = v.\n  Axiom isequiv_path_sigma : forall `{P : A -> Type} {u v : sigT P}, IsEquiv (path_sigma_uncurried P u v).\n\n  Definition ExtensionAlong {A B : Type} (f : A -> B)\n             (P : B -> Type) (d : forall x:A, P (f x))\n    := { s : forall y:B, P y & forall x:A, s (f x) = d x }.\n\n  Definition path_extension {A B : Type} {f : A -> B}\n             {P : B -> Type} {d : forall x:A, P (f x)}\n             (ext ext' : ExtensionAlong f P d)\n  : (ExtensionAlong f\n                    (fun y => pr1 ext y = pr1 ext' y)\n                    (fun x => pr2 ext x @  (pr2 ext' x)^))\n    -> ext = ext'.\n  Proof.\n    apply (compose (path_sigma_uncurried _ _ _)).\n    admit.\n  Defined.\n\n  Global Instance isequiv_path_extension {A B : Type} {f : A -> B}\n         {P : B -> Type} {d : forall x:A, P (f x)}\n         (ext ext' : ExtensionAlong f P d)\n  : IsEquiv (path_extension ext ext') | 0.\n  Proof.\n    apply @ isequiv_compose.\n    2: refine (@ isequiv_path_sigma _ _ _ _) || fail \"sanity check\".\n    Undo.\n    2: apply @ isequiv_path_sigma || fail \"actual test\". (* succeeds *)\n  Admitted.\nEnd NonPrim.\n\nModule Prim.\n  Set Primitive Projections.\n  Record sigT {A} (P : A -> Type) := existT { projT1 : A ; projT2 : P projT1 }.\n  Notation \"{ x : A & B }\" := (sigT (A := A) (fun x : A => B)) : type_scope.\n  Arguments projT1 {_ _} _.\n  Arguments projT2 {_ _} _.\n  Arguments existT {_} _ _ _.\n  Notation \"( x ; y )\" := (existT _ x y) : fibration_scope.\n  Open Scope fibration_scope.\n  Notation pr1 := projT1.\n  Notation pr2 := projT2.\n  Notation \"x .1\" := (pr1 x) (at level 3, format \"x '.1'\") : fibration_scope.\n  Notation \"x .2\" := (pr2 x) (at level 3, format \"x '.2'\") : fibration_scope.\n  Axiom path_sigma_uncurried : forall {A : Type} (P : A -> Type) (u v : sigT P)\n                                      (pq : {p : u.1 = v.1 &  p # u.2 = v.2}),\n                                 u = v.\n  Axiom isequiv_path_sigma : forall `{P : A -> Type} {u v : sigT P}, IsEquiv (path_sigma_uncurried P u v).\n\n  Definition ExtensionAlong {A B : Type} (f : A -> B)\n             (P : B -> Type) (d : forall x:A, P (f x))\n    := { s : forall y:B, P y & forall x:A, s (f x) = d x }.\n\n  Definition path_extension {A B : Type} {f : A -> B}\n             {P : B -> Type} {d : forall x:A, P (f x)}\n             (ext ext' : ExtensionAlong f P d)\n  : (ExtensionAlong f\n                    (fun y => pr1 ext y = pr1 ext' y)\n                    (fun x => pr2 ext x @  (pr2 ext' x)^))\n    -> ext = ext'.\n  Proof.\n    apply (compose (path_sigma_uncurried _ _ _)).    admit.\n  Defined.\n\n  Global Instance isequiv_path_extension {A B : Type} {f : A -> B}\n         {P : B -> Type} {d : forall x:A, P (f x)}\n         (ext ext' : ExtensionAlong f P d)\n  : IsEquiv (path_extension ext ext') | 0.\n  Proof.\n    apply @ isequiv_compose.\n    2: refine (@ isequiv_path_sigma _ _ _ _) || fail \"sanity check\".\n    Undo.\n    2: apply @ isequiv_path_sigma || fail \"actual test\". (* fails *)\n  Admitted.\nEnd Prim.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337523681/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337523683","html_url":"https://github.com/coq/coq/issues/3588#issuecomment-337523683","issue_url":"https://api.github.com/repos/coq/coq/issues/3588","id":337523683,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMzY4Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-09-11T11:40:55Z","updated_at":"2017-10-18T09:30:16Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nFixed too, because I forced type unifications for projections.\n\n*** This bug has been marked as a duplicate of bug [BZ#3504](https://github.com/coq/coq/issues?q=is%3Aissue%20%22Original%20bug%20ID%3A%20BZ%233504%22) ***\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337523683/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]