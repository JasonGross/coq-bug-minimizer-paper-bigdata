[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520952","html_url":"https://github.com/coq/coq/issues/3425#issuecomment-337520952","issue_url":"https://api.github.com/repos/coq/coq/issues/3425","id":337520952,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMDk1Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-07-15T22:19:41Z","updated_at":"2021-09-29T14:40:45Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\r\n\r\n```\r\n(* -*- mode: coq; coq-prog-args: (\"-emacs\" \"-indices-matter\") -*- *)\r\n(* File reduced by coq-bug-finder from original input, then from 17950 lines to 11826 lines, then from 10956 lines to 10214 lines, then from 10225 lines to 6285 lines, then from 6300 lines to 901 lines, then from 833 lines to 552 lines, then from 529 lines to 478 lines *)\r\n\r\nSet Universe Polymorphism.\r\nSet Implicit Arguments.\r\nGeneralizable All Variables.\r\nAxiom admit : forall {T}, T.\r\nReserved Infix \"o\" (at level 40, left associativity).\r\nDefinition relation (A : Type) := A -> A -> Type.\r\nClass Symmetric {A} (R : relation A) := symmetry : forall x y, R x y -> R y x.\r\nInductive paths {A : Type} (a : A) : A -> Type := idpath : paths a a where \"x = y\" := (@ paths _ x y) : type_scope.\r\nArguments idpath {A a} , [A] a.\r\nDelimit Scope path_scope with path.\r\nLocal Open Scope path_scope.\r\nDefinition inverse {A : Type} {x y : A} (p : x = y) : y = x := match p with idpath => idpath end.\r\nInstance symmetric_paths {A} : Symmetric (@ paths A) | 0 := @ inverse A.\r\nNotation \"1\" := idpath : path_scope.\r\nDefinition pointwise_paths {A} {P:A->Type} (f g:forall x:A, P x) := forall x:A, f x = g x.\r\nHint Unfold pointwise_paths : typeclass_instances.\r\nClass Contr_internal (A : Type) := { center : A ; contr : (forall y : A, center = y) }.\r\nInductive trunc_index : Type := minus_two | trunc_S (x : trunc_index).\r\nFixpoint nat_to_trunc_index (n : nat) : trunc_index\r\n  := match n with\r\n       | 0 => trunc_S (trunc_S minus_two)\r\n       | S n' => trunc_S (nat_to_trunc_index n')\r\n     end.\r\nCoercion nat_to_trunc_index : nat >-> trunc_index.\r\nFixpoint IsTrunc_internal (n : trunc_index) (A : Type) : Type :=\r\n  match n with\r\n    | minus_two => Contr_internal A\r\n    | trunc_S n' => forall (x y : A), IsTrunc_internal n' (x = y)\r\n  end.\r\nClass IsTrunc (n : trunc_index) (A : Type) : Type :=\r\n  Trunc_is_trunc : IsTrunc_internal n A.\r\nNotation IsHSet := (IsTrunc 0).\r\nAxiom dummy_funext_type : Type.\r\nClass Funext := { dummy_funext_value_for_speed : dummy_funext_type }.\r\nGlobal Instance trunc_forall `{P : A -> Type} `{forall a, IsTrunc n (P a)} : IsTrunc n (forall a, P a) | 100.\r\nadmit.\r\nDefined.\r\nDefinition path_prod_uncurried {A B : Type} (z z' : A * B)\r\n           (pq : (fst z = fst z') * (snd z = snd z'))\r\n: (z = z')\r\n  := match pq with (p,q) =>\r\n                   match z, z' return\r\n                         (fst z = fst z') -> (snd z = snd z') -> (z = z') with\r\n                     | (a,b), (a',b') => fun p q =>\r\n                                           match p, q with\r\n                                               idpath, idpath => 1\r\n                                           end\r\n                   end p q\r\n     end.\r\nDefinition path_prod {A B : Type} (z z' : A * B) :\r\n  (fst z = fst z') -> (snd z = snd z') -> (z = z')\r\n  := fun p q => path_prod_uncurried z z' (p,q).\r\nDefinition path_prod' {A B : Type} {x x' : A} {y y' : B}\r\n: (x = x') -> (y = y') -> ((x,y) = (x',y'))\r\n  := fun p q => path_prod (x,y) (x',y') p q.\r\nRecord hSet := BuildhSet {setT:> Type; iss :> IsHSet setT}.\r\nGlobal Existing Instance iss.\r\nDelimit Scope morphism_scope with morphism.\r\nDelimit Scope category_scope with category.\r\nDelimit Scope object_scope with object.\r\nRecord PreCategory :=\r\n  Build_PreCategory' {\r\n      object :> Type;\r\n      morphism : object -> object -> Type;\r\n\r\n      identity : forall x, morphism x x;\r\n      compose : forall s d d',\r\n                  morphism d d'\r\n                  -> morphism s d\r\n                  -> morphism s d'\r\n                              where \"f 'o' g\" := (compose f g);\r\n\r\n      associativity : forall x1 x2 x3 x4\r\n                             (m1 : morphism x1 x2)\r\n                             (m2 : morphism x2 x3)\r\n                             (m3 : morphism x3 x4),\r\n                        (m3 o m2) o m1 = m3 o (m2 o m1);\r\n\r\n      associativity_sym : forall x1 x2 x3 x4\r\n                                 (m1 : morphism x1 x2)\r\n                                 (m2 : morphism x2 x3)\r\n                                 (m3 : morphism x3 x4),\r\n                            m3 o (m2 o m1) = (m3 o m2) o m1;\r\n\r\n      left_identity : forall a b (f : morphism a b), identity b o f = f;\r\n      right_identity : forall a b (f : morphism a b), f o identity a = f;\r\n\r\n      identity_identity : forall x, identity x o identity x = identity x;\r\n\r\n      trunc_morphism : forall s d, IsHSet (morphism s d)\r\n    }.\r\n\r\nBind Scope category_scope with PreCategory.\r\nArguments identity [!C%category] x%object : rename.\r\nArguments compose [!C%category s%object d%object d'%object] m1%morphism m2%morphism : rename.\r\n\r\nDefinition Build_PreCategory\r\n           object morphism compose identity\r\n           associativity left_identity right_identity\r\n  := @ Build_PreCategory'\r\n       object\r\n       morphism\r\n       compose\r\n       identity\r\n       associativity\r\n       (fun _ _ _ _ _ _ _ => symmetry _ _ (associativity _ _ _ _ _ _ _))\r\n       left_identity\r\n       right_identity\r\n       (fun _ => left_identity _ _ _).\r\n\r\nExisting Instance trunc_morphism.\r\nInfix \"o\" := compose : morphism_scope.\r\nNotation \"1\" := (identity _) : morphism_scope.\r\n\r\nDelimit Scope functor_scope with functor.\r\n\r\nLocal Open Scope morphism_scope.\r\n\r\nSection Functor.\r\n\r\n  Record Functor (C D : PreCategory) :=\r\n    {\r\n      object_of :> C -> D;\r\n      morphism_of : forall s d, morphism C s d\r\n                                -> morphism D (object_of s) (object_of d);\r\n      composition_of : forall s d d'\r\n                              (m1 : morphism C s d) (m2: morphism C d d'),\r\n                         morphism_of _ _ (m2 o m1)\r\n                         = (morphism_of _ _ m2) o (morphism_of _ _ m1);\r\n      identity_of : forall x, morphism_of _ _ (identity x)\r\n                              = identity (object_of x)\r\n    }.\r\nEnd Functor.\r\n\r\nBind Scope functor_scope with Functor.\r\nArguments morphism_of [C%category] [D%category] F%functor [s%object d%object] m%morphism : rename, simpl nomatch.\r\nNotation \"F '_1' m\" := (morphism_of F m) (at level 10, no associativity) : morphism_scope.\r\n\r\nClass IsIsomorphism {C : PreCategory} {s d} (m : morphism C s d) := { morphism_inverse : morphism C d s ;\r\n                                                                      foo : morphism_inverse = morphism_inverse }.\r\n\r\nSection opposite.\r\n  Definition opposite (C : PreCategory) : PreCategory\r\n    := @ Build_PreCategory'\r\n         C\r\n         (fun s d => morphism C d s)\r\n         (identity (C := C))\r\n         (fun _ _ _ m1 m2 => m2 o m1)\r\n         (fun _ _ _ _ _ _ _ => @ associativity_sym _ _ _ _ _ _ _ _)\r\n         (fun _ _ _ _ _ _ _ => @ associativity _ _ _ _ _ _ _ _)\r\n         (fun _ _ => @ right_identity _ _ _)\r\n         (fun _ _ => @ left_identity _ _ _)\r\n         (@ identity_identity C)\r\n         _.\r\nEnd opposite.\r\nNotation \"C ^op\" := (opposite C) (at level 3) : category_scope.\r\n\r\nSection prod.\r\n\r\n  Definition prod (C D : PreCategory) : PreCategory.\r\n    refine (@ Build_PreCategory\r\n              (C * D)%type\r\n              (fun s d => (morphism C (fst s) (fst d)\r\n                           * morphism D (snd s) (snd d))%type)\r\n              (fun x => (identity (fst x), identity (snd x)))\r\n              (fun s d d' m2 m1 => (fst m2 o fst m1, snd m2 o snd m1))\r\n              _\r\n              _\r\n              _\r\n              _); admit.\r\n  Defined.\r\nEnd prod.\r\nInfix \"*\" := prod : category_scope.\r\n\r\nSection composition.\r\n  Variable C : PreCategory.\r\n  Variable D : PreCategory.\r\n  Variable E : PreCategory.\r\n  Variable G : Functor D E.\r\n  Variable F : Functor C D.\r\n\r\n  Definition composeF : Functor C E\r\n    := Build_Functor\r\n         C E\r\n         (fun c => G (F c))\r\n         (fun _ _ m => morphism_of G (morphism_of F m))\r\n         admit\r\n         admit.\r\nEnd composition.\r\nInfix \"o\" := composeF : functor_scope.\r\n\r\nModule Export HoTT_DOT_categories_DOT_NaturalTransformation_DOT_Core.\r\n\r\n  Section NaturalTransformation.\r\n    Variable C : PreCategory.\r\n    Variable D : PreCategory.\r\n    Variables F G : Functor C D.\r\n\r\n    Record NaturalTransformation :=\r\n      Build_NaturalTransformation' {\r\n          components_of :> forall c, morphism D (F c) (G c);\r\n          commutes : forall s d (m : morphism C s d),\r\n                       components_of d o F _1 m = G _1 m o components_of s;\r\n\r\n          commutes_sym : forall s d (m : C.(morphism) s d),\r\n                           G _1 m o components_of s = components_of d o F _1 m\r\n        }.\r\n  End NaturalTransformation.\r\n\r\n  Section composition.\r\n\r\n    Section compose.\r\n      Variable C : PreCategory.\r\n      Variable D : PreCategory.\r\n      Variables F F' F'' : Functor C D.\r\n\r\n      Variable T' : NaturalTransformation F' F''.\r\n      Variable T : NaturalTransformation F F'.\r\n\r\n      Local Notation CO c := (T' c o T c).\r\n\r\n      Definition composeT\r\n      : NaturalTransformation F F''\r\n        := Build_NaturalTransformation' F F''\r\n                                        (fun c => CO c)\r\n                                        admit\r\n                                        admit.\r\n    End compose.\r\n\r\n  End composition.\r\n  Infix \"o\" := composeT : natural_transformation_scope.\r\n\r\n  Section path_natural_transformation.\r\n\r\n    Global Instance trunc_natural_transformation C D (F G : Functor C D)\r\n    : IsHSet (NaturalTransformation F G).\r\n    admit.\r\n    Defined.\r\n\r\n  End path_natural_transformation.\r\n  Local Open Scope natural_transformation_scope.\r\n\r\n  Section associativity.\r\n\r\n    Section nt.\r\n\r\n      Definition associativityT `{H0 : Funext}\r\n                 C D F G H I\r\n                 (V : @ NaturalTransformation C D F G)\r\n                 (U : @ NaturalTransformation C D G H)\r\n                 (T : @ NaturalTransformation C D H I)\r\n      : (T o U) o V = T o (U o V).\r\n        admit.\r\n      Defined.\r\n    End nt.\r\n  End associativity.\r\n\r\n  Section functor_category.\r\n\r\n    Definition functor_category `{Funext} (C D : PreCategory) : PreCategory\r\n      := @ Build_PreCategory (Functor C D)\r\n                            (@ NaturalTransformation C D)\r\n                            admit\r\n                            (@ composeT C D)\r\n                            (@ associativityT _ C D)\r\n                            admit\r\n                            admit\r\n                            _.\r\n  End functor_category.\r\n\r\n  Local Notation \"C -> D\" := (functor_category C D) : category_scope.\r\n  Module Export ExponentialLaws.\r\n    Module Export Law4.\r\n      Module Export Functors.\r\n\r\n        Section law4.\r\n          Context `{Funext}.\r\n          Variable C1 : PreCategory.\r\n          Variable C2 : PreCategory.\r\n          Variable D : PreCategory.\r\n\r\n          Section inverse.\r\n\r\n            Section object_of.\r\n              Variable F : Functor (C1 * C2) D.\r\n\r\n              Definition inverse_object_of_object_of\r\n              : C1 -> (C2 -> D)%category.\r\n              Proof.\r\n                intro c1.\r\n                refine (Build_Functor\r\n                          C2 D\r\n                          (fun c2 => F (c1, c2))\r\n                          (fun s2 d2 m2 => morphism_of\r\n                                             F\r\n                                             (s := (c1, s2))\r\n                                             (d := (c1, d2))\r\n                                             (identity c1, m2))\r\n                          _\r\n                          _);\r\n                  admit.\r\n              Defined.\r\n\r\n              Definition inverse_object_of_morphism_of\r\n                         s d (m : morphism C1 s d)\r\n              : morphism (C2 -> D)\r\n                         (inverse_object_of_object_of s)\r\n                         (inverse_object_of_object_of d).\r\n                admit.\r\n              Defined.\r\n\r\n              Definition inverse_object_of\r\n              : (C1 -> (C2 -> D))%category.\r\n              Proof.\r\n                refine (Build_Functor\r\n                          C1 (C2 -> D)\r\n                          inverse_object_of_object_of\r\n                          inverse_object_of_morphism_of\r\n                          _\r\n                          _); admit.\r\n              Defined.\r\n            End object_of.\r\n\r\n            Section morphism_of.\r\n\r\n              Definition inverse_morphism_of\r\n                         s d (m : morphism (C1 * C2 -> D) s d)\r\n              : morphism (C1 -> (C2 -> D))\r\n                         (inverse_object_of s)\r\n                         (inverse_object_of d).\r\n                admit.\r\n              Defined.\r\n            End morphism_of.\r\n\r\n            Definition inverse\r\n            : Functor (C1 * C2 -> D) (C1 -> (C2 -> D)).\r\n            Proof.\r\n              refine (Build_Functor\r\n                        (C1 * C2 -> D) (C1 -> (C2 -> D))\r\n                        inverse_object_of\r\n                        inverse_morphism_of\r\n                        _\r\n                        _);\r\n              admit.\r\n            Defined.\r\n          End inverse.\r\n        End law4.\r\n\r\n        Section opposite.\r\n\r\n          Definition opposite C D (F : Functor C D) : Functor C^op D^op\r\n            := Build_Functor (C^op) (D^op)\r\n                             (object_of F)\r\n                             (fun s d => morphism_of F (s := d) (d := s))\r\n                             (fun d' d s m1 m2 => composition_of F s d d' m2 m1)\r\n                             (identity_of F).\r\n        End opposite.\r\n        Notation \"F ^op\" := (opposite F) : functor_scope.\r\n\r\n        Module ProdF.\r\n\r\n          Section proj.\r\n\r\n            Definition fst {C D} : Functor (C * D) C\r\n              := Build_Functor (C * D) C\r\n                               (@ fst _ _)\r\n                               (fun _ _ => @ fst _ _)\r\n                               (fun _ _ _ _ _ => idpath)\r\n                               (fun _ => idpath).\r\n\r\n            Definition snd {C D} : Functor (C * D) D\r\n              := Build_Functor (C * D) D\r\n                               (@ snd _ _)\r\n                               (fun _ _ => @ snd _ _)\r\n                               (fun _ _ _ _ _ => idpath)\r\n                               (fun _ => idpath).\r\n          End proj.\r\n\r\n          Section prod.\r\n\r\n            Definition prod C D D' (F : Functor C D) (F' : Functor C D')\r\n            : Functor C (D * D')\r\n              := Build_Functor\r\n                   C (D * D')\r\n                   (fun c => (F c, F' c))\r\n                   (fun s d m => (F _1 m, F' _1 m))\r\n                   (fun _ _ _ _ _ => path_prod' (composition_of F _ _ _ _ _)\r\n                                                (composition_of F' _ _ _ _ _))\r\n                   (fun _ => path_prod' (identity_of F _) (identity_of F' _)).\r\n          End prod.\r\n\r\n          Local Infix \"*\" := prod : functor_scope.\r\n\r\n          Section pair.\r\n            Definition pair C D C' D' (F : Functor C D) (F' : Functor C' D') : Functor (C * C') (D * D')\r\n              := (F o fst) * (F' o snd).\r\n          End pair.\r\n\r\n          Module Export FunctorProdNotations.\r\n            Notation \"( x , y , .. , z )\" := (pair .. (pair x y) .. z) : functor_scope.\r\n          End FunctorProdNotations.\r\n\r\n        End ProdF.\r\n\r\n        Notation cat_of obj :=\r\n          (@ Build_PreCategory obj\r\n                              (fun x y => x -> y)\r\n                              (fun _ x => x)\r\n                              (fun _ _ _ f g => fun x => f (g x))\r\n                              (fun _ _ _ _ _ _ _ => idpath)\r\n                              (fun _ _ _ => idpath)\r\n                              (fun _ _ _ => idpath)\r\n                              _).\r\n        Definition set_cat `{Funext} : PreCategory := cat_of hSet.\r\n\r\n        Section hom_functor.\r\n          Context `{Funext}.\r\n          Variable C : PreCategory.\r\n\r\n          Local Notation obj_of c'c :=\r\n            (@ BuildhSet\r\n               (morphism\r\n                  C\r\n                  (fst (c'c : object (C^op * C)))\r\n                  (snd (c'c : object (C^op * C))))\r\n               _).\r\n\r\n          Definition hom_functor : Functor (C^op * C) set_cat.\r\n            refine (Build_Functor (C^op * C) set_cat\r\n                                  (fun c'c => obj_of c'c)\r\n                                  admit\r\n                                  admit\r\n                                  admit).\r\n          Defined.\r\n        End hom_functor.\r\n        Import ProdF.\r\n\r\n        Section full_faithful.\r\n          Context `{Funext}.\r\n          Variable C : PreCategory.\r\n          Variable D : PreCategory.\r\n          Variable F : Functor C D.\r\n\r\n          Definition induced_hom_natural_transformation\r\n          : NaturalTransformation (hom_functor C) (hom_functor D o (F^op, F)).\r\n            admit.\r\n          Defined.\r\n\r\n          Class IsFullyFaithful\r\n            := is_fully_faithful\r\n               : forall x y : C,\r\n                   IsIsomorphism (induced_hom_natural_transformation (x, y)).\r\n        End full_faithful.\r\n\r\n        Definition coyoneda `{Funext} A : Functor A^op (A -> set_cat)\r\n          := ExponentialLaws.Law4.Functors.inverse _ _ _ (hom_functor A).\r\n\r\n        Definition coyoneda_lemma_morphism `{Funext} A (F : object (A -> set_cat)) (a : A)\r\n        : morphism set_cat\r\n                   (@ BuildhSet\r\n                      (morphism (A -> set_cat) (coyoneda A a) F)\r\n                      _)\r\n                   (F a)\r\n          := fun phi => phi a 1%morphism.\r\n        Context `{Funext}.\r\n        Variable A : PreCategory.\r\n\r\n        Definition coyoneda_embedding : IsFullyFaithful (coyoneda A).\r\n        Proof.\r\n          intros a b.\r\n          pose (coyoneda_lemma_morphism (F := coyoneda A b) (a := a)) as X.\r\n          exists X.\r\n          Undo.\r\n          Typeclasses eauto := debug.\r\n          Timeout 2 exists (@ coyoneda_lemma_morphism _ A (@ coyoneda _ A b) a).\r\n```\r\n\r\nIf you break the last command, you will see\r\n  Debug: 1.1: exact H on Funext\r\n  Debug: 1.1: exact H on Funext\r\nand there are only two instances of Funext, and filling in either one makes the code go through instantly.  In the original example this is coming from, it might loop, or might just take minutes (rather than 6.5 seconds). (But, really, this typeclass resolution should not take 6.5 seconds.  What is Coq doing?)\r\n\r\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520952/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520955","html_url":"https://github.com/coq/coq/issues/3425#issuecomment-337520955","issue_url":"https://api.github.com/repos/coq/coq/issues/3425","id":337520955,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMDk1NQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-02-22T19:23:40Z","updated_at":"2017-10-18T09:22:28Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nFTR, most of the elapsed time is passed in the on-the-fly hashconsing of universes. If I deactivate it, I get a 100% speedup.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520955/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520956","html_url":"https://github.com/coq/coq/issues/3425#issuecomment-337520956","issue_url":"https://api.github.com/repos/coq/coq/issues/3425","id":337520956,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMDk1Ng==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-03-01T11:23:27Z","updated_at":"2017-10-18T09:22:28Z","author_association":"CONTRIBUTOR","body":"Comment author: @mattam82\n\nThis is an unfortunate situation indeed. What happens currently is that the exists tries to unify the type of the coyoneda application with the hnf of the [morphism _ _ _ ] argument of Build_IsIsomorphism, which is: \n\n  (let\n   (object, morphism, identity, compose, _, _, _, _, _, _) as p\n   return (p -> p -> Type) := ?M216 in\n   morphism) ?M218 ?M217\n\nThis fails. The typeclass resolution is launched during unification ([Typeclass Resolution for Conversion] is on), figuring out the funext instances, but again the unification fails and we forget about these instantiations. Then the goal is unified with [IsIsomorphism ?M216 ?M217 ?M218] and that sets the metavariables to the right terms. We try again the coercion of the coyoneda application with the refined (let (objec... ) term which now unfolds and unifies correctly, but as the existentials for the typeclass instances are not filled, we must resort to doing the unfolding in unification and the (unsound) first-order approximation rule of w_unify fires, which tries to compare two terms of different types, namely Buildhset and:\nEval compute in @ object_of\n               (Top.prod (Top.opposite (Top.opposite A)) (Top.opposite A))\n               (@ set_cat H). \nForcing unification to compute a normal form of the latter, which expands to a very large term. This explains the slowdown. In the case of the pose, no unification is needed, only conversion, which does not try this first-order unification, because no metavariables appear anymore in the type of the coyoneda application.\n\nI'm surprised by the remark of PMP though, I couldn't reproduce a noticeable speedup by deactivating universe hconsing, how did you do it?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520956/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520957","html_url":"https://github.com/coq/coq/issues/3425#issuecomment-337520957","issue_url":"https://api.github.com/repos/coq/coq/issues/3425","id":337520957,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMDk1Nw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-06-04T05:55:53Z","updated_at":"2017-10-18T09:22:29Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nThis seems to be fixed now (takes 0.2 seconds in 8.5pl1)?  Did one of you (Matthieu, Pierre-Marie) fix this intentionally?\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520957/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520958","html_url":"https://github.com/coq/coq/issues/3425#issuecomment-337520958","issue_url":"https://api.github.com/repos/coq/coq/issues/3425","id":337520958,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMDk1OA==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2016-06-04T05:57:08Z","updated_at":"2017-10-18T09:22:29Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nOh, nevermind, if I make [admit] be [case proof_admitted] rather than [abstract case proof_admitted], it's still slow (8 s).\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337520958/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]