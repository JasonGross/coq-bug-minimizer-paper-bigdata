I think I know how this can be fixed, but you'll have to wait for a release of coq-elpi. Hopefully in a month..
> I think I know how this can be fixed, but you'll have to wait for a release of coq-elpi. Hopefully in a month..

Hum, looks interesting. There is so much to do on automatic generation of schemes and I'm extremely glad to learn that you worked on that. Are some "indiscretion" already possible or do we have to wait? In particular, I'm very curious about how it shall compare to `Equations` and the various variants of `Scheme`/`Derive` in terms of supported schemes, supported types, etc. Apparently, efficiency shall be good and I guess it is less painful methodology than working directly with de Bruijn indices (as in `indrec.ml` or `eqschemes.ml`), while at the same time more controlled than working with tactics (as in `auto_ind_decl.ml`).
It should be possible to construct equality schemes + proofs that are linear in the number of constructors.  Taking inspiration from https://github.com/coq/coq/pull/8965#discussion_r232454555, it should be possible to encode constructor indices as n-tuples of booleans, and encode constructor data as dependent over the index type.  Then you can prove that the sigma of the index and the data is equivalent to the original type, and transport any boolean/decidable equality across the equivalence.  Since the encoded index type uses log(n) space, it should be possible to write the decider for the indexed part in (log(n))^2 space, and then write the decider for the data part in linear space, giving terms that are overall linear in the number of constructors.  (Unclear if this is worth doing in general, though...)
> Unclear if this is worth doing in general, though...

:smile:
Another data-point: in https://gist.github.com/JasonGross/0218fac1e348bd09bdfb3cbad12eeef1, I show how to systematically prove `reflect (x = y :> A) (beq x y)` for finite (enumerable) types `A` with one proof that is linear in the number of inhabitants, together with a `vm_cast_no_check (eq_refl true)` with quadratic running time (but very reasonable constant factors).  This allows sub-second proofs even when there are >= 256 constructors.  (Though it's not clear to me how to generalize this to non-enumerable types.)
