[{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521289","html_url":"https://github.com/coq/coq/issues/3448#issuecomment-337521289","issue_url":"https://api.github.com/repos/coq/coq/issues/3448","id":337521289,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTI4OQ==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2014-07-21T12:46:49Z","updated_at":"2017-10-18T09:23:35Z","author_association":"CONTRIBUTOR","body":"Comment author: @JasonGross\n\nThe former takes around 1.3 seconds, while the latter takes less than 0.01 s.\n\n(* File reduced by coq-bug-finder from original input, then from 16780 lines to 19369 lines, then from 18856 lines to 689 lines, then from 700 lines to 686 lines, then from 594 lines to 379 lines, then from 392 lines to 391 lines, then from 377 lines to 360 lines *)\nRequire Coq.Setoids.Setoid.\n\nImport Coq.Classes.Morphisms.\nImport Coq.Setoids.Setoid.\nGeneralizable All Variables.\n\nAxiom admit : forall {T}, T.\nDefinition BITS (n : nat) : Set.\nAdmitted.\nDefinition BYTE   := BITS 8.\nDefinition DWORD  := BITS 32.\n\nClass Equiv (A : Type) := equiv : relation A.\nInfix \"===\" := equiv (at level 70, no associativity).\n\nClass type (A : Type) {e : Equiv A} := eq_equiv : Equivalence equiv.\n\nInstance Equiv_PropP : Equiv Prop := iff.\n\nGlobal Instance ge_Pre: PreOrder ge.\nadmit.\nDefined.\n\nClass ILogicOps Frm := {\n                        lentails: relation Frm;\n                        ltrue: Frm;\n                        lfalse: Frm;\n                        limpl: Frm -> Frm -> Frm;\n                        land: Frm -> Frm -> Frm;\n                        lor: Frm -> Frm -> Frm;\n                        lforall: forall {T}, (T -> Frm) -> Frm;\n                        lexists: forall {T}, (T -> Frm) -> Frm\n                      }.\n\nInfix \"|--\"  := lentails (at level 79, no associativity).\nInfix \"//\\\\\"   := land (at level 75, right associativity).\nInfix \"\\\\//\"   := lor (at level 76, right associativity).\nInfix \"-->>\"   := limpl (at level 77, right associativity).\nNotation \"'Forall' x .. y , p\" :=\n  (lforall (fun x => .. (lforall (fun y => p)) .. )) (at level 78, x binder, y binder, right associativity).\nNotation \"'Exists' x .. y , p\" :=\n  (lexists (fun x => .. (lexists (fun y => p)) .. )) (at level 78, x binder, y binder, right associativity).\n\nClass ILogic Frm {ILOps: ILogicOps Frm} := {\n                                            lentailsPre:> PreOrder lentails;\n                                            ltrueR: forall C, C |-- ltrue;\n                                            lfalseL: forall C, lfalse |-- C;\n                                            lforallL: forall T x (P: T -> Frm) C, P x |-- C -> lforall P |-- C;\n                                            lforallR: forall T (P: T -> Frm) C, (forall x, C |-- P x) -> C |-- lforall P;\n                                            lexistsL: forall T (P: T -> Frm) C, (forall x, P x |-- C) -> lexists P |-- C;\n                                            lexistsR: forall T x (P: T -> Frm) C, C |-- P x -> C |-- lexists P;\n                                            landL1: forall P Q C, P |-- C  ->  P //\\\\ Q |-- C;\n                                            landL2: forall P Q C, Q |-- C  ->  P //\\\\ Q |-- C;\n                                            lorR1:  forall P Q C, C |-- P  ->  C |-- P \\\\// Q;\n                                            lorR2:  forall P Q C, C |-- Q  ->  C |-- P \\\\// Q;\n                                            landR:  forall P Q C, C |-- P  ->  C |-- Q  ->  C |-- P //\\\\ Q;\n                                            lorL:   forall P Q C, P |-- C  ->  Q |-- C  ->  P \\\\// Q |-- C;\n                                            landAdj: forall P Q C, C |-- (P -->> Q) -> C //\\\\ P |-- Q;\n                                            limplAdj: forall P Q C, C //\\\\ P |-- Q -> C |-- (P -->> Q)\n                                          }.\n\nSection ILogicExtra.\n  Context `{IL: ILogic Frm}.\n\n  Definition lequiv P Q := P |-- Q /\\ Q |-- P.\n  Definition lpropand (p: Prop) Q := Exists _: p, Q.\n  Definition lpropimpl (p: Prop) Q := Forall _: p, Q.\n\nEnd ILogicExtra.\n\nInfix \"/\\\\\" := lpropand (at level 75, right associativity).\nInfix \"->>\" := lpropimpl (at level 77, right associativity).\nInfix \"-|-\"  := lequiv (at level 85, no associativity).\n\nSection ILogicMorphisms.\n  Context `{IL: ILogic Frm}.\n\n  Global Instance lforall_lentails_m T:\n    Proper (pointwise_relation T lentails ++> lentails) lforall.\n  admit.\n  Defined.\n\n  Global Instance lexists_lentails_m T:\n    Proper (pointwise_relation T lentails ++> lentails) lexists.\n  admit.\n  Defined.\n\n  Global Instance land_lentails_m:\n    Proper (lentails ++> lentails ++> lentails) land.\n  admit.\n  Defined.\n\n  Global Instance lor_lentails_m:\n    Proper (lentails ++> lentails ++> lentails) lor.\n  admit.\n  Defined.\n\n  Global Instance lpropimpl_lentails_m:\n    Proper (impl --> lentails ++> lentails) lpropimpl.\n  admit.\n  Defined.\n\nEnd ILogicMorphisms.\n\nSection ILogic_Pre.\n  Context T (ord: relation T) {ord_Pre: PreOrder ord}.\n  Context `{IL: ILogic Frm}.\n\n  Record ILPreFrm := mkILPreFrm {\n                         ILPreFrm_pred :> T -> Frm;\n                         ILPreFrm_closed: forall t t': T, ord t t' ->\n                                                          ILPreFrm_pred t |-- ILPreFrm_pred t'\n                       }.\n\n  Notation \"'mk'\" := @ mkILPreFrm.\n\n  Global Instance ILPreFrm_m (P: ILPreFrm): Proper (ord ++> lentails) P.\n  admit.\n  Defined.\n\n  Local Obligation Tactic :=\n    repeat match goal with\n             | |- ord _ _ -> _ => intros Hord; try setoid_rewrite Hord; reflexivity\n             | |- _ => intro\n           end.\n\n  Program Definition ILPre_Ops : ILogicOps ILPreFrm := {|\n                                                        lentails P Q := forall t:T, P t |-- Q t;\n                                                        ltrue        := mk (fun t => ltrue) _;\n                                                        lfalse       := mk (fun t => lfalse) _;\n                                                        limpl    P Q := mk (fun t => Forall t', ord t t' ->> P t' -->> Q t') _;\n                                                        land     P Q := mk (fun t => P t //\\\\ Q t) _;\n                                                        lor      P Q := mk (fun t => P t \\\\// Q t) _;\n                                                        lforall  A P := mk (fun t => Forall a, P a t) _;\n                                                        lexists  A P := mk (fun t => Exists a, P a t) _\n                                                      |}.\n  Local Existing Instance ILPre_Ops.\n\n  Definition ILPre_ILogic : ILogic ILPreFrm.\n    admit.\n  Defined.\nEnd ILogic_Pre.\n\nImplicit Arguments ILPreFrm [T [ILOps]].\nImplicit Arguments mkILPreFrm [T ord Frm ILOps].\n\nSection ILogic_Fun.\n  Context (T: Type) `{TType: type T}.\n  Context `{IL: ILogic Frm}.\n\n  Record ILFunFrm := mkILFunFrm {\n                         ILFunFrm_pred :> T -> Frm;\n                         ILFunFrm_closed: forall t t': T, t === t' ->\n                                                          ILFunFrm_pred t |-- ILFunFrm_pred t'\n                       }.\n\n  Notation \"'mk'\" := @ mkILFunFrm.\n  Local Obligation Tactic := admit.\n  Program Definition ILFun_Ops : ILogicOps ILFunFrm := {|\n                                                        lentails P Q := forall t:T, P t |-- Q t;\n                                                        ltrue        := mk (fun t => ltrue) _;\n                                                        lfalse       := mk (fun t => lfalse) _;\n                                                        limpl    P Q := mk (fun t => P t -->> Q t) _;\n                                                        land     P Q := mk (fun t => P t //\\\\ Q t) _;\n                                                        lor      P Q := mk (fun t => P t \\\\// Q t) _;\n                                                        lforall  A P := mk (fun t => Forall a, P a t) _;\n                                                        lexists  A P := mk (fun t => Exists a, P a t) _\n                                                      |}.\n\nEnd ILogic_Fun.\n\nImplicit Arguments ILFunFrm [[ILOps] [e]].\nImplicit Arguments mkILFunFrm [T Frm ILOps].\n\nInstance ILogicOps_Prop : ILogicOps Prop | 2 := {|\n                                                 lentails P Q := P -> Q;\n                                                 ltrue        := True;\n                                                 lfalse       := False;\n                                                 limpl    P Q := P -> Q;\n                                                 land     P Q := P /\\ Q;\n                                                 lor      P Q := P \\/ Q;\n                                                 lforall  T F := forall x:T, F x;\n                                                 lexists  T F := exists x:T, F x\n                                               |}.\n\nInstance ILogic_Prop : ILogic Prop.\nadmit.\nDefined.\n\nSection FunEq.\n  Context A `{eT: type A}.\n\n  Global Instance FunEquiv {T} : Equiv (T -> A) := {\n                                                    equiv P Q := forall a, P a === Q a\n                                                  }.\nEnd FunEq.\nClass SepAlgOps T `{eT : type T}:= {\n                                    sa_unit : T;\n\n                                    sa_mul : T -> T -> T -> Prop\n                                  }.\n\nClass SepAlg T `{SAOps: SepAlgOps T} : Type := {\n                                                sa_mul_eqL a b c d : sa_mul a b c -> c === d -> sa_mul a b d;\n                                                sa_mul_eqR a b c d : sa_mul a b c -> sa_mul a b d -> c === d;\n                                                sa_mon a b c   : a === b -> sa_mul a c === sa_mul b c;\n                                                sa_mulC a b        : sa_mul a b === sa_mul b a;\n                                                sa_mulA a b c      : forall bc abc, sa_mul a bc abc -> sa_mul b c bc ->\n                                                                                    exists ac, sa_mul b ac abc /\\ sa_mul a c ac;\n                                                sa_unitI a         : sa_mul a sa_unit a\n                                              }.\n\nClass BILOperators (A : Type) := {\n                                  empSP : A;\n                                  sepSP : A -> A -> A;\n                                  wandSP : A -> A -> A\n                                }.\n\nNotation \"a '**' b\"  := (sepSP a b)\n                          (at level 75, right associativity).\n\nSection BISepAlg.\n  Context {A} `{sa : SepAlg A}.\n  Context {B} `{IL: ILogic B}.\n\n  Instance SABIOps: BILOperators (ILFunFrm A B) := {\n                                                    empSP := mkILFunFrm e (fun x => sa_unit === x /\\\\ ltrue) _;\n                                                    sepSP P Q := mkILFunFrm e (fun x => Exists x1, Exists x2, sa_mul x1 x2 x /\\\\\n                                                                                                                     P x1 //\\\\ Q x2) _;\n                                                    wandSP P Q := mkILFunFrm e (fun x => Forall x1, Forall x2, sa_mul x x1 x2 ->>\n                                                                                                                      P x1 -->> Q x2) _\n                                                  }.\n  admit.\n  admit.\n  admit.\n  Defined.\n\nEnd BISepAlg.\n\nSet Implicit Arguments.\n\nSection PFun.\n\n  Variable X Y : Type.\n\n  Definition splitsAs (f f1 f2: X -> option Y) :=\n    forall x,\n      match f x with\n        | Some y => (f1 x = Some y /\\ f2 x = None)\n                    \\/ (f2 x = Some y /\\ f1 x = None)\n        | _ => f1 x = None /\\ f2 x = None\n      end.\n\n  Definition empFun : X -> option Y := fun _ => None.\n\nEnd PFun.\n\nDefinition Flag  := BITS 5.\n\nInductive FlagVal := mkFlag (b: bool) | FlagUnspecified.\n\nDefinition Chan := BYTE.\n\nDefinition PTR := DWORD.\n\nInductive NonSPReg := EAX | EBX | ECX | EDX | ESI | EDI | EBP.\n\nInductive Reg := nonSPReg (r: NonSPReg) | ESP.\n\nInductive AnyReg := regToAnyReg (r: Reg) | EIP.\n\nInductive Frag := Registers | Memory | Flags | Traces.\nDefinition fragDom d :=\n  match d with\n    | Registers => AnyReg\n    | Memory => PTR\n    | Flags => Flag\n    | Traces => Chan\n  end.\n\nDefinition fragTgt d :=\n  match d with\n    | Registers => DWORD\n\n    | Memory => option BYTE\n\n    | Flags => FlagVal\n    | Traces => list (bool * BYTE)\n  end.\n\nDefinition PState := forall f: Frag, fragDom f -> option (fragTgt f).\n\nDefinition emptyPState : PState := fun _ => empFun _.\n\nInstance PStateEquiv : Equiv PState := {\n                                        equiv s1 s2 := forall f, s1 f = s2 f\n                                      }.\n\nInstance PStateType : type PState.\nadmit.\nDefined.\n\nInstance PStateSepAlgOps: SepAlgOps PState := {\n                                               sa_unit := emptyPState;\n                                               sa_mul s1 s2 s := forall f, splitsAs (s f) (s1 f) (s2 f)\n                                             }.\n\nDefinition SPred := ILFunFrm PState Prop.\n\nLocal Existing Instance ILFun_Ops.\nLocal Existing Instance SABIOps.\n\nImplicit Arguments mkILFunFrm [[e] [ILOps]].\n\nDefinition mkSPred (P : PState -> Prop)\n           (f : forall t t' : PState, t === t' -> P t |-- P t') : SPred :=\n  mkILFunFrm PState Prop P f.\n\nDefinition eq_pred s := mkSPred (fun s' => s === s') admit.\n\nDefinition extSP (P Q: SPred) := exists R, (P ** R) -|- Q.\nInstance extSP_Pre: PreOrder extSP.\nadmit.\nDefined.\n\nLocal Existing Instance ILPre_Ops.\nLocal Existing Instance ILPre_ILogic.\n\nDefinition spec := ILPreFrm ge (ILPreFrm extSP Prop).\n\nDefinition mkspec (f: nat -> SPred -> Prop)\n           (Hnat: forall k P, f (S k) P -> f k P)\n           (HSPred: forall k P P', extSP P P' -> f k P -> f k P') : spec.\nProof.\n  refine (mkILPreFrm (fun k => mkILPreFrm (f k) _) _).\n  simpl; admit.\n  Grab Existential Variables.\n  repeat intro.\n  eapply HSPred; eassumption.\nDefined.\n\nDefinition spec_fun (S: spec) := fun k P => S k P.\nCoercion spec_fun: spec >-> Funclass.\n\nDefinition spec_at (S: spec) (R: SPred) : spec.\nProof.\n  refine (mkspec (fun k P => S k (R ** P)) _ _); admit.\nDefined.\n\nInfix \"@ \" := spec_at (at level 44, left associativity).\n\nClass AtEx S := at_ex: forall A f, Forall x:A, S @  f x |-- S @  lexists f.\n\nModule slow.\n  Axiom AtEx_at : forall S R {HS: AtEx S}, AtEx (S @  R).\n  Local Hint Extern 1 (AtEx _) => apply AtEx_at : typeclass_instances.\n  Typeclasses eauto := debug.\n  Goal forall S R (HS : AtEx S) a, eq_pred a |-- R -> AtEx (S @  eq_pred a).\n  Proof.\n    Time typeclasses eauto.\n    (* : no match for (forall (S : spec) (R : SPred),\n                AtEx S ->\n                forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a))\n2 possibilities\n: no match for (forall R : SPred,\n                AtEx S ->\n                forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a))\n2 possibilities\n: no match for (AtEx S ->\n                forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a))\n2 possibilities\n: no match for (forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a))\n3 possibilities\n: no match for (eq_pred a |-- R -> AtEx (S @  eq_pred a))\n3 possibilities\n1: (*external*) apply AtEx_at on\n(AtEx (S @  eq_pred a))\n1.1.1: exact HS on\n(AtEx S)\nno backtrack on (AtEx S) after normevars\nno backtrack on (AtEx S) after (*external*)\nno backtrack on (AtEx (S @  eq_pred a)) after intro\nno backtrack on (eq_pred a |-- R -> AtEx (S @  eq_pred a)) after intro\nno backtrack on (forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a)) after intro\nno backtrack on (AtEx S ->\n                 forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a)) after intro\nno backtrack on (forall R : SPred,\n                 AtEx S ->\n                 forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a)) after intro\nNo more subgoals.\n\n(dependent evars:)\nFinished transaction in 1. secs (1.260079u,0.s) *)\n    Undo.\n    Time intros; typeclasses eauto.\n    (* 1: (*external*) apply AtEx_at on\n(AtEx (S @  eq_pred a))\n1.1.1: exact HS on\n(AtEx S)\nno backtrack on (AtEx S) after normevars\nno backtrack on (AtEx S) after (*external*)\nNo more subgoals.\n\n(dependent evars:)\nFinished transaction in 0. secs (0.u,0.s) *)\n    Undo.\n    Fail Timeout 1 typeclasses eauto. (* Timeout! *)\n  Admitted.\nEnd slow.\n\nModule fast.\n  Axiom AtEx_at : forall S R {HS: AtEx S}, AtEx (S @  R).\n  Local Hint Extern 1 AtEx => apply AtEx_at : typeclass_instances.\n  Typeclasses eauto := debug.\n  Goal forall S R (HS : AtEx S) a, eq_pred a |-- R -> AtEx (S @  eq_pred a).\n  Proof.\n    Time typeclasses eauto. (* : no match for (forall (S : spec) (R : SPred),\n                AtEx S ->\n                forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a))\n2 possibilities\n: no match for (forall R : SPred,\n                AtEx S ->\n                forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a))\n2 possibilities\n: no match for (AtEx S ->\n                forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a))\n2 possibilities\n: no match for (forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a))\n3 possibilities\n: no match for (eq_pred a |-- R -> AtEx (S @  eq_pred a))\n3 possibilities\n1: apply AtEx_at on\n(AtEx (S @  eq_pred a))\n1.1.1: exact HS on\n(AtEx S)\nno backtrack on (AtEx S) after normevars\nno backtrack on (AtEx S) after apply AtEx_at\nno backtrack on (AtEx (S @  eq_pred a)) after intro\nno backtrack on (eq_pred a |-- R -> AtEx (S @  eq_pred a)) after intro\nno backtrack on (forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a)) after intro\nno backtrack on (AtEx S ->\n                 forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a)) after intro\nno backtrack on (forall R : SPred,\n                 AtEx S ->\n                 forall a : PState, eq_pred a |-- R -> AtEx (S @  eq_pred a)) after intro\nNo more subgoals.\n\n(dependent evars:)\nFinished transaction in 0. secs (0.u,0.s)\n *)\n  Defined.\nEnd fast.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521289/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521292","html_url":"https://github.com/coq/coq/issues/3448#issuecomment-337521292","issue_url":"https://api.github.com/repos/coq/coq/issues/3448","id":337521292,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTI5Mg==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-03-08T17:25:16Z","updated_at":"2017-10-18T09:23:35Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\n\nIt seems to be an issue in unification.\n\n","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521292/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521293","html_url":"https://github.com/coq/coq/issues/3448#issuecomment-337521293","issue_url":"https://api.github.com/repos/coq/coq/issues/3448","id":337521293,"node_id":"MDEyOklzc3VlQ29tbWVudDMzNzUyMTI5Mw==","user":{"login":"coqbot","id":13040781,"node_id":"MDQ6VXNlcjEzMDQwNzgx","avatar_url":"https://avatars.githubusercontent.com/u/13040781?v=4","gravatar_id":"","url":"https://api.github.com/users/coqbot","html_url":"https://github.com/coqbot","followers_url":"https://api.github.com/users/coqbot/followers","following_url":"https://api.github.com/users/coqbot/following{/other_user}","gists_url":"https://api.github.com/users/coqbot/gists{/gist_id}","starred_url":"https://api.github.com/users/coqbot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/coqbot/subscriptions","organizations_url":"https://api.github.com/users/coqbot/orgs","repos_url":"https://api.github.com/users/coqbot/repos","events_url":"https://api.github.com/users/coqbot/events{/privacy}","received_events_url":"https://api.github.com/users/coqbot/received_events","type":"User","site_admin":false},"created_at":"2015-03-08T22:09:14Z","updated_at":"2021-12-26T21:50:20Z","author_association":"CONTRIBUTOR","body":"Comment author: @ppedrot\r\n\r\nHere is a a shorter version of the example:\r\n\r\n```coq\r\nRequire Program.Tactics.\r\nGeneralizable All Variables.\r\n\r\nClass ILogicOps Frm := {\r\n                        lentails: Frm -> Frm -> Prop;\r\n                        lforall: forall {T}, (T -> Frm) -> Frm;\r\n                        lexists: forall {T}, (T -> Frm) -> Frm\r\n                      }.\r\n\r\nInfix \"|--\"  := lentails (at level 79, no associativity).\r\nNotation \"'Forall' x .. y , p\" :=\r\n  (lforall (fun x => .. (lforall (fun y => p)) .. )) (at level 78, x binder, y binder, right associativity).\r\nNotation \"'Exists' x .. y , p\" :=\r\n  (lexists (fun x => .. (lexists (fun y => p)) .. )) (at level 78, x binder, y binder, right associativity).\r\n\r\nSection ILogic_Pre.\r\n  Context (T : Type) .\r\n  Context `{ILOps: ILogicOps Frm}.\r\n\r\n  Record ILPreFrm := mkILPreFrm {\r\n                         ILPreFrm_pred :> T -> Frm;\r\n                         ILPreFrm_closed: forall t t': T,\r\n                                                          ILPreFrm_pred t |-- ILPreFrm_pred t'\r\n                       }.\r\n\r\n  Notation \"'mk'\" := @ mkILPreFrm.\r\n\r\n  Program Definition ILPre_Ops : ILogicOps ILPreFrm := {|\r\n                                                        lentails P Q := forall t:T, P t |-- Q t;\r\n                                                        lforall  A P := mk (fun t => Forall a, P a t) _;\r\n                                                        lexists  A P := mk (fun t => Exists a, P a t) _\r\n                                                      |}.\r\n  Admit Obligations.\r\n\r\nEnd ILogic_Pre.\r\n\r\nImplicit Arguments ILPreFrm [T [ILOps]].\r\nImplicit Arguments mkILPreFrm [T Frm ILOps].\r\n\r\nSection ILogic_Fun.\r\n  Context (T: Type).\r\n  Context `{ILOps: ILogicOps Frm}.\r\n\r\n  Definition ILFunFrm := T -> Frm .\r\n\r\n  Program Definition ILFun_Ops : ILogicOps ILFunFrm := {|\r\n                                                        lentails P Q := forall t:T, P t |-- Q t;\r\n                                                        lforall  A P := (fun t => Forall a, P a t);\r\n                                                        lexists  A P := (fun t => Exists a, P a t)\r\n                                                      |}.\r\n\r\nEnd ILogic_Fun.\r\n\r\nSet Implicit Arguments.\r\n\r\nAxiom PState : Type.\r\nDefinition SPred := @ ILFunFrm PState Prop.\r\nAxiom sepSP : SPred -> SPred -> SPred.\r\nAxiom eq_pred : PState -> SPred.\r\n\r\nLocal Existing Instance ILFun_Ops.\r\nLocal Existing Instance ILPre_Ops.\r\n\r\nInstance ILogicOps_Prop : ILogicOps Prop | 2 := {|\r\n                                                 lentails := fun (P : Prop) (Q : Prop) => P -> Q;\r\n                                                 lforall  T F := forall x:T, F x;\r\n                                                 lexists  T F := exists x:T, F x\r\n                                               |}.\r\n\r\nDefinition spec := @ ILPreFrm nat (@ ILPreFrm SPred Prop _) _.\r\n\r\nDefinition mkspec (f: nat -> SPred -> Prop)\r\n           (HSPred: forall k P P', f k P -> f k P') : spec.\r\nProof.\r\n  refine (mkILPreFrm (fun k => mkILPreFrm (f k) _) _).\r\n  repeat intro.\r\n  eapply HSPred; eassumption.\r\n  simpl. admit.\r\nDefined.\r\n\r\nDefinition spec_fun (S: spec) := fun k P => S k P.\r\nCoercion spec_fun: spec >-> Funclass.\r\n\r\nDefinition spec_at (S: spec) (R: SPred) : spec.\r\nProof.\r\n  refine (mkspec (fun k P => S k (sepSP R P)) _); admit.\r\nDefined.\r\n\r\nInfix \"@ \" := spec_at (at level 44, left associativity).\r\n\r\nClass AtEx S := at_ex: forall A f, Forall x:A, S @  f x |-- S @  lexists f.\r\n\r\nModule slow.\r\n  Axiom AtEx_at : forall S R {HS: AtEx S}, AtEx (S @  R).\r\n  Local Hint Extern 1 (AtEx _) => apply AtEx_at : typeclass_instances.\r\n  Typeclasses eauto := debug.\r\n  Goal forall S R (HS : AtEx S) a, eq_pred a |-- R -> AtEx (S @  eq_pred a).\r\n  Proof.\r\n    Time typeclasses eauto.\r\n    Undo.\r\n    Time intros; typeclasses eauto.\r\n    Undo.\r\n    Fail Timeout 1 typeclasses eauto. (* Timeout! *)\r\n  Admitted.\r\nEnd slow.\r\n\r\nModule fast.\r\n  Axiom AtEx_at : forall S R {HS: AtEx S}, AtEx (S @  R).\r\n  Local Hint Extern 1 AtEx => apply AtEx_at : typeclass_instances.\r\n  Typeclasses eauto := debug.\r\n  Goal forall S R (HS : AtEx S) a, eq_pred a |-- R -> AtEx (S @  eq_pred a).\r\n  Proof.\r\n    Time typeclasses eauto.\r\n  Defined.\r\nEnd fast.\r\n```","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/337521293/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null},{"url":"https://api.github.com/repos/coq/coq/issues/comments/1040457712","html_url":"https://github.com/coq/coq/issues/3448#issuecomment-1040457712","issue_url":"https://api.github.com/repos/coq/coq/issues/3448","id":1040457712,"node_id":"IC_kwDOABUDh84-BB_w","user":{"login":"ppedrot","id":1202327,"node_id":"MDQ6VXNlcjEyMDIzMjc=","avatar_url":"https://avatars.githubusercontent.com/u/1202327?v=4","gravatar_id":"","url":"https://api.github.com/users/ppedrot","html_url":"https://github.com/ppedrot","followers_url":"https://api.github.com/users/ppedrot/followers","following_url":"https://api.github.com/users/ppedrot/following{/other_user}","gists_url":"https://api.github.com/users/ppedrot/gists{/gist_id}","starred_url":"https://api.github.com/users/ppedrot/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ppedrot/subscriptions","organizations_url":"https://api.github.com/users/ppedrot/orgs","repos_url":"https://api.github.com/users/ppedrot/repos","events_url":"https://api.github.com/users/ppedrot/events{/privacy}","received_events_url":"https://api.github.com/users/ppedrot/received_events","type":"User","site_admin":false},"created_at":"2022-02-15T16:02:00Z","updated_at":"2022-02-15T16:02:00Z","author_association":"MEMBER","body":"I can't reproduce on a modern Coq version, closing.","reactions":{"url":"https://api.github.com/repos/coq/coq/issues/comments/1040457712/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"performed_via_github_app":null}]