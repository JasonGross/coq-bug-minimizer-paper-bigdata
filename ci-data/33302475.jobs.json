{"id":109291077,"status":"success","stage":"test","name":"ci-mtac2","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T15:10:21.880Z","started_at":"2018-10-17T15:10:22.094Z","finished_at":"2018-10-17T15:14:25.187Z","duration":243.093149,"queued_duration":0.191873,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109291077","artifacts":[{"file_type":"trace","size":175422,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272954,"status":"success","stage":"test","name":"ci-vst","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.917Z","started_at":"2018-10-17T15:03:22.114Z","finished_at":"2018-10-17T16:11:04.826Z","duration":4062.711691,"queued_duration":1.938631,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272954","artifacts":[{"file_type":"trace","size":228655,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272953,"status":"success","stage":"test","name":"ci-unimath","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.896Z","started_at":"2018-10-17T15:03:22.072Z","finished_at":"2018-10-17T15:32:18.583Z","duration":1736.510811,"queued_duration":1.705724,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272953","artifacts":[{"file_type":"trace","size":165605,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272952,"status":"success","stage":"test","name":"ci-sf","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.876Z","started_at":"2018-10-17T15:03:22.033Z","finished_at":"2018-10-17T15:08:35.263Z","duration":313.230128,"queued_duration":1.393424,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272952","artifacts":[{"file_type":"trace","size":273205,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272950,"status":"success","stage":"test","name":"ci-quickchick","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.856Z","started_at":"2018-10-17T15:03:21.942Z","finished_at":"2018-10-17T15:09:55.462Z","duration":393.519522,"queued_duration":0.956288,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272950","artifacts":[{"file_type":"trace","size":270530,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272949,"status":"failed","stage":"test","name":"ci-plugin-tutorial","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.835Z","started_at":"2018-10-17T15:03:21.784Z","finished_at":"2018-10-17T15:06:55.692Z","duration":213.908057,"queued_duration":0.262629,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"failure_reason":"script_failure","web_url":"https://gitlab.com/coq/coq/-/jobs/109272949","artifacts":[{"file_type":"trace","size":35657,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272948,"status":"success","stage":"test","name":"ci-pidetop","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.815Z","started_at":"2018-10-17T15:03:55.282Z","finished_at":"2018-10-17T15:07:40.309Z","duration":225.027183,"queued_duration":33.014982,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272948","artifacts":[{"file_type":"trace","size":33125,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272946,"status":"success","stage":"test","name":"ci-math-comp","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.774Z","started_at":"2018-10-17T15:03:54.535Z","finished_at":"2018-10-17T15:56:13.899Z","duration":3139.364341,"queued_duration":31.512073,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272946","artifacts":[{"file_type":"trace","size":365745,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272945,"status":"success","stage":"test","name":"ci-ltac2","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.754Z","started_at":"2018-10-17T15:03:23.444Z","finished_at":"2018-10-17T15:06:24.596Z","duration":181.151301,"queued_duration":0.226362,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272945","artifacts":[{"file_type":"trace","size":75605,"filename":"job.log","file_format":null}],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":109272944,"status":"success","stage":"test","name":"ci-iris-lambda-rust","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.733Z","started_at":"2018-10-17T15:03:54.416Z","finished_at":"2018-10-17T16:14:24.346Z","duration":4229.929963,"queued_duration":30.98807,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272944","artifacts":[{"file_type":"trace","size":294349,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272943,"status":"success","stage":"test","name":"ci-hott","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.713Z","started_at":"2018-10-17T15:03:23.806Z","finished_at":"2018-10-17T15:14:40.992Z","duration":677.185713,"queued_duration":0.147813,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272943","artifacts":[{"file_type":"trace","size":130369,"filename":"job.log","file_format":null}],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":109272942,"status":"success","stage":"test","name":"ci-geocoq","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.693Z","started_at":"2018-10-17T15:03:54.360Z","finished_at":"2018-10-17T16:09:29.702Z","duration":3935.34191,"queued_duration":30.509962,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272942","artifacts":[{"file_type":"trace","size":341216,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272941,"status":"success","stage":"test","name":"ci-formal-topology","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.673Z","started_at":"2018-10-17T15:03:24.147Z","finished_at":"2018-10-17T15:31:44.343Z","duration":1700.196167,"queued_duration":0.12863,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272941","artifacts":[{"file_type":"trace","size":613070,"filename":"job.log","file_format":null}],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":109272940,"status":"success","stage":"test","name":"ci-flocq","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.654Z","started_at":"2018-10-17T15:03:53.828Z","finished_at":"2018-10-17T15:19:52.309Z","duration":958.480948,"queued_duration":29.700623,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272940","artifacts":[{"file_type":"trace","size":38004,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272938,"status":"success","stage":"test","name":"ci-fiat-parsers","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.633Z","started_at":"2018-10-17T15:03:53.478Z","finished_at":"2018-10-17T15:23:36.492Z","duration":1183.013903,"queued_duration":29.258203,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272938","artifacts":[{"file_type":"trace","size":241548,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272937,"status":"failed","stage":"test","name":"ci-fiat-crypto-legacy","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.612Z","started_at":"2018-10-17T15:03:53.498Z","finished_at":"2018-10-17T16:00:16.998Z","duration":3383.500547,"queued_duration":29.206444,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"failure_reason":"script_failure","web_url":"https://gitlab.com/coq/coq/-/jobs/109272937","artifacts":[{"file_type":"trace","size":154668,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272936,"status":"success","stage":"test","name":"ci-fiat-crypto","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.591Z","started_at":"2018-10-17T15:03:53.372Z","finished_at":"2018-10-17T15:50:51.759Z","duration":2818.387119,"queued_duration":29.022367,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272936","artifacts":[{"file_type":"trace","size":869712,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272935,"status":"success","stage":"test","name":"ci-fcsl-pcm","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.568Z","started_at":"2018-10-17T15:03:53.178Z","finished_at":"2018-10-17T15:09:03.894Z","duration":310.715299,"queued_duration":28.754128,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272935","artifacts":[{"file_type":"trace","size":135293,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272934,"status":"success","stage":"test","name":"ci-equations","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.546Z","started_at":"2018-10-17T15:03:24.515Z","finished_at":"2018-10-17T15:09:07.409Z","duration":342.894843,"queued_duration":0.046846,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272934","artifacts":[{"file_type":"trace","size":115200,"filename":"job.log","file_format":null}],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":109272933,"status":"success","stage":"test","name":"ci-elpi","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.525Z","started_at":"2018-10-17T15:03:53.006Z","finished_at":"2018-10-17T15:09:05.960Z","duration":312.95387,"queued_duration":28.496375,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272933","artifacts":[{"file_type":"trace","size":474799,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272932,"status":"success","stage":"test","name":"ci-cross-crypto","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.503Z","started_at":"2018-10-17T15:03:24.727Z","finished_at":"2018-10-17T15:43:36.459Z","duration":2411.732134,"queued_duration":0.171846,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272932","artifacts":[{"file_type":"trace","size":47496,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272931,"status":"success","stage":"test","name":"ci-coquelicot","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.481Z","started_at":"2018-10-17T15:03:52.944Z","finished_at":"2018-10-17T15:11:04.133Z","duration":431.188857,"queued_duration":28.3512,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272931","artifacts":[{"file_type":"trace","size":137812,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272930,"status":"success","stage":"test","name":"ci-coq-dpdgraph","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.460Z","started_at":"2018-10-17T15:03:52.601Z","finished_at":"2018-10-17T15:07:46.134Z","duration":233.533162,"queued_duration":27.962003,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272930","artifacts":[{"file_type":"trace","size":44631,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272929,"status":"success","stage":"test","name":"ci-compcert","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.438Z","started_at":"2018-10-17T15:03:24.867Z","finished_at":"2018-10-17T15:34:55.872Z","duration":1891.005527,"queued_duration":0.175565,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272929","artifacts":[{"file_type":"trace","size":2049285,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272928,"status":"success","stage":"test","name":"ci-color","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.415Z","started_at":"2018-10-17T15:03:52.520Z","finished_at":"2018-10-17T15:26:11.695Z","duration":1339.175481,"queued_duration":27.759846,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272928","artifacts":[{"file_type":"trace","size":230515,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272927,"status":"success","stage":"test","name":"ci-bignums","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.392Z","started_at":"2018-10-17T15:03:52.382Z","finished_at":"2018-10-17T15:09:27.724Z","duration":335.342018,"queued_duration":27.545603,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272927","artifacts":[{"file_type":"trace","size":58138,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272926,"status":"failed","stage":"test","name":"ci-bedrock2","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":true,"created_at":"2018-10-17T14:34:23.368Z","started_at":"2018-10-17T15:03:51.500Z","finished_at":"2018-10-17T15:26:20.139Z","duration":1348.638265,"queued_duration":26.594065,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"failure_reason":"script_failure","web_url":"https://gitlab.com/coq/coq/-/jobs/109272926","artifacts":[{"file_type":"trace","size":53837,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272925,"status":"success","stage":"test","name":"ci-aac-tactics","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.348Z","started_at":"2018-10-17T15:03:51.451Z","finished_at":"2018-10-17T15:07:52.659Z","duration":241.208125,"queued_duration":26.383785,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272925","artifacts":[{"file_type":"trace","size":55195,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272924,"status":"success","stage":"test","name":"validate:edge+flambda","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.326Z","started_at":"2018-10-17T15:03:50.894Z","finished_at":"2018-10-17T15:13:18.545Z","duration":567.651288,"queued_duration":25.755445,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272924","artifacts":[{"file_type":"trace","size":24945,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272923,"status":"success","stage":"test","name":"validate:edge","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.305Z","started_at":"2018-10-17T15:03:50.830Z","finished_at":"2018-10-17T15:12:39.169Z","duration":528.338574,"queued_duration":25.626854,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272923","artifacts":[{"file_type":"trace","size":24002,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272922,"status":"success","stage":"test","name":"validate:base+32bit","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.285Z","started_at":"2018-10-17T15:03:50.261Z","finished_at":"2018-10-17T15:12:27.316Z","duration":517.054624,"queued_duration":24.765995,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272922","artifacts":[{"file_type":"trace","size":23317,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272921,"status":"success","stage":"test","name":"validate:base","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.264Z","started_at":"2018-10-17T15:03:50.021Z","finished_at":"2018-10-17T15:12:56.873Z","duration":546.851182,"queued_duration":24.24236,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272921","artifacts":[{"file_type":"trace","size":24413,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272920,"status":"success","stage":"test","name":"test-suite:egde:dune:dev","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.244Z","started_at":"2018-10-17T15:03:49.854Z","finished_at":"2018-10-17T15:25:40.449Z","duration":1310.595428,"queued_duration":23.963195,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272920","artifacts":[{"file_type":"trace","size":72723,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272919,"status":"success","stage":"test","name":"test-suite:edge+flambda","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.223Z","started_at":"2018-10-17T15:03:49.762Z","finished_at":"2018-10-17T15:17:34.205Z","duration":824.443123,"queued_duration":23.77006,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272919","artifacts":[{"file_type":"trace","size":73840,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272918,"status":"success","stage":"test","name":"test-suite:edge","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.201Z","started_at":"2018-10-17T15:03:26.343Z","finished_at":"2018-10-17T15:15:02.419Z","duration":696.076741,"queued_duration":0.214284,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272918","artifacts":[{"file_type":"trace","size":72897,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272917,"status":"success","stage":"test","name":"test-suite:base+32bit","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.178Z","started_at":"2018-10-17T15:03:34.864Z","finished_at":"2018-10-17T15:14:11.620Z","duration":636.756646,"queued_duration":8.653649,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272917","artifacts":[{"file_type":"trace","size":72275,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272916,"status":"success","stage":"test","name":"test-suite:base","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.156Z","started_at":"2018-10-17T15:03:34.819Z","finished_at":"2018-10-17T15:15:22.134Z","duration":707.315215,"queued_duration":8.569277,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272916","artifacts":[{"file_type":"trace","size":73308,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272914,"status":"success","stage":"test","name":"doc:ml-api:odoc","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.133Z","started_at":"2018-10-17T15:03:33.910Z","finished_at":"2018-10-17T15:08:23.943Z","duration":290.033443,"queued_duration":7.617988,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272914","artifacts":[{"file_type":"trace","size":45983,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272913,"status":"success","stage":"test","name":"doc:refman","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.112Z","started_at":"2018-10-17T15:03:27.782Z","finished_at":"2018-10-17T15:10:57.863Z","duration":450.081148,"queued_duration":1.446951,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272913","artifacts":[{"file_type":"trace","size":950887,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272912,"status":"success","stage":"test","name":"pkg:nix","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.090Z","started_at":"2018-10-17T15:03:27.399Z","finished_at":"2018-10-17T15:34:31.058Z","duration":1863.659203,"queued_duration":1.014343,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272912","artifacts":[{"file_type":"trace","size":656586,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272911,"status":"success","stage":"test","name":"pkg:opam","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.070Z","started_at":"2018-10-17T15:03:27.020Z","finished_at":"2018-10-17T15:18:04.979Z","duration":877.9586,"queued_duration":0.553317,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272911","artifacts":[{"file_type":"trace","size":22613,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":109272910,"status":"success","stage":"test","name":"windows64","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:23.043Z","started_at":"2018-10-17T15:03:27.127Z","finished_at":"2018-10-17T15:54:12.400Z","duration":3045.273615,"queued_duration":0.598368,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272910","artifacts":[{"file_type":"trace","size":373000,"filename":"job.log","file_format":null}],"runner":null,"artifacts_expire_at":"2018-10-24T15:54:05.509Z","tag_list":["windows"]}
{"id":109272909,"status":"success","stage":"build","name":"build:egde:dune:dev","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:22.963Z","started_at":"2018-10-17T14:34:25.222Z","finished_at":"2018-10-17T14:50:57.084Z","duration":991.86172,"queued_duration":1.105053,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272909","artifacts":[{"file_type":"trace","size":21345,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":"2018-10-24T14:50:52.246Z","tag_list":[]}
{"id":109272907,"status":"success","stage":"build","name":"build:edge+flambda","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:22.935Z","started_at":"2018-10-17T14:34:25.168Z","finished_at":"2018-10-17T15:03:19.382Z","duration":1734.214758,"queued_duration":1.019295,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272907","artifacts":[{"file_type":"trace","size":235708,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":"2018-10-24T15:03:09.047Z","tag_list":[]}
{"id":109272906,"status":"success","stage":"build","name":"build:edge","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:22.906Z","started_at":"2018-10-17T14:34:24.770Z","finished_at":"2018-10-17T14:52:17.082Z","duration":1072.312339,"queued_duration":0.588158,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272906","artifacts":[{"file_type":"trace","size":234508,"filename":"job.log","file_format":null}],"runner":{"id":380987,"description":"shared-runners-manager-6.gitlab.com","ip_address":"34.74.239.13","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":"2018-10-24T14:52:11.502Z","tag_list":[]}
{"id":109272905,"status":"success","stage":"build","name":"build:base+32bit","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:22.875Z","started_at":"2018-10-17T14:34:24.661Z","finished_at":"2018-10-17T14:50:06.574Z","duration":941.912629,"queued_duration":0.437726,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272905","artifacts":[{"file_type":"trace","size":229738,"filename":"job.log","file_format":null}],"runner":{"id":44028,"description":"shared-runners-manager-3.gitlab.com","ip_address":"35.196.21.178","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":"2018-10-24T14:50:01.214Z","tag_list":[]}
{"id":109272904,"status":"success","stage":"build","name":"build:base","ref":"pr-8741","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-10-17T14:34:22.845Z","started_at":"2018-10-17T14:34:24.547Z","finished_at":"2018-10-17T14:52:39.132Z","duration":1094.584329,"queued_duration":0.298067,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"681fe586409ac09b8900295dcd8d51c579d69b1e","short_id":"681fe586","created_at":"2018-10-17T16:33:56.000+02:00","parent_ids":["5fdea165e89b025334af06e0a8ae9f0ac4840fdb"],"title":"[typeclasses] functionalize typeclass evar handling","message":"[typeclasses] functionalize typeclass evar handling\n\nThis avoids all the side effects associated with the manipulation of an\nunresolvable flag. In the new design:\n\n- The evar_map stores a set of evars that are candidates for typeclass\n  resolution, which can be retrieved and set.\n\n  We maintain the invariant that it always contains only undefined\n  evars.\n\n- At the creation time of an evar (new_evar), we classify it as a\n  potential candidate of resolution.\n\n  - This uses a hook to test if the conclusion ends in a typeclass\n    application. (hook set in typeclasses.ml)\n\n  - This is an approximation if the conclusion is an existential (i.e.\n    not yet determined). In that case we register the evar as\n    potentially a typeclass instance, and later phases must consider\n    that case, dropping the evar if it is not a typeclass.\n\n  - One can pass the ~typeclass_candidate:false flag to new_evar to\n    prevent classification entirely. Typically this is for new goals\n    which should not ever be considered to be typeclass resolution\n    candidates.\n\n  - One can mark a subset of evars unresolvable later if\n    needed. Typically for clausenv, and marking future goals as\n    unresolvable even if they are typeclass goals. For clausenv for\n    example, after turing metas into evars we first (optionally) try a\n    typeclass resolution on the newly created evars and only then mark\n    the remaining newly created evars as subgoals. The intent of the\n    code looks clearer now.\n\n  This should prevent keeping testing if undefined evars are classes\n  all the time and crawling large sets when no typeclasses are present.\n\n- Typeclass candidate evars stay candidates through\n  restriction/evar-evar solutions.\n\n- Evd.add uses ~typeclass_candidate:false to avoid recomputing if the new\n  evar is a candidate. There's a deficiency in the API, in most use\n  cases of Evd.add we should rather use a:\n\n  `Evd.update_evar_info : evar_map -> Evar.t -> (evar_info -> evar_info)\n  -> evar_map`\n\n  Usually it is only about nf_evar'ing the evar_info's contents, which\n  doesn't change the evar candidate status.\n\n- Typeclass resolution can now handle the set of candidates\n  functionally: it always starts from the set of candidates (and not the\n  whole undefined_map) and a filter on it, potentially splitting it in\n  connected components, does proof search for each component in an\n  evar_map with an empty set of typeclass evars (allowing clean\n  reentrancy), then reinstates the potential remaining unsolved\n  components and filtered out typeclass evars at the end of\n  resolution.\n\n  This means no more marking of resolvability/unresolvability\n  everywhere, and hopefully a more efficient implementation in general.\n\n- This is on top of the cleanup of evar_info's currently but can\n  be made independent.\n\n[typeclasses] Fix cases.ml: none of the new_evars should be typeclass candidates\n\nSolve bug in inheritance of flags in evar-evar solutions.\n\nRenaming unresolvable to typeclass_candidate (positive) and fix maybe_typeclass_hook\n","author_name":"Matthieu Sozeau","author_email":"matthieu.sozeau@inria.fr","authored_date":"2018-10-16T12:30:59.000+02:00","committer_name":"Matthieu Sozeau","committer_email":"matthieu.sozeau@inria.fr","committed_date":"2018-10-17T16:33:56.000+02:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/681fe586409ac09b8900295dcd8d51c579d69b1e"},"pipeline":{"id":33302475,"iid":4449,"project_id":6138686,"sha":"681fe586409ac09b8900295dcd8d51c579d69b1e","ref":"pr-8741","status":"failed","source":"push","created_at":"2018-10-17T14:34:22.824Z","updated_at":"2018-10-17T16:14:24.555Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/33302475"},"web_url":"https://gitlab.com/coq/coq/-/jobs/109272904","artifacts":[{"file_type":"trace","size":277736,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":"2018-10-24T14:52:31.858Z","tag_list":[]}
