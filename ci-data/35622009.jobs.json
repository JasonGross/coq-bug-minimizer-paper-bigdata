{"id":117113051,"status":"skipped","stage":"test","name":"ci-vst","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:15.939Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113051","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113049,"status":"skipped","stage":"test","name":"ci-unimath","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:15.904Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113049","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113039,"status":"skipped","stage":"test","name":"ci-sf","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:15.576Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113039","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113036,"status":"skipped","stage":"test","name":"ci-quickchick","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:15.285Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113036","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113034,"status":"skipped","stage":"test","name":"ci-plugin-tutorial","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:15.150Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113034","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113032,"status":"skipped","stage":"test","name":"ci-pidetop","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:15.071Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113032","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113029,"status":"skipped","stage":"test","name":"ci-mtac2","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:13.968Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113029","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113027,"status":"skipped","stage":"test","name":"ci-math-comp","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:13.374Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113027","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113026,"status":"skipped","stage":"test","name":"ci-ltac2","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:12.991Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113026","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113025,"status":"skipped","stage":"test","name":"ci-iris-lambda-rust","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:12.869Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113025","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113021,"status":"skipped","stage":"test","name":"ci-hott","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:12.103Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113021","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113020,"status":"skipped","stage":"test","name":"ci-geocoq","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:12.035Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113020","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113014,"status":"skipped","stage":"test","name":"ci-formal-topology","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:11.667Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113014","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113002,"status":"skipped","stage":"test","name":"ci-flocq","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:11.190Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113002","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117113000,"status":"skipped","stage":"test","name":"ci-fiat-parsers","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:11.128Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117113000","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112988,"status":"skipped","stage":"test","name":"ci-fiat-crypto-legacy","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:10.745Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112988","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112986,"status":"skipped","stage":"test","name":"ci-fiat-crypto","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:10.354Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112986","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112985,"status":"skipped","stage":"test","name":"ci-fcsl-pcm","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:10.318Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112985","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112984,"status":"skipped","stage":"test","name":"ci-equations","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:10.268Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112984","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112983,"status":"skipped","stage":"test","name":"ci-elpi","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:10.227Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112983","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112977,"status":"skipped","stage":"test","name":"ci-cross-crypto","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:09.614Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112977","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112972,"status":"skipped","stage":"test","name":"ci-coquelicot","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:09.257Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112972","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112970,"status":"skipped","stage":"test","name":"ci-coq-dpdgraph","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:09.206Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112970","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112969,"status":"skipped","stage":"test","name":"ci-compcert","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:09.180Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112969","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112968,"status":"skipped","stage":"test","name":"ci-color","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:09.117Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112968","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112964,"status":"skipped","stage":"test","name":"ci-bignums","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:08.476Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112964","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112963,"status":"skipped","stage":"test","name":"ci-bedrock2","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":true,"created_at":"2018-11-06T16:03:08.451Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112963","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112962,"status":"skipped","stage":"test","name":"ci-aac-tactics","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:08.426Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112962","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112961,"status":"skipped","stage":"test","name":"validate:edge+flambda","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:08.402Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112961","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112960,"status":"skipped","stage":"test","name":"validate:edge","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:08.111Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112960","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112958,"status":"skipped","stage":"test","name":"validate:base+32bit","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:07.859Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112958","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112955,"status":"skipped","stage":"test","name":"validate:base","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:07.666Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112955","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112953,"status":"skipped","stage":"test","name":"test-suite:egde:dune:dev","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:07.558Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112953","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112950,"status":"skipped","stage":"test","name":"test-suite:edge+flambda","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:07.228Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112950","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112949,"status":"skipped","stage":"test","name":"test-suite:edge","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:06.988Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112949","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112948,"status":"skipped","stage":"test","name":"test-suite:base+32bit","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:06.948Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112948","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112944,"status":"skipped","stage":"test","name":"test-suite:base","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:06.569Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112944","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112937,"status":"skipped","stage":"test","name":"doc:ml-api:odoc","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:06.236Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112937","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112931,"status":"skipped","stage":"test","name":"doc:refman","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:06.055Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112931","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112930,"status":"skipped","stage":"test","name":"pkg:nix","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:05.992Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112930","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112928,"status":"skipped","stage":"test","name":"pkg:opam","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:05.755Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112928","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":[]}
{"id":117112923,"status":"skipped","stage":"test","name":"windows64","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:04.837Z","started_at":null,"finished_at":null,"duration":null,"queued_duration":null,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"web_url":"https://gitlab.com/coq/coq/-/jobs/117112923","artifacts":[],"runner":null,"artifacts_expire_at":null,"tag_list":["windows"]}
{"id":117112918,"status":"failed","stage":"build","name":"build:egde:dune:dev","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:04.514Z","started_at":"2018-11-06T16:57:19.034Z","finished_at":"2018-11-06T17:14:48.021Z","duration":1048.987611,"queued_duration":3230.97081,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"failure_reason":"script_failure","web_url":"https://gitlab.com/coq/coq/-/jobs/117112918","artifacts":[{"file_type":"trace","size":20270,"filename":"job.log","file_format":null}],"runner":{"id":44949,"description":"shared-runners-manager-4.gitlab.com","ip_address":"13.37.237.197","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":117112915,"status":"failed","stage":"build","name":"build:edge+flambda","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:04.220Z","started_at":"2018-11-06T16:57:05.420Z","finished_at":"2018-11-06T17:02:30.637Z","duration":325.216499,"queued_duration":3217.327455,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"failure_reason":"script_failure","web_url":"https://gitlab.com/coq/coq/-/jobs/117112915","artifacts":[{"file_type":"trace","size":61737,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":117112913,"status":"failed","stage":"build","name":"build:edge","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:04.020Z","started_at":"2018-11-06T16:56:51.379Z","finished_at":"2018-11-06T17:05:28.307Z","duration":516.92829,"queued_duration":3203.2527,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"failure_reason":"script_failure","web_url":"https://gitlab.com/coq/coq/-/jobs/117112913","artifacts":[{"file_type":"trace","size":60566,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":117112904,"status":"failed","stage":"build","name":"build:base+32bit","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:03.551Z","started_at":"2018-11-06T16:56:51.231Z","finished_at":"2018-11-06T17:00:52.197Z","duration":240.965361,"queued_duration":3202.599066,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"failure_reason":"script_failure","web_url":"https://gitlab.com/coq/coq/-/jobs/117112904","artifacts":[{"file_type":"trace","size":57935,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
{"id":117112903,"status":"failed","stage":"build","name":"build:base","ref":"pr-6705","tag":false,"coverage":null,"allow_failure":false,"created_at":"2018-11-06T16:03:03.169Z","started_at":"2018-11-06T16:56:49.266Z","finished_at":"2018-11-06T17:04:48.558Z","duration":479.291471,"queued_duration":3199.6517,"user":{"id":2256237,"username":"coqbot","name":"coqbot","state":"active","avatar_url":"https://gitlab.com/uploads/-/system/user/avatar/2256237/avatar.png","web_url":"https://gitlab.com/coqbot","created_at":"2018-04-28T07:53:57.210Z","bio":"Hello, I'm a bot.","location":"","public_email":"","skype":"","linkedin":"","twitter":"","website_url":"","organization":"","job_title":"","pronouns":null,"bot":false,"work_information":null,"followers":0,"following":0,"local_time":null},"commit":{"id":"d54da4f75beba7d455eb996863b1ba88136b7aaa","short_id":"d54da4f7","created_at":"2018-11-06T17:02:44.000+01:00","parent_ids":["f6033667bd9b8069308d4bcba420c4ce0771e44f"],"title":"ssr: extended intro patterns","message":"ssr: extended intro patterns\n\nThis commit implements the extended intro patterns discussed in the\nQuill working group.\n\nDispatch \"=> ( | )\"\n this is like [|] but does not perform case (never: no ssr exceptions)\n\nTemporary \"=> +\"\n \"move=> + stuff\" ==== \"move=> tmp stuff; move: tmp\"\n It preserves the original name.\n \"=>\" can be chained to force generalization as in\n \"move=> + y + => x z\"\n\nTactics as views \"=> /ltac:(tactic)\"\n Supports notations, eg \"Notation foo := ltac:(bla bla bla). .. => /foo\".\n Limited to views on the right of \"=>\", views that decorate a tactic\n as move or case are not supported to be tactics.\n\nDependent \"=> >H\"\n move=> >H  ===== move=> ???? H, with enough ? to\n name H the first non-dependent assumption (LHS of the first arrow)\n\nBlock intro \"=> [^ H] [^~ H] ( ^H ) ( ^~H )\"\n after \"case\" or \"elim\" or \"elim/v\" it introduces in one go\n all new assumptions coming from the eliminations. The names are\n picked from the inductive type declaration or the elimination principle\n \"v\" in \"elim/v\" and are appended/prepended the seed \"H\"\n\nCustom simpl-switch \"=> /2/ /3= /4/5=\"\n  /$n/ maps to \"ssrdone$n\" while /n= maps to \"ssrsimpl$n\"\n  \"ssrdone0\" is taken by ssreflect (like done, but without split)\n\nThe implementation makes crucial use of the goal_with_state feature of\nthe tactic monad. For example + schedules a generalization to be performed\nat the end of the intro pattern and [^ .. ] reads the name seeds from\nthe state (that is filled in by case and elim).\n","author_name":"Enrico Tassi","author_email":"Enrico.Tassi@inria.fr","authored_date":"2018-08-29T13:11:24.000+02:00","committer_name":"Enrico Tassi","committer_email":"Enrico.Tassi@inria.fr","committed_date":"2018-11-06T17:02:44.000+01:00","trailers":{},"web_url":"https://gitlab.com/coq/coq/-/commit/d54da4f75beba7d455eb996863b1ba88136b7aaa"},"pipeline":{"id":35622009,"iid":4987,"project_id":6138686,"sha":"d54da4f75beba7d455eb996863b1ba88136b7aaa","ref":"pr-6705","status":"failed","source":"push","created_at":"2018-11-06T16:03:03.134Z","updated_at":"2018-11-06T17:14:50.730Z","web_url":"https://gitlab.com/coq/coq/-/pipelines/35622009"},"failure_reason":"script_failure","web_url":"https://gitlab.com/coq/coq/-/jobs/117112903","artifacts":[{"file_type":"trace","size":60864,"filename":"job.log","file_format":null}],"runner":{"id":380986,"description":"shared-runners-manager-5.gitlab.com","ip_address":"34.74.209.140","active":true,"paused":false,"is_shared":true,"runner_type":"instance_type","name":"gitlab-runner","online":false,"status":"stale"},"artifacts_expire_at":null,"tag_list":[]}
